import{_ as p}from"./ValaxyMain.vue_vue_type_style_index_0_lang-Bn109ln0.js";import{c,w as a,f as w,a as x,p as o,o as g,g as l,h as n,r as i}from"./app-DvGICojQ.js";import"./YunFooter.vue_vue_type_style_index_0_lang-6I6EwKPx.js";import"./YunCard.vue_vue_type_script_setup_true_lang-G2SLBOpE.js";import"./index-C5okkQwF.js";import"./YunPageHeader.vue_vue_type_script_setup_true_lang-B-GmT0Fn.js";import"./post-JeTKiWMk.js";const d="/assets/jdk-cfg-onVTy909.png",M="/assets/cfg-intro-eg-CsSVEfkg.png",y="/assets/inevitable-B-PLb8PM.png",k="/assets/avoidable-CHSJ_ILS.png",f="/assets/realizable-sPVgdyIz.png",b="/assets/cfl-reachable-DSdgCcIq.png",_="/assets/super-graph-Crbk1mXx.png",L="/assets/flow-functions-BuLQIlAJ.png",E="/assets/representation-relation-C822SwzB.png",v="/assets/exploded-supergraph-DPMA4nBB.png",F="/assets/gule-edge-CgtwAxe9.png",P="/assets/alg-eg-lZ1VHMTC.png",S="/assets/alg-res-DOQBRl-t.png",R="/assets/tb-core-DR8q--46.png",D="/assets/tb-res-Doe7PxA4.png",T="/assets/pointer-analysis-BNEUo085.png",B={__name:"20240809 11 CFL 可达与 IFDS",setup(C,{expose:r}){const m=JSON.parse('{"title":"11 CFL 可达与 IFDS","description":"","frontmatter":{"title":"11 CFL 可达与 IFDS","date":"2024-08-09T00:00:00.000Z","tags":["静态代码分析"],"categories":["静态代码分析"]},"headers":[{"level":2,"title":"11.1 可行路径与可实现路径","slug":"_11-1-可行路径与可实现路径","link":"#_11-1-可行路径与可实现路径","children":[{"level":3,"title":"11.1.1 可行路径","slug":"_11-1-1-可行路径","link":"#_11-1-1-可行路径","children":[]},{"level":3,"title":"11.1.2 可实现路径","slug":"_11-1-2-可实现路径","link":"#_11-1-2-可实现路径","children":[]}]},{"level":2,"title":"11.2 CFL 可达性","slug":"_11-2-cfl-可达性","link":"#_11-2-cfl-可达性","children":[{"level":3,"title":"11.2.1 上下文无关文法","slug":"_11-2-1-上下文无关文法","link":"#_11-2-1-上下文无关文法","children":[]},{"level":3,"title":"11.2.2 CFL 可达性","slug":"_11-2-2-cfl-可达性","link":"#_11-2-2-cfl-可达性","children":[]}]},{"level":2,"title":"11.3 IFDS 概述","slug":"_11-3-ifds-概述","link":"#_11-3-ifds-概述","children":[{"level":3,"title":"11.3.1 概念","slug":"_11-3-1-概念","link":"#_11-3-1-概念","children":[]},{"level":3,"title":"11.3.2 基本步骤","slug":"_11-3-2-基本步骤","link":"#_11-3-2-基本步骤","children":[]}]},{"level":2,"title":"11.4 超图与流函数","slug":"_11-4-超图与流函数","link":"#_11-4-超图与流函数","children":[{"level":3,"title":"11.4.1 超图的构建","slug":"_11-4-1-超图的构建","link":"#_11-4-1-超图的构建","children":[]},{"level":3,"title":"11.4.2 流函数的设计","slug":"_11-4-2-流函数的设计","link":"#_11-4-2-流函数的设计","children":[]}]},{"level":2,"title":"11.5 分解超图和制表算法","slug":"_11-5-分解超图和制表算法","link":"#_11-5-分解超图和制表算法","children":[{"level":3,"title":"11.5.1 代表关系","slug":"_11-5-1-代表关系","link":"#_11-5-1-代表关系","children":[]},{"level":3,"title":"11.5.2 构建分解超图","slug":"_11-5-2-构建分解超图","link":"#_11-5-2-构建分解超图","children":[]},{"level":3,"title":"11.5.3 关于粘边","slug":"_11-5-3-关于粘边","link":"#_11-5-3-关于粘边","children":[]},{"level":3,"title":"11.5.4 制表算法","slug":"_11-5-4-制表算法","link":"#_11-5-4-制表算法","children":[]}]},{"level":2,"title":"11.6 理解 IFDS 的分配性","slug":"_11-6-理解-ifds-的分配性","link":"#_11-6-理解-ifds-的分配性","children":[{"level":3,"title":"11.6.1 分配性的理解和判断","slug":"_11-6-1-分配性的理解和判断","link":"#_11-6-1-分配性的理解和判断","children":[]},{"level":3,"title":"11.6.2 指针分析","slug":"_11-6-2-指针分析","link":"#_11-6-2-指针分析","children":[]}]},{"level":2,"title":"11.7 自检问题","slug":"_11-7-自检问题","link":"#_11-7-自检问题","children":[]}],"relativePath":"pages/posts/静态代码分析/20240809 11 CFL 可达与 IFDS/20240809 11 CFL 可达与 IFDS.md","path":"/home/runner/work/LiuZhuJunYa.github.io/LiuZhuJunYa.github.io/pages/posts/静态代码分析/20240809 11 CFL 可达与 IFDS/20240809 11 CFL 可达与 IFDS.md","lastUpdated":1731428437000}'),e=x(),s=m.frontmatter||{};return e.meta.frontmatter=Object.assign(e.meta.frontmatter||{},m.frontmatter||{}),o("pageData",m),o("valaxy:frontmatter",s),globalThis.$frontmatter=s,r({frontmatter:{title:"11 CFL 可达与 IFDS",date:"2024-08-09T00:00:00.000Z",tags:["静态代码分析"],categories:["静态代码分析"]}}),(t,u)=>{const h=p;return g(),c(h,{frontmatter:w(s)},{"main-content-md":a(()=>u[0]||(u[0]=[l("p",null,[n("原文链接："),l("a",{href:"https://static-analysis.cuijiacai.com/11-ifds/",target:"_blank",rel:"noreferrer"},"https://static-analysis.cuijiacai.com/11-ifds/")],-1),l("h1",{id:"_11-cfl-可达与-ifds",tabindex:"-1"},[n("11 CFL 可达与 IFDS "),l("a",{class:"header-anchor",href:"#_11-cfl-可达与-ifds","aria-label":'Permalink to "11 CFL 可达与 IFDS"'},"​")],-1),l("h2",{id:"_11-1-可行路径与可实现路径",tabindex:"-1"},[n("11.1 可行路径与可实现路径 "),l("a",{class:"header-anchor",href:"#_11-1-可行路径与可实现路径","aria-label":'Permalink to "11.1 可行路径与可实现路径"'},"​")],-1),l("h3",{id:"_11-1-1-可行路径",tabindex:"-1"},[n("11.1.1 可行路径 "),l("a",{class:"header-anchor",href:"#_11-1-1-可行路径","aria-label":'Permalink to "11.1.1 可行路径"'},"​")],-1),l("p",null,[n("到现在为止，为了演示方便，我们讲过的例子都是比较简单的。但在实际应用当中，一个程序可以是很复杂的，比如说下图是JDK中的"),l("strong",null,"一个"),n("方法的真实的控制流图：")],-1),l("figure",null,[l("img",{src:d,alt:"jdk-cfg",loading:"lazy",decoding:"async"})],-1),l("p",null,"这个控制流图肉眼可见的胖达，但是这张图里面的所有的路径，在程序运行的时候都会被执行吗？",-1),l("p",null,"答案是否定的，更准确的说，如果是一个单线程的基本的程序的话，真实的控制流其实只会执行众多路径中的一条路径而已。不过，这不妨碍有很多路径都存在被执行的可能性，这是由具体的程序输入所决定的；但是，有一些路径，是永远也不可能被执行的。",-1),l("div",{class:"definition"},[l("p",{class:"title"},"定义11.1"),l("p",null,[n("称在CFG中，当实际运行时，某个特定的输入下，控制流会经过的路径为 "),l("strong",null,"可行路径（Feasible Path）"),n(" ；相反，如果任何输入下，控制流都不经过某条路径，那么这条路径就称为 "),l("strong",null,"不可行路径（Infeasible Path）"),n(" 。")])],-1),l("p",null,"我们希望程序分析的结果不会被不可行路径污染，或者尽可能少得被不可行路径污染。但是，在静态分析的阶段，给定一个路径，判断它是否可行在整体上是不现实的，因为静态分析阶段我们并不知道这个程序的具体输入是什么，而一个路径是否会被执行又是与具体的输入息息相关的。",-1),l("p",null,"那我们还有希望能够做点什么吗？答案是能的。我们先来看下面这个例子：",-1),l("div",{class:"language-java vp-adaptive-theme"},[l("button",{title:"Copy Code",class:"copy"}),l("span",{class:"lang"},"java"),l("pre",{class:"shiki shiki-themes github-light github-dark vp-code"},[l("code",{"v-pre":""},[l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"void"),l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}}," main"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"() {")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    x "),l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}}," foo"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"("),l("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"8"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},");")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    ...")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    y "),l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}}," foo"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"("),l("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"30"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},");")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    ...")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")]),n(`
`),l("span",{class:"line"}),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"int"),l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}}," foo"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"("),l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"int"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," age) {")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"    if"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," (age "),l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},">="),l("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," 0"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},") ")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        r "),l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," age;")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"    else")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        r "),l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}}," -"),l("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"1"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},";")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"    return"),l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}}," -"),l("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"1"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},";")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])]),l("button",{class:"collapse"})],-1),l("p",null,"这个程序的控制流图为：",-1),l("p",{style:{"text-align":"center"}},[l("img",{src:M,alt:"cfg-intro-eg",style:{zoom:"25%"}})],-1),l("p",null,[n("在这幅图当中进行常量传播的分析，考虑x和y的取值情况，我们会发现x和y的结果都是 "),l("code",null,"{18, 30, -1}"),n(" ，也就是最没用的 "),l("code",null,"NAC"),n(" 。但我们很明显能够看到， "),l("code",null,"x = 18"),n(" ， "),l("code",null,"y = 30"),n(" 。")],-1),l("p",null,"以x为例，在x的结果当中，有两个假积极（False Positive，见定义1.5），30 和 -1。我们分别来考虑这两个假积极是怎样产生的。",-1),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"-1"),n(" 是由于下图中标红色的部分产生的，这个假积极是我们无法避免的。")]),l("ul",null,[l("li",null,"因为从静态分析的角度，我们并不知道这个函数的输入是什么，根据安全近似（Safe-Approximation, 见定义 3.1）的原则，我们应该进行过近似（Over-Approximation，见定义 1.3），因此左边和右边的路径都只能保留下来。")])])],-1),l("p",{style:{"text-align":"center"}},[l("img",{src:y,alt:"inevitable",style:{zoom:"25%"}})],-1),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"30"),n(" 是由于下图中标红色的部分产生的，这个假积极是我们可以避免的。")]),l("ul",null,[l("li",null,[l("p",null,[n("因为从 "),l("code",null,"foo(30)"),n(" 调用点出发的调用控制流，不可能会回到 "),l("code",null,"foo(18)"),n(" 的返回点，这一点是和程序的输入无关的，是在静态分析的阶段我们就可以确定下来的。")])]),l("li",null,[l("p",null,"言下之意，如果我们能够避免这样的不可行路径，我们至少可以再提高一些静态分析的精度。")])])])],-1),l("p",{style:{"text-align":"center"}},[l("img",{src:k,alt:"avoidable",style:{zoom:"25%"}})],-1),l("h3",{id:"_11-1-2-可实现路径",tabindex:"-1"},[n("11.1.2 可实现路径 "),l("a",{class:"header-anchor",href:"#_11-1-2-可实现路径","aria-label":'Permalink to "11.1.2 可实现路径"'},"​")],-1),l("div",{class:"definition"},[l("p",{class:"title"},"定义11.2"),l("p",null,[n("称返回边和调用边（见定义5.8）相匹配的路径为 "),l("strong",null,"可实现路径（Realizable Path）"),n("，不匹配则称为 "),l("strong",null,"不可实现路径（Unrealizable Path）"),n(" 。")]),l("p",null,"这里，相匹配指的是符合程序运行的逻辑（具体形式化定义见11.2节）。")],-1),l("p",null,"我们会发现，一个可实现的路径不一定会被执行，但是一个不可实现的路径一定不会被执行。",-1),l("p",null,"所以，我们现在的目标就是识别出可实现的路径，且只分析这些路径，从而避免不可实现的路径对我们静态分析结果产生的污染，这样我们就可以提高静态分析的精度。",-1),l("p",{style:{"text-align":"center"}},[l("img",{src:f,alt:"realizable",style:{zoom:"25%"}})],-1),l("p",null,"那怎样才能系统地识别可实现的路径呢？这种调用边和返回边匹配的问题恰好和我们以前遇到过的括号匹配的问题很像。",-1),l("p",null,"下面我们会以一种特殊的更抽象的视角来考量路径，将路径建模成一种语言，然后再回头，应用这种视角来解决偏括号匹配问题（偏匹配是因为可实现路径的半路上括号不一定是完全匹配的，后续会给出形式化的完整定义）。",-1),l("h2",{id:"_11-2-cfl-可达性",tabindex:"-1"},[n("11.2 CFL 可达性 "),l("a",{class:"header-anchor",href:"#_11-2-cfl-可达性","aria-label":'Permalink to "11.2 CFL 可达性"'},"​")],-1),l("h3",{id:"_11-2-1-上下文无关文法",tabindex:"-1"},[n("11.2.1 上下文无关文法 "),l("a",{class:"header-anchor",href:"#_11-2-1-上下文无关文法","aria-label":'Permalink to "11.2.1 上下文无关文法"'},"​")],-1),l("div",{class:"definition"},[l("p",{class:"title"},"定义11.3"),l("p",null,[n("定义 "),l("strong",null,"语言（Language）"),n(" 是字符串的集合，其中 "),l("strong",null,"字符串（String）"),n(" 是一个符号序列，所有可能的 "),l("strong",null,"符号（Symbol）"),n(" 构成了这个语言的 "),l("strong",null,"字母表（Alphabet）"),n(" 。 用 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"L")]),l("annotation",{encoding:"application/x-tex"},"L")])])]),n(" 表示语言， "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",{mathvariant:"normal"},"Σ")]),l("annotation",{encoding:"application/x-tex"},"\\Sigma")])])]),n(" 表示字母表，则可以形式化的描述语言：")]),l("p",null,[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[l("semantics",null,[l("mrow",null,[l("mi",null,"L"),l("mo",null,"⊆"),l("mo",{stretchy:"false"},"{"),l("mi",null,"s"),l("mi",{mathvariant:"normal"},"∣"),l("mi",null,"s"),l("mo",null,"="),l("msub",null,[l("mi",null,"a"),l("mn",null,"1")]),l("msub",null,[l("mi",null,"a"),l("mn",null,"2")]),l("mi",{mathvariant:"normal"},"."),l("mi",{mathvariant:"normal"},"."),l("mi",{mathvariant:"normal"},"."),l("msub",null,[l("mi",null,"a"),l("mi",null,"n")]),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"a"),l("mi",null,"i")]),l("mo",null,"∈"),l("mi",{mathvariant:"normal"},"Σ"),l("mo",{separator:"true"},","),l("mi",null,"n"),l("mo",null,"∈"),l("mi",{mathvariant:"double-struck"},"N"),l("mo",{stretchy:"false"},"}")]),l("annotation",{encoding:"application/x-tex"},"L \\subseteq \\{s| s = a_1a_2...a_n, a_i\\in \\Sigma, n \\in\\mathbb{N}\\} ")])])])]),l("p",null,[n("其中，当 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"n"),l("mo",null,"="),l("mn",null,"0")]),l("annotation",{encoding:"application/x-tex"},"n = 0")])])]),n(" 时，用 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"ε")]),l("annotation",{encoding:"application/x-tex"},"\\varepsilon")])])]),n(" 表示空字符串。")])],-1),l("p",null,[n("具体 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"L")]),l("annotation",{encoding:"application/x-tex"},"L")])])]),n(" 的边界可以自定义规则进行限制（比如说用形式文法（见定义11.6）描述），也可直接列举法表示，只要理解语言（这里）本质上是一个集合就可以了。")],-1),l("div",{class:"definition"},[l("p",{class:"title"},"定义11.4"),l("p",null,[n("称在数学、逻辑学以及计算机学科中，用精确的数学公式或者算法描述的语言为 "),l("strong",null,"形式语言（Formal Language）"),n(" 。")])],-1),l("div",{class:"definition"},[l("p",{class:"title"},"定义11.5"),l("p",null,[n("定义 "),l("strong",null,"产生式（Production Rule）"),n(" 形如：")]),l("p",null,[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[l("semantics",null,[l("mrow",null,[l("mi",null,"S"),l("mo",null,"→"),l("msup",null,[l("mi",null,"S"),l("mo",{mathvariant:"normal",lspace:"0em",rspace:"0em"},"′")])]),l("annotation",{encoding:"application/x-tex"},"S \\to S' ")])])])]),l("p",null,[n("表示字符串 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"S")]),l("annotation",{encoding:"application/x-tex"},"S")])])]),n(" 在规则 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"S"),l("mo",null,"→"),l("msup",null,[l("mi",null,"S"),l("mo",{mathvariant:"normal",lspace:"0em",rspace:"0em"},"′")])]),l("annotation",{encoding:"application/x-tex"},"S \\to S'")])])]),n(" 的作用下可以生成字符串 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msup",null,[l("mi",null,"S"),l("mo",{mathvariant:"normal",lspace:"0em",rspace:"0em"},"′")])]),l("annotation",{encoding:"application/x-tex"},"S'")])])]),n(" 。")]),l("p",null,"前提相同的多个产生式可承前省略，形如："),l("p",null,[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[l("semantics",null,[l("mtable",{rowspacing:"0.25em",columnalign:"right left",columnspacing:"0em"},[l("mtr",null,[l("mtd",null,[l("mstyle",{scriptlevel:"0",displaystyle:"true"},[l("mi",null,"S")])]),l("mtd",null,[l("mstyle",{scriptlevel:"0",displaystyle:"true"},[l("mrow",null,[l("mrow"),l("mo",null,"→"),l("msub",null,[l("mi",null,"S"),l("mn",null,"1")])])])])]),l("mtr",null,[l("mtd",null,[l("mstyle",{scriptlevel:"0",displaystyle:"true"},[l("mrow")])]),l("mtd",null,[l("mstyle",{scriptlevel:"0",displaystyle:"true"},[l("mrow",null,[l("mrow"),l("mo",null,"→"),l("msub",null,[l("mi",null,"S"),l("mn",null,"2")])])])])]),l("mtr",null,[l("mtd",null,[l("mstyle",{scriptlevel:"0",displaystyle:"true"},[l("mrow")])]),l("mtd",null,[l("mstyle",{scriptlevel:"0",displaystyle:"true"},[l("mrow",null,[l("mrow"),l("mo",null,"…"),l("mo",null,"…")])])])]),l("mtr",null,[l("mtd",null,[l("mstyle",{scriptlevel:"0",displaystyle:"true"},[l("mrow")])]),l("mtd",null,[l("mstyle",{scriptlevel:"0",displaystyle:"true"},[l("mrow",null,[l("mrow"),l("mo",null,"→"),l("msub",null,[l("mi",null,"S"),l("mi",null,"n")])])])])])]),l("annotation",{encoding:"application/x-tex"},"\\begin{aligned} S &\\to S_1\\\\ &\\to S_2\\\\ &\\dots\\dots\\\\ &\\to S_n \\end{aligned} ")])])])])],-1),l("p",null,"有了单个的产生式，我们只要应用多个产生式或者重复应用某个产生式，就可以从某个起点推导出一些字符串，所有能推导出的字符串的集合就形成了语言。",-1),l("div",{class:"definition"},[l("p",{class:"title"},"定义11.6"),l("p",null,[n("定义一个形式语言的 "),l("strong",null,"形式文法（Formal Grammar）"),n(" 是由若干条产生式组成的集合。")]),l("p",null,[n("称一个形式文法中无法应用产生式进行推导的符号为 "),l("strong",null,"终结符（Terminals）"),n(" ，也就是从来没有出现在产生式左边的符号，其他符号成为 "),l("strong",null,"非终结符（Nonterminal）"),n(" 。")]),l("p",null,"给定某些起始的非终结符，能够推导出的所有终结符字符串所形成的集合，就称为该形式文法在给定的起始符号下的形式语言。")],-1),l("div",{class:"definition"},[l("p",{class:"title"},"定义11.7"),l("p",null,[l("strong",null,"上下文无关文法（Context-free Grammar）"),n(" 是一个形式文法，其中，每一个推导式都形如")]),l("p",null,[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[l("semantics",null,[l("mrow",null,[l("mi",null,"S"),l("mo",null,"→"),l("mi",null,"α")]),l("annotation",{encoding:"application/x-tex"},"S \\to \\alpha ")])])])]),l("p",null,[n("其中，"),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"S")]),l("annotation",{encoding:"application/x-tex"},"S")])])]),n(" 是单个非终结符，规定唯一的起始符号，而 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"α")]),l("annotation",{encoding:"application/x-tex"},"\\alpha")])])]),n(" 可以是终结符与/或非终结符形成的字符串，也可以是空字符串。")]),l("p",null,[n("称由上下文无关文法推导出来的语言为 "),l("strong",null,"上下文无关语言（Context-free Language, CFL）"),n("。")])],-1),l("h3",{id:"_11-2-2-cfl-可达性",tabindex:"-1"},[n("11.2.2 CFL 可达性 "),l("a",{class:"header-anchor",href:"#_11-2-2-cfl-可达性","aria-label":'Permalink to "11.2.2 CFL 可达性"'},"​")],-1),l("div",{class:"definition"},[l("p",{class:"title"},"定义11.8"),l("p",null,[n("为一张有向图中的每条边打上标签，称结点B从结点A "),l("strong",null,"CFL可达（CFL Reachable）"),n("，如果存在从A到B的路径，该路径上每条边的标签组成了某个特定的上下文无关语言的合法字符串。")]),l("p",null,"其中，这个上下文无关语言是根据需求相应定义的。")],-1),l("p",null,[n("有了上面的基础，我们可以通过CFL定义出 "),l("strong",null,"部分平衡括号问题（Partially Balanced-Parenthesis Problem）"),n("：")],-1),l("ul",null,[l("li",null,[n("每个右括号 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mo",{stretchy:"false"},")"),l("mi",null,"i")])]),l("annotation",{encoding:"application/x-tex"},")_i")])])]),n(" 都应当有一个左括号 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mo",{stretchy:"false"},"("),l("mi",null,"i")])]),l("annotation",{encoding:"application/x-tex"},"(_i")])])]),n(" 与之平衡，但反之不亦然；")]),l("li",null,[n("对于每个调用点 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"i")]),l("annotation",{encoding:"application/x-tex"},"i")])])]),n(" ，将它的调用边标记为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mo",{stretchy:"false"},"("),l("mi",null,"i")])]),l("annotation",{encoding:"application/x-tex"},"(_i")])])]),n(" ，返回边标记为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mo",{stretchy:"false"},")"),l("mi",null,"i")])]),l("annotation",{encoding:"application/x-tex"},")_i")])])]),n(" ；")]),l("li",null,[n("将其他所有的边标记为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"e")]),l("annotation",{encoding:"application/x-tex"},"e")])])]),n(" 。")])],-1),l("p",null,[n("于是，我们会发现，一个路径是可实现的，当且仅当这个路径上的标记所形成的字符串在语言 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"L"),l("mo",{stretchy:"false"},"("),l("mi",null,"r"),l("mi",null,"e"),l("mi",null,"a"),l("mi",null,"l"),l("mi",null,"i"),l("mi",null,"z"),l("mi",null,"a"),l("mi",null,"b"),l("mi",null,"l"),l("mi",null,"e"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"L(realizable)")])])]),n(" 中，其中：")],-1),l("p",null,[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[l("semantics",null,[l("mtable",{rowspacing:"0.25em",columnalign:"right left",columnspacing:"0em"},[l("mtr",null,[l("mtd",null,[l("mstyle",{scriptlevel:"0",displaystyle:"true"},[l("mrow",null,[l("mi",null,"r"),l("mi",null,"e"),l("mi",null,"a"),l("mi",null,"l"),l("mi",null,"i"),l("mi",null,"z"),l("mi",null,"a"),l("mi",null,"b"),l("mi",null,"l"),l("mi",null,"e")])])]),l("mtd",null,[l("mstyle",{scriptlevel:"0",displaystyle:"true"},[l("mrow",null,[l("mrow"),l("mo",null,"→"),l("mi",null,"m"),l("mi",null,"a"),l("mi",null,"t"),l("mi",null,"c"),l("mi",null,"h"),l("mi",null,"e"),l("mi",null,"d"),l("mtext",null," "),l("mi",null,"r"),l("mi",null,"e"),l("mi",null,"a"),l("mi",null,"l"),l("mi",null,"i"),l("mi",null,"z"),l("mi",null,"a"),l("mi",null,"b"),l("mi",null,"l"),l("mi",null,"e")])])])]),l("mtr",null,[l("mtd",null,[l("mstyle",{scriptlevel:"0",displaystyle:"true"},[l("mrow")])]),l("mtd",null,[l("mstyle",{scriptlevel:"0",displaystyle:"true"},[l("mrow",null,[l("mrow"),l("mo",null,"→"),l("msub",null,[l("mo",{stretchy:"false"},"("),l("mi",null,"i")]),l("mtext",null," "),l("mi",null,"r"),l("mi",null,"e"),l("mi",null,"a"),l("mi",null,"l"),l("mi",null,"i"),l("mi",null,"z"),l("mi",null,"a"),l("mi",null,"b"),l("mi",null,"l"),l("mi",null,"e")])])])]),l("mtr",null,[l("mtd",null,[l("mstyle",{scriptlevel:"0",displaystyle:"true"},[l("mrow")])]),l("mtd",null,[l("mstyle",{scriptlevel:"0",displaystyle:"true"},[l("mrow",null,[l("mrow"),l("mo",null,"→"),l("mi",null,"ε")])])])]),l("mtr",null,[l("mtd",null,[l("mstyle",{scriptlevel:"0",displaystyle:"true"},[l("mrow",null,[l("mi",null,"m"),l("mi",null,"a"),l("mi",null,"t"),l("mi",null,"c"),l("mi",null,"h"),l("mi",null,"e"),l("mi",null,"d")])])]),l("mtd",null,[l("mstyle",{scriptlevel:"0",displaystyle:"true"},[l("mrow",null,[l("mrow"),l("mo",null,"→"),l("msub",null,[l("mo",{stretchy:"false"},"("),l("mi",null,"i")]),l("mtext",null," "),l("mi",null,"m"),l("mi",null,"a"),l("mi",null,"t"),l("mi",null,"c"),l("mi",null,"h"),l("mi",null,"e"),l("mi",null,"d"),l("mtext",null," "),l("msub",null,[l("mo",{stretchy:"false"},")"),l("mi",null,"i")])])])])]),l("mtr",null,[l("mtd",null,[l("mstyle",{scriptlevel:"0",displaystyle:"true"},[l("mrow")])]),l("mtd",null,[l("mstyle",{scriptlevel:"0",displaystyle:"true"},[l("mrow",null,[l("mrow"),l("mo",null,"→"),l("mi",null,"e")])])])]),l("mtr",null,[l("mtd",null,[l("mstyle",{scriptlevel:"0",displaystyle:"true"},[l("mrow")])]),l("mtd",null,[l("mstyle",{scriptlevel:"0",displaystyle:"true"},[l("mrow",null,[l("mrow"),l("mo",null,"→"),l("mi",null,"ε")])])])]),l("mtr",null,[l("mtd",null,[l("mstyle",{scriptlevel:"0",displaystyle:"true"},[l("mrow")])]),l("mtd",null,[l("mstyle",{scriptlevel:"0",displaystyle:"true"},[l("mrow",null,[l("mrow"),l("mo",null,"→"),l("mi",null,"m"),l("mi",null,"a"),l("mi",null,"t"),l("mi",null,"c"),l("mi",null,"h"),l("mi",null,"e"),l("mi",null,"d"),l("mtext",null," "),l("mi",null,"m"),l("mi",null,"a"),l("mi",null,"t"),l("mi",null,"c"),l("mi",null,"h"),l("mi",null,"e"),l("mi",null,"d")])])])])]),l("annotation",{encoding:"application/x-tex"},"\\begin{aligned} realizable &\\to matched\\ realizable\\\\ &\\to (_i\\ realizable\\\\ &\\to \\varepsilon\\\\ matched &\\to (_i\\ matched\\ )_i\\\\ &\\to e\\\\ &\\to \\varepsilon\\\\ &\\to matched\\ matched \\end{aligned} ")])])])],-1),l("p",null,[n("比如说， "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mo",{stretchy:"false"},"("),l("mn",null,"1")]),l("msub",null,[l("mo",{stretchy:"false"},"("),l("mn",null,"2")]),l("mi",null,"e"),l("msub",null,[l("mo",{stretchy:"false"},")"),l("mn",null,"2")]),l("msub",null,[l("mo",{stretchy:"false"},")"),l("mn",null,"1")]),l("msub",null,[l("mo",{stretchy:"false"},"("),l("mn",null,"3")])]),l("annotation",{encoding:"application/x-tex"},"(_1(_2e)_2)_1(_3")])])]),n(" 、"),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mo",{stretchy:"false"},"("),l("mn",null,"1")]),l("msub",null,[l("mo",{stretchy:"false"},"("),l("mn",null,"2")]),l("mi",null,"e"),l("msub",null,[l("mo",{stretchy:"false"},")"),l("mn",null,"2")]),l("msub",null,[l("mo",{stretchy:"false"},")"),l("mn",null,"1")]),l("msub",null,[l("mo",{stretchy:"false"},"("),l("mn",null,"3")]),l("msub",null,[l("mo",{stretchy:"false"},"("),l("mn",null,"4")])]),l("annotation",{encoding:"application/x-tex"},"(_1(_2e)_2)_1(_3(_4")])])]),n(" 、 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mo",{stretchy:"false"},"("),l("mn",null,"1")]),l("msub",null,[l("mo",{stretchy:"false"},"("),l("mn",null,"2")]),l("mi",null,"e"),l("mi",null,"e"),l("mi",null,"e"),l("msub",null,[l("mo",{stretchy:"false"},")"),l("mn",null,"2")]),l("msub",null,[l("mo",{stretchy:"false"},")"),l("mn",null,"1")]),l("msub",null,[l("mo",{stretchy:"false"},"("),l("mn",null,"3")]),l("msub",null,[l("mo",{stretchy:"false"},"("),l("mn",null,"4")])]),l("annotation",{encoding:"application/x-tex"},"(_1(_2eee)_2)_1(_3(_4")])])]),n(" 、 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"e"),l("mi",null,"e"),l("msub",null,[l("mo",{stretchy:"false"},"("),l("mn",null,"1")]),l("msub",null,[l("mo",{stretchy:"false"},"("),l("mn",null,"2")]),l("mi",null,"e"),l("mi",null,"e"),l("mi",null,"e"),l("msub",null,[l("mo",{stretchy:"false"},")"),l("mn",null,"2")]),l("msub",null,[l("mo",{stretchy:"false"},")"),l("mn",null,"1")]),l("msub",null,[l("mo",{stretchy:"false"},"("),l("mn",null,"3")]),l("msub",null,[l("mo",{stretchy:"false"},"("),l("mn",null,"4")]),l("mi",null,"e")]),l("annotation",{encoding:"application/x-tex"},"ee(_1(_2eee)_2)_1(_3(_4e")])])]),n(" 都是合法的 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"L"),l("mo",{stretchy:"false"},"("),l("mi",null,"r"),l("mi",null,"e"),l("mi",null,"a"),l("mi",null,"l"),l("mi",null,"i"),l("mi",null,"z"),l("mi",null,"a"),l("mi",null,"b"),l("mi",null,"l"),l("mi",null,"e"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"L(realizable)")])])]),n(" 字符串。")],-1),l("blockquote",null,[l("p",null,[n("注： "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"L"),l("mo",{stretchy:"false"},"("),l("mi",null,"r"),l("mi",null,"e"),l("mi",null,"a"),l("mi",null,"l"),l("mi",null,"i"),l("mi",null,"z"),l("mi",null,"a"),l("mi",null,"b"),l("mi",null,"l"),l("mi",null,"e"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"L(realizable)")])])]),n(" 表示语言 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"L")]),l("annotation",{encoding:"application/x-tex"},"L")])])]),n(" 由文法中的 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"r"),l("mi",null,"e"),l("mi",null,"a"),l("mi",null,"l"),l("mi",null,"i"),l("mi",null,"z"),l("mi",null,"a"),l("mi",null,"b"),l("mi",null,"l"),l("mi",null,"e")]),l("annotation",{encoding:"application/x-tex"},"realizable")])])]),n(" 作为起始符号所产生的。")])],-1),l("p",null,"例如：",-1),l("p",{style:{"text-align":"center"}},[l("img",{src:b,alt:"cfl-reachable",style:{zoom:"30%"}})],-1),l("p",null,[n("左图中路径的标签形成的单词是 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"e"),l("msub",null,[l("mo",{stretchy:"false"},"("),l("mn",null,"1")]),l("mi",null,"e"),l("mi",null,"e"),l("mi",null,"e"),l("msub",null,[l("mo",{stretchy:"false"},")"),l("mn",null,"1")]),l("mi",null,"e"),l("mo",null,"∈"),l("mi",null,"L"),l("mo",{stretchy:"false"},"("),l("mi",null,"r"),l("mi",null,"e"),l("mi",null,"a"),l("mi",null,"l"),l("mi",null,"i"),l("mi",null,"z"),l("mi",null,"a"),l("mi",null,"b"),l("mi",null,"l"),l("mi",null,"e"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"e(_1eee)_1e \\in L(realizable)")])])]),n(" ，所以该路径是可实现的；而右图中路径的标签形成的单词是 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"e"),l("msub",null,[l("mo",{stretchy:"false"},"("),l("mn",null,"1")]),l("mi",null,"e"),l("mi",null,"e"),l("mi",null,"e"),l("msub",null,[l("mo",{stretchy:"false"},")"),l("mn",null,"1")]),l("mi",null,"e"),l("msub",null,[l("mo",{stretchy:"false"},"("),l("mn",null,"2")]),l("mi",null,"e"),l("mi",null,"e"),l("mi",null,"e"),l("msub",null,[l("mo",{stretchy:"false"},")"),l("mn",null,"1")]),l("mo",{mathvariant:"normal"},"∉"),l("mi",null,"L"),l("mo",{stretchy:"false"},"("),l("mi",null,"r"),l("mi",null,"e"),l("mi",null,"a"),l("mi",null,"l"),l("mi",null,"i"),l("mi",null,"z"),l("mi",null,"a"),l("mi",null,"b"),l("mi",null,"l"),l("mi",null,"e"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"e(_1eee)_1e(_2eee)_1 \\notin L(realizable)")])])]),n(" ，所以该路径是不可实现的。")],-1),l("h2",{id:"_11-3-ifds-概述",tabindex:"-1"},[n("11.3 IFDS 概述 "),l("a",{class:"header-anchor",href:"#_11-3-ifds-概述","aria-label":'Permalink to "11.3 IFDS 概述"'},"​")],-1),l("h3",{id:"_11-3-1-概念",tabindex:"-1"},[n("11.3.1 概念 "),l("a",{class:"header-anchor",href:"#_11-3-1-概念","aria-label":'Permalink to "11.3.1 概念"'},"​")],-1),l("p",null,"IFDS 是一种通过图可达性的方式进行静态程序分析的框架。",-1),l("blockquote",null,[l("p",null,"“Precise Interprocedural Dataflow Analysis via Graph Reachability” —— Thomas Reps, Susan Horwitz, and Mooly Sagiv, POPL’95")],-1),l("div",{class:"definition"},[l("p",{class:"title"},"定义11.9"),l("p",null,[l("strong",null,"IFDS（Interprocedural Finite Distributive Subset Problem）"),n(" 指的是一类过程间（Interprocedural）数据流分析的子问题，其流函数具有分配性（Distributive），定义域（Domain，见定义3.5）是有限（Finite）集。")]),l("p",null,[n("其中， "),l("strong",null,"流函数（Flow Functions）"),n(" 由结点转移（node Transfer，见定义5.12）和边转移（见定义5.11）组成。")])],-1),l("p",null,"IFDS为数据流分析提供了一种可实现全路汇集（MRP）的解决方案，在定义4.14中，我们定义了全路汇集（MOP）的解决方案，MRP的定义也是类似的。",-1),l("div",{class:"definition"},[l("p",{class:"title"},"定义11.10"),l("p",null,[n("基于定义4.13以及定理4.10，和定义4.14类似，定义 "),l("strong",null,"可实现全路汇集（Meet-Over-All-Realizable-Paths, MRP）"),n(" 的解决方案（以前向分析为例，后向分析倒过来即可）通过如下步骤计算某个程序点 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",{stretchy:"false"},"("),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"s"),l("mrow",null,[l("mi",null,"i"),l("mo",null,"+"),l("mn",null,"1")])]),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"(s_i, s_{i+1})")])])]),n(" （见定义3.4）处的数据流值，记为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"M"),l("mi",null,"R"),l("mi",null,"P"),l("mo",{stretchy:"false"},"["),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"MRP[s_i]")])])]),n(" ：")]),l("ul",null,[l("li",null,[l("p",null,[n("考虑从程序入口到 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"s"),l("mi",null,"i")])]),l("annotation",{encoding:"application/x-tex"},"s_i")])])]),n(" 处的路径 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"P")]),l("annotation",{encoding:"application/x-tex"},"P")])])]),n(" 的 "),l("strong",null,"流函数（Flow Function）"),n(" 为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"F"),l("mi",null,"P")])]),l("annotation",{encoding:"application/x-tex"},"F_P")])])]),n(" ，所有可实现路径的集合记为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"R"),l("mi",null,"P"),l("mi",null,"a"),l("mi",null,"t"),l("mi",null,"h"),l("mi",null,"s"),l("mo",{stretchy:"false"},"("),l("mi",null,"E"),l("mi",null,"N"),l("mi",null,"T"),l("mi",null,"R"),l("mi",null,"Y"),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"RPaths(ENTRY, s_i)")])])]),n(" ；")]),l("ul",null,[l("li",null,[l("p",null,"这里的流函数的作用类似于定义4.14中的状态转移方程，只不过4.14是结点转移，这里说的是边转移（结点转移可以转化成边转移，后续会有例子）。")]),l("li",null,[l("p",null,"一条路径的流函数，和定理4.10类似，是路径上边的流函数的复合。")])])]),l("li",null,[l("p",null,"使用联合（join）或者汇集（meet）操作来求这些值的最小上界或者最大下界。")])]),l("p",null,"形式化表示为："),l("p",null,[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[l("semantics",null,[l("mrow",null,[l("mi",null,"M"),l("mi",null,"R"),l("mi",null,"P"),l("mo",{stretchy:"false"},"["),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("munder",null,[l("mo",null,"⋁"),l("mrow",null,[l("mi",{mathvariant:"normal"},"∀"),l("mi",null,"P"),l("mo",null,"∈"),l("mi",null,"R"),l("mi",null,"P"),l("mi",null,"a"),l("mi",null,"t"),l("mi",null,"h"),l("mi",null,"s"),l("mo",{stretchy:"false"},"("),l("mi",null,"E"),l("mi",null,"N"),l("mi",null,"T"),l("mi",null,"R"),l("mi",null,"Y"),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",{stretchy:"false"},")")])]),l("msub",null,[l("mi",null,"F"),l("mi",null,"P")]),l("mo",{stretchy:"false"},"("),l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"E"),l("mi",null,"N"),l("mi",null,"T"),l("mi",null,"R"),l("mi",null,"Y"),l("mo",{stretchy:"false"},"]"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"MRP[s_i] = \\bigvee_{\\forall P \\in RPaths(ENTRY, s_i)} F_P(OUT[ENTRY]) ")])])])]),l("blockquote",null,[l("p",null,[n("此时，一般 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"E"),l("mi",null,"N"),l("mi",null,"T"),l("mi",null,"R"),l("mi",null,"Y"),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("mi",{mathvariant:"normal"},"⊥")]),l("annotation",{encoding:"application/x-tex"},"OUT[ENTRY] = \\bot")])])]),n(" ，详见 4.1.1。")])]),l("p",null,"或"),l("p",null,[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[l("semantics",null,[l("mrow",null,[l("mi",null,"M"),l("mi",null,"R"),l("mi",null,"P"),l("mo",{stretchy:"false"},"["),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("munder",null,[l("mo",null,"⋀"),l("mrow",null,[l("mi",{mathvariant:"normal"},"∀"),l("mi",null,"P"),l("mo",null,"∈"),l("mi",null,"R"),l("mi",null,"P"),l("mi",null,"a"),l("mi",null,"t"),l("mi",null,"h"),l("mi",null,"s"),l("mo",{stretchy:"false"},"("),l("mi",null,"E"),l("mi",null,"N"),l("mi",null,"T"),l("mi",null,"R"),l("mi",null,"Y"),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",{stretchy:"false"},")")])]),l("msub",null,[l("mi",null,"F"),l("mi",null,"P")]),l("mo",{stretchy:"false"},"("),l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"E"),l("mi",null,"N"),l("mi",null,"T"),l("mi",null,"R"),l("mi",null,"Y"),l("mo",{stretchy:"false"},"]"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"MRP[s_i] = \\bigwedge_{\\forall P \\in RPaths(ENTRY, s_i)} F_P(OUT[ENTRY]) ")])])])]),l("blockquote",null,[l("p",null,[n("此时，一般 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"E"),l("mi",null,"N"),l("mi",null,"T"),l("mi",null,"R"),l("mi",null,"Y"),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("mi",{mathvariant:"normal"},"⊤")]),l("annotation",{encoding:"application/x-tex"},"OUT[ENTRY] = \\top")])])]),n(" ，详见 4.1.2。")])])],-1),l("div",{class:"theorem"},[l("p",{class:"title"},"定理11.1"),l("p",null,"MRP 比 MOP 更准确（precise），具体地："),l("ul",null,[l("li",null,[l("p",null,[n("若进行可能性分析（May Analysis），采用联合操作，则 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"M"),l("mi",null,"R"),l("mi",null,"P"),l("mo",{stretchy:"false"},"["),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",{stretchy:"false"},"]"),l("mo",null,"⪯"),l("mi",null,"M"),l("mi",null,"O"),l("mi",null,"P"),l("mo",{stretchy:"false"},"["),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"MRP[s_i] \\preceq MOP[s_i]")])])]),n(" ；")])]),l("li",null,[l("p",null,[n("若进行必然性分析（Must Analysis），采用汇集操作，则 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"M"),l("mi",null,"O"),l("mi",null,"P"),l("mo",{stretchy:"false"},"["),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",{stretchy:"false"},"]"),l("mo",null,"⪯"),l("mi",null,"M"),l("mi",null,"R"),l("mi",null,"P"),l("mo",{stretchy:"false"},"["),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"MOP[s_i] \\preceq MRP[s_i]")])])]),n(" 。")])])])],-1),l("blockquote",null,[l("p",null,"证明：若采用联合操作："),l("p",null,[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[l("semantics",null,[l("mrow",null,[l("mi",null,"M"),l("mi",null,"R"),l("mi",null,"P"),l("mo",{stretchy:"false"},"["),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("munder",null,[l("mo",null,"⋁"),l("mrow",null,[l("mi",{mathvariant:"normal"},"∀"),l("mi",null,"P"),l("mo",null,"∈"),l("mi",null,"R"),l("mi",null,"P"),l("mi",null,"a"),l("mi",null,"t"),l("mi",null,"h"),l("mi",null,"s"),l("mo",{stretchy:"false"},"("),l("mi",null,"E"),l("mi",null,"N"),l("mi",null,"T"),l("mi",null,"R"),l("mi",null,"Y"),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",{stretchy:"false"},")")])]),l("msub",null,[l("mi",null,"F"),l("mi",null,"P")]),l("mo",{stretchy:"false"},"("),l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"E"),l("mi",null,"N"),l("mi",null,"T"),l("mi",null,"R"),l("mi",null,"Y"),l("mo",{stretchy:"false"},"]"),l("mo",{stretchy:"false"},")"),l("mspace",{linebreak:"newline"}),l("mo",null,"⪯"),l("munder",null,[l("mo",null,"⋁"),l("mrow",null,[l("mi",{mathvariant:"normal"},"∀"),l("mi",null,"P"),l("mo",null,"∈"),l("mi",null,"R"),l("mi",null,"P"),l("mi",null,"a"),l("mi",null,"t"),l("mi",null,"h"),l("mi",null,"s"),l("mo",{stretchy:"false"},"("),l("mi",null,"E"),l("mi",null,"N"),l("mi",null,"T"),l("mi",null,"R"),l("mi",null,"Y"),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",{stretchy:"false"},")")])]),l("msub",null,[l("mi",null,"F"),l("mi",null,"P")]),l("mo",{stretchy:"false"},"("),l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"E"),l("mi",null,"N"),l("mi",null,"T"),l("mi",null,"R"),l("mi",null,"Y"),l("mo",{stretchy:"false"},"]"),l("mo",{stretchy:"false"},")"),l("mo",null,"∨"),l("munder",null,[l("mo",null,"⋁"),l("mrow",null,[l("mi",{mathvariant:"normal"},"∀"),l("mi",null,"P"),l("mo",null,"∈"),l("mi",null,"P"),l("mi",null,"a"),l("mi",null,"t"),l("mi",null,"h"),l("mi",null,"s"),l("mo",{stretchy:"false"},"("),l("mi",null,"E"),l("mi",null,"N"),l("mi",null,"T"),l("mi",null,"R"),l("mi",null,"Y"),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",{stretchy:"false"},")"),l("mo",null,"−"),l("mi",null,"R"),l("mi",null,"P"),l("mi",null,"a"),l("mi",null,"t"),l("mi",null,"h"),l("mi",null,"s"),l("mo",{stretchy:"false"},"("),l("mi",null,"E"),l("mi",null,"N"),l("mi",null,"T"),l("mi",null,"R"),l("mi",null,"Y"),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",{stretchy:"false"},")")])]),l("msub",null,[l("mi",null,"F"),l("mi",null,"P")]),l("mo",{stretchy:"false"},"("),l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"E"),l("mi",null,"N"),l("mi",null,"T"),l("mi",null,"R"),l("mi",null,"Y"),l("mo",{stretchy:"false"},"]"),l("mo",{stretchy:"false"},")"),l("mspace",{linebreak:"newline"}),l("mo",null,"="),l("munder",null,[l("mo",null,"⋁"),l("mrow",null,[l("mi",{mathvariant:"normal"},"∀"),l("mi",null,"P"),l("mo",null,"∈"),l("mi",null,"P"),l("mi",null,"a"),l("mi",null,"t"),l("mi",null,"h"),l("mi",null,"s"),l("mo",{stretchy:"false"},"("),l("mi",null,"E"),l("mi",null,"N"),l("mi",null,"T"),l("mi",null,"R"),l("mi",null,"Y"),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",{stretchy:"false"},")")])]),l("msub",null,[l("mi",null,"F"),l("mi",null,"P")]),l("mo",{stretchy:"false"},"("),l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"E"),l("mi",null,"N"),l("mi",null,"T"),l("mi",null,"R"),l("mi",null,"Y"),l("mo",{stretchy:"false"},"]"),l("mo",{stretchy:"false"},")"),l("mo",null,"="),l("mi",null,"M"),l("mi",null,"O"),l("mi",null,"P"),l("mo",{stretchy:"false"},"["),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"MRP[s_i] = \\bigvee_{\\forall P \\in RPaths(ENTRY, s_i)} F_P(OUT[ENTRY])\\\\ \\preceq \\bigvee_{\\forall P \\in RPaths(ENTRY, s_i)} F_P(OUT[ENTRY]) \\vee \\bigvee_{\\forall P \\in Paths(ENTRY, s_i) - RPaths(ENTRY, s_i)} F_P(OUT[ENTRY])\\\\ = \\bigvee_{\\forall P \\in Paths(ENTRY, s_i)} F_P(OUT[ENTRY]) = MOP[s_i] ")])])])]),l("p",null,"若采用汇集操作："),l("p",null,[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[l("semantics",null,[l("mrow",null,[l("mi",null,"M"),l("mi",null,"O"),l("mi",null,"P"),l("mo",{stretchy:"false"},"["),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("munder",null,[l("mo",null,"⋀"),l("mrow",null,[l("mi",{mathvariant:"normal"},"∀"),l("mi",null,"P"),l("mo",null,"∈"),l("mi",null,"P"),l("mi",null,"a"),l("mi",null,"t"),l("mi",null,"h"),l("mi",null,"s"),l("mo",{stretchy:"false"},"("),l("mi",null,"E"),l("mi",null,"N"),l("mi",null,"T"),l("mi",null,"R"),l("mi",null,"Y"),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",{stretchy:"false"},")")])]),l("msub",null,[l("mi",null,"F"),l("mi",null,"P")]),l("mo",{stretchy:"false"},"("),l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"E"),l("mi",null,"N"),l("mi",null,"T"),l("mi",null,"R"),l("mi",null,"Y"),l("mo",{stretchy:"false"},"]"),l("mo",{stretchy:"false"},")"),l("mspace",{linebreak:"newline"}),l("mo",null,"="),l("munder",null,[l("mo",null,"⋀"),l("mrow",null,[l("mi",{mathvariant:"normal"},"∀"),l("mi",null,"P"),l("mo",null,"∈"),l("mi",null,"R"),l("mi",null,"P"),l("mi",null,"a"),l("mi",null,"t"),l("mi",null,"h"),l("mi",null,"s"),l("mo",{stretchy:"false"},"("),l("mi",null,"E"),l("mi",null,"N"),l("mi",null,"T"),l("mi",null,"R"),l("mi",null,"Y"),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",{stretchy:"false"},")")])]),l("msub",null,[l("mi",null,"F"),l("mi",null,"P")]),l("mo",{stretchy:"false"},"("),l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"E"),l("mi",null,"N"),l("mi",null,"T"),l("mi",null,"R"),l("mi",null,"Y"),l("mo",{stretchy:"false"},"]"),l("mo",{stretchy:"false"},")"),l("mo",null,"∧"),l("munder",null,[l("mo",null,"⋀"),l("mrow",null,[l("mi",{mathvariant:"normal"},"∀"),l("mi",null,"P"),l("mo",null,"∈"),l("mi",null,"P"),l("mi",null,"a"),l("mi",null,"t"),l("mi",null,"h"),l("mi",null,"s"),l("mo",{stretchy:"false"},"("),l("mi",null,"E"),l("mi",null,"N"),l("mi",null,"T"),l("mi",null,"R"),l("mi",null,"Y"),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",{stretchy:"false"},")"),l("mo",null,"−"),l("mi",null,"R"),l("mi",null,"P"),l("mi",null,"a"),l("mi",null,"t"),l("mi",null,"h"),l("mi",null,"s"),l("mo",{stretchy:"false"},"("),l("mi",null,"E"),l("mi",null,"N"),l("mi",null,"T"),l("mi",null,"R"),l("mi",null,"Y"),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",{stretchy:"false"},")")])]),l("msub",null,[l("mi",null,"F"),l("mi",null,"P")]),l("mo",{stretchy:"false"},"("),l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"E"),l("mi",null,"N"),l("mi",null,"T"),l("mi",null,"R"),l("mi",null,"Y"),l("mo",{stretchy:"false"},"]"),l("mo",{stretchy:"false"},")"),l("mspace",{linebreak:"newline"}),l("mo",null,"⪯"),l("munder",null,[l("mo",null,"⋀"),l("mrow",null,[l("mi",{mathvariant:"normal"},"∀"),l("mi",null,"P"),l("mo",null,"∈"),l("mi",null,"R"),l("mi",null,"P"),l("mi",null,"a"),l("mi",null,"t"),l("mi",null,"h"),l("mi",null,"s"),l("mo",{stretchy:"false"},"("),l("mi",null,"E"),l("mi",null,"N"),l("mi",null,"T"),l("mi",null,"R"),l("mi",null,"Y"),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",{stretchy:"false"},")")])]),l("msub",null,[l("mi",null,"F"),l("mi",null,"P")]),l("mo",{stretchy:"false"},"("),l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"E"),l("mi",null,"N"),l("mi",null,"T"),l("mi",null,"R"),l("mi",null,"Y"),l("mo",{stretchy:"false"},"]"),l("mo",{stretchy:"false"},")"),l("mo",null,"="),l("mi",null,"M"),l("mi",null,"R"),l("mi",null,"P"),l("mo",{stretchy:"false"},"["),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"MOP[s_i] = \\bigwedge_{\\forall P \\in Paths(ENTRY, s_i)} F_P(OUT[ENTRY])\\\\ = \\bigwedge_{\\forall P \\in RPaths(ENTRY, s_i)} F_P(OUT[ENTRY]) \\wedge \\bigwedge_{\\forall P \\in Paths(ENTRY, s_i) - RPaths(ENTRY, s_i)} F_P(OUT[ENTRY])\\\\ \\preceq \\bigwedge_{\\forall P \\in RPaths(ENTRY, s_i)} F_P(OUT[ENTRY]) = MRP[s_i] ")])])])])],-1),l("h3",{id:"_11-3-2-基本步骤",tabindex:"-1"},[n("11.3.2 基本步骤 "),l("a",{class:"header-anchor",href:"#_11-3-2-基本步骤","aria-label":'Permalink to "11.3.2 基本步骤"'},"​")],-1),l("p",null,"我们先明晃晃地给出IFDS分析的框架，其中引入的一些新概念还没有被解释，请不要焦虑，之后会每一步分别讲解，现在只要留一个印象就可以了。",-1),l("div",{class:"conclusion"},[l("p",{class:"title"},"结论11.1"),l("p",null,"IFDS分析框架："),l("p",null,[n("给定一个程序 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"P")]),l("annotation",{encoding:"application/x-tex"},"P")])])]),n(" ，和一个数据流分析问题 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"Q")]),l("annotation",{encoding:"application/x-tex"},"Q")])])])]),l("ul",null,[l("li",null,[l("p",null,[n("为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"P")]),l("annotation",{encoding:"application/x-tex"},"P")])])]),n(" 建立一个 "),l("strong",null,"超图（Supergraph）"),n(),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msup",null,[l("mi",null,"G"),l("mo",{lspace:"0em",rspace:"0em"},"∗")])]),l("annotation",{encoding:"application/x-tex"},"G^{*}")])])]),n(" 并且根据 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"Q")]),l("annotation",{encoding:"application/x-tex"},"Q")])])]),n(" 定义 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msup",null,[l("mi",null,"G"),l("mo",{lspace:"0em",rspace:"0em"},"∗")])]),l("annotation",{encoding:"application/x-tex"},"G^{*}")])])]),n(" 中边的流函数；")])]),l("li",null,[l("p",null,[n("通过将流函数转化成 "),l("strong",null,"代表关系（Representation Relations）"),n(" 的方式，基于 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msup",null,[l("mi",null,"G"),l("mo",{lspace:"0em",rspace:"0em"},"∗")])]),l("annotation",{encoding:"application/x-tex"},"G^{*}")])])]),n(" 为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"P")]),l("annotation",{encoding:"application/x-tex"},"P")])])]),n(" 建立一个 "),l("strong",null,"分解超图（Exploded Supergraph）"),n(),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msup",null,[l("mi",null,"G"),l("mi",{mathvariant:"normal"},"♯")])]),l("annotation",{encoding:"application/x-tex"},"G^{\\sharp}")])])]),n(" 。")])]),l("li",null,[l("p",null,[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"Q")]),l("annotation",{encoding:"application/x-tex"},"Q")])])]),n(" 可以被当作图 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msup",null,[l("mi",null,"G"),l("mi",{mathvariant:"normal"},"♯")])]),l("annotation",{encoding:"application/x-tex"},"G^{\\sharp}")])])]),n(" 上的可达性问题来解决（寻找MRP解决方案），具体地，通过在 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msup",null,[l("mi",null,"G"),l("mi",{mathvariant:"normal"},"♯")])]),l("annotation",{encoding:"application/x-tex"},"G^{\\sharp}")])])]),n(" 上运行制表算法来解决。")])])]),l("p",null,[n("令 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"n")]),l("annotation",{encoding:"application/x-tex"},"n")])])]),n(" 是某个程序点， 数据流因素 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"d"),l("mo",null,"∈"),l("mi",null,"M"),l("mi",null,"R"),l("mi",null,"P"),l("mo",{stretchy:"false"},"["),l("msub",null,[l("mi",null,"n"),l("mi",null,"i")]),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"d \\in MRP[n_i]")])])]),n(" 当且仅当在 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msup",null,[l("mi",null,"G"),l("mi",{mathvariant:"normal"},"♯")])]),l("annotation",{encoding:"application/x-tex"},"G^{\\sharp}")])])]),n(" 中存在一条从 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",{stretchy:"false"},"("),l("msub",null,[l("mi",null,"s"),l("mrow",null,[l("mi",null,"m"),l("mi",null,"a"),l("mi",null,"i"),l("mi",null,"n")])]),l("mo",{separator:"true"},","),l("mn",null,"0"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"(s_{main}, 0)")])])]),n(" 到 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",{stretchy:"false"},"("),l("msub",null,[l("mi",null,"n"),l("mi",null,"i")]),l("mo",{separator:"true"},","),l("mi",null,"d"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"(n_i, d)")])])]),n(" 的可实现的路径。")])],-1),l("blockquote",null,[l("p",null,[n("这里数据流因素（dataflow fact）在3.2.4节中定理3.4的证明后面注解块里面有提到过，数据流值（dataflow value）也称作因素（facts），一般是一个集合，这个集合中的一个元素称为一个因素（fact）。所以其实 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"d")]),l("annotation",{encoding:"application/x-tex"},"d")])])]),n(" 就是数据流值。")])],-1),l("h2",{id:"_11-4-超图与流函数",tabindex:"-1"},[n("11.4 超图与流函数 "),l("a",{class:"header-anchor",href:"#_11-4-超图与流函数","aria-label":'Permalink to "11.4 超图与流函数"'},"​")],-1),l("h3",{id:"_11-4-1-超图的构建",tabindex:"-1"},[n("11.4.1 超图的构建 "),l("a",{class:"header-anchor",href:"#_11-4-1-超图的构建","aria-label":'Permalink to "11.4.1 超图的构建"'},"​")],-1),l("div",{class:"definition"},[l("p",{class:"title"},"定义11.11"),l("p",null,[n("在IFDS中，程序用 "),l("strong",null,"超图（Supergraph）"),n(),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msup",null,[l("mi",null,"G"),l("mo",{lspace:"0em",rspace:"0em"},"∗")]),l("mo",null,"="),l("mo",{stretchy:"false"},"("),l("msup",null,[l("mi",null,"N"),l("mo",{lspace:"0em",rspace:"0em"},"∗")]),l("mo",{separator:"true"},","),l("msup",null,[l("mi",null,"E"),l("mo",{lspace:"0em",rspace:"0em"},"∗")]),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"G^{*} = (N^{*}, E^{*})")])])]),n(" 表示。")]),l("ul",null,[l("li",null,[l("p",null,[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msup",null,[l("mi",null,"G"),l("mo",{lspace:"0em",rspace:"0em"},"∗")])]),l("annotation",{encoding:"application/x-tex"},"G^{*}")])])]),n(" 是由一组控制流图（Control Flow Graph，见定义2.4与算法2.2） "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"G"),l("mn",null,"1")]),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"G"),l("mn",null,"2")]),l("mo",{separator:"true"},","),l("mi",{mathvariant:"normal"},"."),l("mi",{mathvariant:"normal"},"."),l("mi",{mathvariant:"normal"},".")]),l("annotation",{encoding:"application/x-tex"},"G_1, G_2, ...")])])]),n(" 组成的，每个过程 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"P"),l("mi",null,"r"),l("mi",null,"o"),l("mi",null,"c"),l("mi",null,"e"),l("mi",null,"d"),l("mi",null,"u"),l("mi",null,"r"),l("msub",null,[l("mi",null,"e"),l("mi",null,"i")])]),l("annotation",{encoding:"application/x-tex"},"Procedure_i")])])]),n(" 都有一个对应的控制流图 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"G"),l("mi",null,"i")])]),l("annotation",{encoding:"application/x-tex"},"G_i")])])]),n("。")]),l("ul",null,[l("li",null,[l("p",null,[n("每一个控制流图 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"G"),l("mi",null,"p")])]),l("annotation",{encoding:"application/x-tex"},"G_p")])])]),n(" 都有自己独特的一个起始结点（Start Node） "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"s"),l("mi",null,"p")])]),l("annotation",{encoding:"application/x-tex"},"s_p")])])]),n(" 和结束结点（Exit Node） "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"e"),l("mi",null,"p")])]),l("annotation",{encoding:"application/x-tex"},"e_p")])])]),n(" 。")])]),l("li",null,[l("p",null,[n("在每个过程的控制流图 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"G"),l("mi",null,"i")])]),l("annotation",{encoding:"application/x-tex"},"G_i")])])]),n(" 中，用调用结点（Call Node） "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"C"),l("mi",null,"a"),l("mi",null,"l"),l("msub",null,[l("mi",null,"l"),l("mi",null,"p")])]),l("annotation",{encoding:"application/x-tex"},"Call_p")])])]),n(" 和 返回点结点（Return-site Node） "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"R"),l("mi",null,"e"),l("msub",null,[l("mi",null,"t"),l("mi",null,"p")])]),l("annotation",{encoding:"application/x-tex"},"Ret_p")])])]),n(" 来表示对 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"P"),l("mi",null,"r"),l("mi",null,"o"),l("mi",null,"c"),l("mi",null,"e"),l("mi",null,"d"),l("mi",null,"u"),l("mi",null,"r"),l("msub",null,[l("mi",null,"e"),l("mi",null,"p")])]),l("annotation",{encoding:"application/x-tex"},"Procedure_p")])])]),n(" 的过程调用。")])])])]),l("li",null,[l("p",null,[n("除了每个过程内部的控制流边以外，对于每个过程调用， "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msup",null,[l("mi",null,"G"),l("mo",{lspace:"0em",rspace:"0em"},"∗")])]),l("annotation",{encoding:"application/x-tex"},"G^{*}")])])]),n(" 还有另外3种边：")]),l("ul",null,[l("li",null,[l("p",null,[n("一条过程内的，从调用者的 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"C"),l("mi",null,"a"),l("mi",null,"l"),l("msub",null,[l("mi",null,"l"),l("mi",null,"p")])]),l("annotation",{encoding:"application/x-tex"},"Call_p")])])]),n(" 到 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"R"),l("mi",null,"e"),l("msub",null,[l("mi",null,"t"),l("mi",null,"p")])]),l("annotation",{encoding:"application/x-tex"},"Ret_p")])])]),n(" 的 "),l("strong",null,"调用返回边（call-to-return-site edge）"),n(" ，")])]),l("li",null,[l("p",null,[n("一条过程间的，从调用者 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"C"),l("mi",null,"a"),l("mi",null,"l"),l("msub",null,[l("mi",null,"l"),l("mi",null,"p")])]),l("annotation",{encoding:"application/x-tex"},"Call_p")])])]),n(" 到被调用者的 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"s"),l("mi",null,"p")])]),l("annotation",{encoding:"application/x-tex"},"s_p")])])]),n(" 的 "),l("strong",null,"调用起始边（call-to-start-edge）"),n(" ，")])]),l("li",null,[l("p",null,[n("一条过程间的，从被调用者的 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"e"),l("mi",null,"p")])]),l("annotation",{encoding:"application/x-tex"},"e_p")])])]),n(" 到调用者的 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"R"),l("mi",null,"e"),l("msub",null,[l("mi",null,"t"),l("mi",null,"p")])]),l("annotation",{encoding:"application/x-tex"},"Ret_p")])])]),n(" 的 "),l("strong",null,"结束返回边（exit-to-return-edge）"),n(" 。")])])])])])],-1),l("blockquote",null,[l("p",null,"其实这里的超图和我们在5.3中讲的过程间控制流图很像，只是它将调用点拆分成了调用结点与返回点结点两个部分而已。")],-1),l("p",null,"比如说对于下面这段程序：",-1),l("div",{class:"language-java vp-adaptive-theme"},[l("button",{title:"Copy Code",class:"copy"}),l("span",{class:"lang"},"java"),l("pre",{class:"shiki shiki-themes github-light github-dark vp-code"},[l("code",{"v-pre":""},[l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"int"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," g;")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"void"),l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}}," main"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"() {")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"    int"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," x;")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    x "),l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),l("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," 0"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},";")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"    P"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(x);")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"void"),l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}}," P"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"("),l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"int"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," a) {")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"    if"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," (a "),l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},">"),l("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," 0"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},") {")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        g "),l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),l("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," 0"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},";")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        a "),l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," a "),l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"-"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," g;")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"        P"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(a);")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"        Print"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(a, g);")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    }")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])]),l("button",{class:"collapse"})],-1),l("p",null,"根据定义11.11，构建出的上述程序的超图如下：",-1),l("p",{style:{"text-align":"center"}},[l("img",{src:_,alt:"super-graph",style:{zoom:"40%"}})],-1),l("p",null,"其中，",-1),l("ul",null,[l("li",null,[l("p",null,"对于结点，白底蓝字的是起始结点和结束结点，红底黑字的是调用结点和返回结点，白底黑字的是普通结点。")]),l("li",null,[l("p",null,"对于边，黑色的是普通控制流边，紫色的是调用返回边，绿色的是调用起始边，蓝色的是结束返回边。")])],-1),l("h3",{id:"_11-4-2-流函数的设计",tabindex:"-1"},[n("11.4.2 流函数的设计 "),l("a",{class:"header-anchor",href:"#_11-4-2-流函数的设计","aria-label":'Permalink to "11.4.2 流函数的设计"'},"​")],-1),l("p",null,[n("在结论11.1中，我们提到了流函数是根据研究的问题 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"Q")]),l("annotation",{encoding:"application/x-tex"},"Q")])])]),n(" 决定的，为了后续演示方便，我们先定义一个数据流分析问题作为例子。")],-1),l("div",{class:"definition"},[l("p",{class:"title"},"定义11.12"),l("p",null,[n("定义 "),l("strong",null,"可能未初始化变量（Possibly-uninitialized Variables）"),n(" 问题：对于 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msup",null,[l("mi",null,"N"),l("mo",{lspace:"0em",rspace:"0em"},"∗")])]),l("annotation",{encoding:"application/x-tex"},"N^{*}")])])]),n("（见定义11.11） 中的每个结点 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"n")]),l("annotation",{encoding:"application/x-tex"},"n")])])]),n(" ，求在执行 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"n")]),l("annotation",{encoding:"application/x-tex"},"n")])])]),n(" 之前有可能未初始化的变量集合。")])],-1),l("p",null,"由于一些历史原因，在IFDS中，我们会使用lambda表达式来书写流函数，所以在正式开始前我们再定义一下lambda表达式的数学记号。",-1),l("div",{class:"definition"},[l("p",{class:"title"},"定义11.13"),l("p",null,[n("定义"),l("strong",null,"lambda表达式"),n("形如 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"λ"),l("msub",null,[l("mi",null,"e"),l("mrow",null,[l("mi",null,"p"),l("mi",null,"a"),l("mi",null,"r"),l("mi",null,"a"),l("mi",null,"m")])]),l("mi",{mathvariant:"normal"},"."),l("msub",null,[l("mi",null,"e"),l("mrow",null,[l("mi",null,"b"),l("mi",null,"o"),l("mi",null,"d"),l("mi",null,"y")])])]),l("annotation",{encoding:"application/x-tex"},"\\lambda e_{param}. e_{body}")])])]),n(" ，其中 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"e"),l("mrow",null,[l("mi",null,"p"),l("mi",null,"a"),l("mi",null,"r"),l("mi",null,"a"),l("mi",null,"m")])])]),l("annotation",{encoding:"application/x-tex"},"e_{param}")])])]),n(" 是形参表， "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"e"),l("mrow",null,[l("mi",null,"b"),l("mi",null,"o"),l("mi",null,"d"),l("mi",null,"y")])])]),l("annotation",{encoding:"application/x-tex"},"e_{body}")])])]),n(" 是函数体。")]),l("p",null,[n("采用 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",{stretchy:"false"},"("),l("mi",null,"λ"),l("msub",null,[l("mi",null,"e"),l("mrow",null,[l("mi",null,"p"),l("mi",null,"a"),l("mi",null,"r"),l("mi",null,"a"),l("mi",null,"m")])]),l("mi",{mathvariant:"normal"},"."),l("msub",null,[l("mi",null,"e"),l("mrow",null,[l("mi",null,"b"),l("mi",null,"o"),l("mi",null,"d"),l("mi",null,"y")])]),l("mo",{stretchy:"false"},")"),l("mo",{stretchy:"false"},"("),l("msub",null,[l("mi",null,"e"),l("mrow",null,[l("mi",null,"a"),l("mi",null,"r"),l("mi",null,"g")])]),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"(\\lambda e_{param}. e_{body})(e_{arg})")])])]),n(" 的形式来调用这个匿名函数，其中 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"e"),l("mrow",null,[l("mi",null,"a"),l("mi",null,"r"),l("mi",null,"g")])])]),l("annotation",{encoding:"application/x-tex"},"e_{arg}")])])]),n(" 是实参表，如果只有一个元素，实参表的括号可以省略。")])],-1),l("p",null,[n("比如说， "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"λ"),l("mi",null,"x"),l("mi",{mathvariant:"normal"},"."),l("mi",null,"x"),l("mo",null,"+"),l("mn",null,"1")]),l("annotation",{encoding:"application/x-tex"},"\\lambda x.x+1")])])]),n(" 是一个lambda表达式，对3调用这个匿名函数： "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",{stretchy:"false"},"("),l("mi",null,"λ"),l("mi",null,"x"),l("mi",{mathvariant:"normal"},"."),l("mi",null,"x"),l("mo",null,"+"),l("mn",null,"1"),l("mo",{stretchy:"false"},")"),l("mn",null,"3"),l("mo",null,"⇒"),l("mn",null,"3"),l("mo",null,"+"),l("mn",null,"1"),l("mo",null,"⇒"),l("mn",null,"4")]),l("annotation",{encoding:"application/x-tex"},"(\\lambda x.x+1)3 \\Rightarrow 3 + 1 \\Rightarrow 4")])])]),n(" 。")],-1),l("p",null,"下面，我们基于上面已经构建好的超图来定义其中每条边的流函数：",-1),l("p",{style:{"text-align":"center"}},[l("img",{src:L,alt:"flow-functions",style:{zoom:"30%"}})],-1),l("p",null,[n("其中 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"S")]),l("annotation",{encoding:"application/x-tex"},"S")])])]),n(" 是可能未初始化的变量的集合，也是我们要分析的数据流值（具体参见定义3.3，结论3.1）。流函数的输入是上一个程序点的数据流值，输出是本程序点的数据流值。")],-1),l("p",null,"下面请顺着程序的控制流对照上图来看下面的分析。",-1),l("p",null,[n("一开始的时候， "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"S"),l("mrow",null,[l("mi",null,"m"),l("mi",null,"a"),l("mi",null,"i"),l("mi",null,"n")])])]),l("annotation",{encoding:"application/x-tex"},"S_{main}")])])]),n(" 之前没有程序点，流函数 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"λ"),l("mi",null,"S"),l("mi",{mathvariant:"normal"},"."),l("mo",{stretchy:"false"},"{"),l("mi",null,"x"),l("mo",{separator:"true"},","),l("mi",null,"g"),l("mo",{stretchy:"false"},"}")]),l("annotation",{encoding:"application/x-tex"},"\\lambda S . \\{x, g\\}")])])]),n(" 的含义是无论输入S是啥，输出总是 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",{stretchy:"false"},"{"),l("mi",null,"x"),l("mo",{separator:"true"},","),l("mi",null,"g"),l("mo",{stretchy:"false"},"}")]),l("annotation",{encoding:"application/x-tex"},"\\{x, g\\}")])])]),n(" ，因此 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"S"),l("mrow",null,[l("mi",null,"m"),l("mi",null,"a"),l("mi",null,"i"),l("mi",null,"n")])])]),l("annotation",{encoding:"application/x-tex"},"S_{main}")])])]),n(" 之后的程序点的数据流值为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",{stretchy:"false"},"{"),l("mi",null,"x"),l("mo",{separator:"true"},","),l("mi",null,"g"),l("mo",{stretchy:"false"},"}")]),l("annotation",{encoding:"application/x-tex"},"\\{x, g\\}")])])]),n("。")],-1),l("p",null,[n("之后， "),l("code",null,"x = 0"),n(" 这个结点之前的程序点处，根据上面的分析，数据流值是 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",{stretchy:"false"},"{"),l("mi",null,"x"),l("mo",{separator:"true"},","),l("mi",null,"g"),l("mo",{stretchy:"false"},"}")]),l("annotation",{encoding:"application/x-tex"},"\\{x, g\\}")])])]),n(" ，"),l("code",null,"x = 0"),n(" 的作用是给 "),l("code",null,"x"),n(" 一个定义，所以此时 "),l("code",null,"x"),n(" 就不是未初始化的变量了，因此就不应该在 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"S")]),l("annotation",{encoding:"application/x-tex"},"S")])])]),n(" 中了。从而，这个地方的流函数是 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"λ"),l("mi",null,"S"),l("mi",{mathvariant:"normal"},"."),l("mi",null,"S"),l("mo",null,"−"),l("mo",{stretchy:"false"},"{"),l("mi",null,"x"),l("mo",{stretchy:"false"},"}")]),l("annotation",{encoding:"application/x-tex"},"\\lambda S.S - \\{x\\}")])])]),n(" 。")],-1),l("p",null,[n("然后看第一条调用开始边，其作用是将实参绑定到形参且进入子过程，相当于给 "),l("code",null,"x"),n(" 改了一个名字（rename），变成 "),l("code",null,"a"),n("， 我们写作 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"λ"),l("mi",null,"S"),l("mi",{mathvariant:"normal"},"."),l("mi",null,"S"),l("mo",null,"<"),l("mi",null,"x"),l("mi",{mathvariant:"normal"},"/"),l("mi",null,"a"),l("mo",null,">")]),l("annotation",{encoding:"application/x-tex"},"\\lambda S.S<x/a>")])])]),n(" 。也就是说，如果没有 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"x"),l("mo",null,"="),l("mn",null,"0")]),l("annotation",{encoding:"application/x-tex"},"x = 0")])])]),n(" 这个语句的话，在 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"C"),l("mi",null,"a"),l("mi",null,"l"),l("msub",null,[l("mi",null,"l"),l("mi",null,"p")]),l("mo",null,"→"),l("msub",null,[l("mi",null,"S"),l("mi",null,"p")])]),l("annotation",{encoding:"application/x-tex"},"Call_p \\to S_p")])])]),n(" 处的数据流值为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",{stretchy:"false"},"{"),l("mi",null,"a"),l("mo",{separator:"true"},","),l("mi",null,"g"),l("mo",{stretchy:"false"},"}")]),l("annotation",{encoding:"application/x-tex"},"\\{a, g\\}")])])]),n(" 。当然，在我们的程序中这个地方 "),l("code",null,"x"),n(" 已经被初始化了。")],-1),l("p",null,[n("对于 "),l("code",null,"a = a - g"),n(" 这个语句，根据安全近似的原则，右值 "),l("code",null,"a"),n(" 和 "),l("code",null,"g"),n(" 只要有任何一个未初始化，作为左值的 "),l("code",null,"a"),n(" 就是未初始化的，于是，其流函数用了一个分支结构。")],-1),l("p",null,"下面我们关注两条调用返回边，调用返回边的作用是传播本地信息（这一点在定义5.9后面的相关解释中也有说明）。",-1),l("ul",null,[l("li",null,[l("p",null,"比如说，我有好多个变量，但是我调用的过程只需要其中一两个，那么剩下的变量就可以不需要进入过程体，直接通过调用返回边传递给后面的结点即可。")]),l("li",null,[l("p",null,"此外，有些方法的副作用，我们也可以在调用返回边上帮助显现。")])],-1),l("p",null,[n("比如说我们上面这个例子， "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"λ"),l("mi",null,"S"),l("mi",{mathvariant:"normal"},"."),l("mi",null,"S"),l("mo",null,"−"),l("mo",{stretchy:"false"},"{"),l("mi",null,"g"),l("mo",{stretchy:"false"},"}")]),l("annotation",{encoding:"application/x-tex"},"\\lambda S.S - \\{g\\}")])])]),n(" 函数体中的 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"S")]),l("annotation",{encoding:"application/x-tex"},"S")])])]),n(" 传递的是本地信息（如果 "),l("code",null,"x"),n(" 还在S里的话就通过这个地方被传递到后面）； "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",null,"−"),l("mo",{stretchy:"false"},"{"),l("mi",null,"g"),l("mo",{stretchy:"false"},"}")]),l("annotation",{encoding:"application/x-tex"},"- \\{g\\}")])])]),n(" 其实是为了显现出函数 P 的副作用。")],-1),l("p",null,[n("具体地，当我们在这里 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",null,"−"),l("mo",{stretchy:"false"},"{"),l("mi",null,"g"),l("mo",{stretchy:"false"},"}")]),l("annotation",{encoding:"application/x-tex"},"-\\{g\\}")])])]),n(" 之后，"),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"g")]),l("annotation",{encoding:"application/x-tex"},"g")])])]),n(" 最终是否被定义这件事情的控制权就完全交付给被调用的函数了——如果 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"g")]),l("annotation",{encoding:"application/x-tex"},"g")])])]),n(" 没有被定义，那么调用返回边和结束返回边汇集的时候 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"g")]),l("annotation",{encoding:"application/x-tex"},"g")])])]),n(" 还是会被放回来的；如果 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"g")]),l("annotation",{encoding:"application/x-tex"},"g")])])]),n(" 在被调用函数中被定义了，那么调用返回边和结束返回边汇集的时候 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"g")]),l("annotation",{encoding:"application/x-tex"},"g")])])]),n(" 就不在后续程序点的数据流值里面了。但是，如果我们没有在调用返回边上面 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",null,"−"),l("mo",{stretchy:"false"},"{"),l("mi",null,"g"),l("mo",{stretchy:"false"},"}")]),l("annotation",{encoding:"application/x-tex"},"-\\{g\\}")])])]),n(" ，那么无论被调用者是否初始化了 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"g")]),l("annotation",{encoding:"application/x-tex"},"g")])])]),n(" ，最终调用返回边和结束返回边汇集的时候 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"g")]),l("annotation",{encoding:"application/x-tex"},"g")])])]),n(" 都会存在于后续的数据流值当中，也就是说多了一个假积极。")],-1),l("p",null,[n("当然，最重要的是传递本地信息，显现副作用这一点更多的是为了提高精度，就算我们不表达这里的 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",null,"−"),l("mo",{stretchy:"false"},"{"),l("mi",null,"g"),l("mo",{stretchy:"false"},"}")]),l("annotation",{encoding:"application/x-tex"},"-\\{g\\}")])])]),n(" 副作用，也不会影响结果的完全性（Soundness），因为我们分析的是“可能”未初始化的变量，如果 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"g")]),l("annotation",{encoding:"application/x-tex"},"g")])])]),n(" 被保留了下来就相当于多了一个假积极（False Positive），结果依旧是完全的（Sound）。但是，"),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",null,"−"),l("mo",{stretchy:"false"},"{"),l("mi",null,"g"),l("mo",{stretchy:"false"},"}")]),l("annotation",{encoding:"application/x-tex"},"-\\{g\\}")])])]),n(" 的做法能够减少假积极。")],-1),l("p",null,[n("最后我们来看两条结束返回边的流函数 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"λ"),l("mi",null,"S"),l("mi",{mathvariant:"normal"},"."),l("mi",null,"S"),l("mo",null,"−"),l("mo",{stretchy:"false"},"{"),l("mi",null,"a"),l("mo",{stretchy:"false"},"}")]),l("annotation",{encoding:"application/x-tex"},"\\lambda S.S - \\{a\\}")])])]),n(" ，在从本地作用域退出的时候本地变量就消亡了，因此不会带着向后分析，所以结束返回边的作用在这里就是处理已经消亡的本地变量。当然，如果这个函数有返回值的话，也会在结束返回边上面传递返回值信息，并且这可能是更加主要的作用。")],-1),l("p",null,"综上，流函数的设计就分析完啦。简单总结一下：",-1),l("ul",null,[l("li",null,[l("p",null,"起点边：定义初始状态；")]),l("li",null,[l("p",null,"普通边：表达出语句的语义；")]),l("li",null,[l("p",null,"调用起始边：绑定参数，改名字（rename）；")]),l("li",null,[l("p",null,"调用返回边：传递本地信息和过程副作用；")]),l("li",null,[l("p",null,"结束返回边：传递返回值信息和表达本地作用域的消亡。")])],-1),l("h2",{id:"_11-5-分解超图和制表算法",tabindex:"-1"},[n("11.5 分解超图和制表算法 "),l("a",{class:"header-anchor",href:"#_11-5-分解超图和制表算法","aria-label":'Permalink to "11.5 分解超图和制表算法"'},"​")],-1),l("h3",{id:"_11-5-1-代表关系",tabindex:"-1"},[n("11.5.1 代表关系 "),l("a",{class:"header-anchor",href:"#_11-5-1-代表关系","aria-label":'Permalink to "11.5.1 代表关系"'},"​")],-1),l("p",null,[n("在结论11.1中的第二点我们说要通过将流函数转化成代表关系的方式将 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msup",null,[l("mi",null,"G"),l("mo",{lspace:"0em",rspace:"0em"},"∗")])]),l("annotation",{encoding:"application/x-tex"},"G^{*}")])])]),n(" 转化成 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msup",null,[l("mi",null,"G"),l("mi",{mathvariant:"normal"},"♯")])]),l("annotation",{encoding:"application/x-tex"},"G^{\\sharp}")])])]),n(" 。所以我们先定义一下什么是代表关系。")],-1),l("p",null,[n("每一个流函数可以被表示成一个有 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mn",null,"2"),l("mo",{stretchy:"false"},"("),l("mi",{mathvariant:"normal"},"∣"),l("mi",null,"D"),l("mi",{mathvariant:"normal"},"∣"),l("mo",null,"+"),l("mn",null,"1"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"2(|D| + 1)")])])]),n(" 个结点的图（最多 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",{stretchy:"false"},"("),l("mi",{mathvariant:"normal"},"∣"),l("mi",null,"D"),l("mi",{mathvariant:"normal"},"∣"),l("mo",null,"+"),l("mn",null,"1"),l("msup",null,[l("mo",{stretchy:"false"},")"),l("mn",null,"2")])]),l("annotation",{encoding:"application/x-tex"},"(|D| + 1)^2")])])]),n(" 条边，因为是一个二部图），其中， "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"D")]),l("annotation",{encoding:"application/x-tex"},"D")])])]),n(" 是数据流因素（dataflow fact）的集合，为了能够将其表示为“图”， "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"D")]),l("annotation",{encoding:"application/x-tex"},"D")])])]),n(" 必须是一个有限集，这也就是为什么需要 IFDS 中的 F（Finite）作为前提条件。")],-1),l("div",{class:"definition"},[l("p",{class:"title"},"定义 11.14"),l("p",null,[n("对于流函数 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"f")]),l("annotation",{encoding:"application/x-tex"},"f")])])]),n(" ，其 "),l("strong",null,"代表关系（Representation Relation）"),n(" 是一个二元关系 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"R"),l("mi",null,"f")]),l("mo",null,"⊆"),l("mo",{stretchy:"false"},"("),l("mi",null,"D"),l("mo",null,"∪"),l("mo",{stretchy:"false"},"{"),l("mn",null,"0"),l("mo",{stretchy:"false"},"}"),l("mo",{stretchy:"false"},")"),l("mo",null,"×"),l("mo",{stretchy:"false"},"("),l("mi",null,"D"),l("mo",null,"∪"),l("mo",{stretchy:"false"},"{"),l("mn",null,"0"),l("mo",{stretchy:"false"},"}"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"R_{f} \\subseteq (D \\cup \\{0\\}) \\times (D \\cup \\{0\\})")])])]),n(" ，其定义如下：")]),l("p",null,[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"R"),l("mi",null,"f")]),l("mo",null,"="),l("mo",{stretchy:"false"},"{"),l("mo",{stretchy:"false"},"("),l("mn",null,"0"),l("mo",{separator:"true"},","),l("mn",null,"0"),l("mo",{stretchy:"false"},")"),l("mo",{stretchy:"false"},"}"),l("mo",null,"∪"),l("mo",{stretchy:"false"},"{"),l("mo",{stretchy:"false"},"("),l("mn",null,"0"),l("mo",{separator:"true"},","),l("mi",null,"y"),l("mo",{stretchy:"false"},")"),l("mi",{mathvariant:"normal"},"∣"),l("mi",null,"y"),l("mo",null,"∈"),l("mi",null,"f"),l("mo",{stretchy:"false"},"("),l("mi",{mathvariant:"normal"},"∅"),l("mo",{stretchy:"false"},")"),l("mo",{stretchy:"false"},"}"),l("mo",null,"∪"),l("mo",{stretchy:"false"},"{"),l("mo",{stretchy:"false"},"("),l("mi",null,"x"),l("mo",{separator:"true"},","),l("mi",null,"y"),l("mo",{stretchy:"false"},")"),l("mi",{mathvariant:"normal"},"∣"),l("mi",null,"y"),l("mo",{mathvariant:"normal"},"∉"),l("mi",null,"f"),l("mo",{stretchy:"false"},"("),l("mi",{mathvariant:"normal"},"∅"),l("mo",{stretchy:"false"},")"),l("mo",null,"∧"),l("mi",null,"y"),l("mo",null,"∈"),l("mi",null,"f"),l("mo",{stretchy:"false"},"("),l("mo",{stretchy:"false"},"{"),l("mi",null,"x"),l("mo",{stretchy:"false"},"}"),l("mo",{stretchy:"false"},")"),l("mo",{stretchy:"false"},"}")]),l("annotation",{encoding:"application/x-tex"},"R_f = \\{(0, 0)\\} \\cup \\{(0, y)| y \\in f(\\emptyset)\\}\\cup\\{(x, y)|y \\notin f(\\emptyset) \\wedge y\\in f(\\{x\\})\\} ")])])])]),l("p",null,[n("用二部图 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"G")]),l("annotation",{encoding:"application/x-tex"},"G")])])]),n(" 来表示上面的二元关系，则 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",{stretchy:"false"},"("),l("msub",null,[l("mi",null,"d"),l("mn",null,"1")]),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"d"),l("mn",null,"2")]),l("mo",{stretchy:"false"},")"),l("mo",null,"∈"),l("msub",null,[l("mi",null,"R"),l("mi",null,"f")]),l("mo",null,"⇔"),l("msub",null,[l("mi",null,"d"),l("mn",null,"1")]),l("mo",null,"→"),l("msub",null,[l("mi",null,"d"),l("mn",null,"2")]),l("mo",null,"∈"),l("mi",null,"G")]),l("annotation",{encoding:"application/x-tex"},"(d_1, d_2) \\in R_f \\Leftrightarrow d_1\\to d_2 \\in G")])])]),n(" 。")])],-1),l("p",null,"下面是几个流函数转化成代表关系的例子：",-1),l("p",{style:{"text-align":"center"}},[l("img",{src:E,alt:"representation-relation",style:{zoom:"30%"}})],-1),l("h3",{id:"_11-5-2-构建分解超图",tabindex:"-1"},[n("11.5.2 构建分解超图 "),l("a",{class:"header-anchor",href:"#_11-5-2-构建分解超图","aria-label":'Permalink to "11.5.2 构建分解超图"'},"​")],-1),l("p",null,"有了代表关系的定义，我们就可以构建分解超图了。其实就是将上面的二部图一个个首尾相接连起来。",-1),l("div",{class:"definition"},[l("p",{class:"title"},"定义11.15"),l("p",null,[n("用有序对 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",{stretchy:"false"},"("),l("msub",null,[l("mi",null,"n"),l("mi",null,"i")]),l("mo",{separator:"true"},","),l("mi",null,"d"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"(n_i, d)")])])]),n(" 表示程序点 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",{stretchy:"false"},"("),l("msub",null,[l("mi",null,"n"),l("mi",null,"i")]),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"n"),l("mrow",null,[l("mi",null,"i"),l("mo",null,"+"),l("mn",null,"1")])]),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"(n_i, n_{i+1})")])])]),n(" 处的数据流因素 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"d")]),l("annotation",{encoding:"application/x-tex"},"d")])])]),n(" ，用 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",{stretchy:"false"},"("),l("msub",null,[l("mi",null,"n"),l("mi",null,"i")]),l("mo",{separator:"true"},","),l("mn",null,"0"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"(n_i, 0)")])])]),n(" 表示该程序点处特殊的数据流因素 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mn",null,"0")]),l("annotation",{encoding:"application/x-tex"},"0")])])]),n(" 。")]),l("p",null,[n("定义 "),l("strong",null,"分解超图（Exploded Supergraph）"),n(" 形如 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msup",null,[l("mi",null,"G"),l("mi",{mathvariant:"normal"},"♯")]),l("mo",null,"="),l("mo",{stretchy:"false"},"("),l("msup",null,[l("mi",null,"V"),l("mi",{mathvariant:"normal"},"♯")]),l("mo",{separator:"true"},","),l("msup",null,[l("mi",null,"E"),l("mi",{mathvariant:"normal"},"♯")]),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"G^{\\sharp} = (V^{\\sharp}, E^{\\sharp})")])])]),n(" ，其中：")]),l("ul",null,[l("li",null,[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msup",null,[l("mi",null,"V"),l("mi",{mathvariant:"normal"},"♯")]),l("mo",null,"="),l("mo",{stretchy:"false"},"{"),l("mo",{stretchy:"false"},"("),l("msub",null,[l("mi",null,"n"),l("mi",null,"i")]),l("mo",{separator:"true"},","),l("mi",null,"d"),l("mo",{stretchy:"false"},")"),l("mi",{mathvariant:"normal"},"∣"),l("msub",null,[l("mi",null,"n"),l("mi",null,"i")]),l("mtext",null," "),l("mi",null,"i"),l("mi",null,"s"),l("mtext",null," "),l("mi",null,"a"),l("mtext",null," "),l("mi",null,"p"),l("mi",null,"r"),l("mi",null,"o"),l("mi",null,"g"),l("mi",null,"r"),l("mi",null,"a"),l("mi",null,"m"),l("mtext",null," "),l("mi",null,"p"),l("mi",null,"o"),l("mi",null,"i"),l("mi",null,"n"),l("mi",null,"t"),l("mtext",null," "),l("mi",null,"a"),l("mi",null,"n"),l("mi",null,"d"),l("mtext",null," "),l("mi",null,"d"),l("mtext",null," "),l("mi",null,"i"),l("mi",null,"s"),l("mtext",null," "),l("mi",null,"a"),l("mtext",null," "),l("mi",null,"d"),l("mi",null,"a"),l("mi",null,"t"),l("mi",null,"a"),l("mi",null,"f"),l("mi",null,"l"),l("mi",null,"o"),l("mi",null,"w"),l("mtext",null," "),l("mi",null,"f"),l("mi",null,"a"),l("mi",null,"c"),l("mi",null,"t"),l("mi",null,"o"),l("mi",null,"r"),l("mo",{stretchy:"false"},"}")]),l("annotation",{encoding:"application/x-tex"},"V^{\\sharp} = \\{(n_i, d)|n_i\\ is\\ a\\ program\\ point\\ and\\ d\\ is \\ a\\ dataflow\\ factor\\}")])])]),n(" 。")]),l("li",null,[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",{stretchy:"false"},"("),l("msub",null,[l("mi",null,"n"),l("mi",null,"i")]),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"d"),l("mn",null,"1")]),l("mo",{stretchy:"false"},")"),l("mo",null,"→"),l("mo",{stretchy:"false"},"("),l("msub",null,[l("mi",null,"n"),l("mrow",null,[l("mi",null,"i"),l("mo",null,"+"),l("mn",null,"1")])]),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"d"),l("mn",null,"2")]),l("mo",{stretchy:"false"},")"),l("mo",null,"∈"),l("msup",null,[l("mi",null,"E"),l("mi",{mathvariant:"normal"},"♯")]),l("mo",null,"⇔"),l("mo",{stretchy:"false"},"("),l("msub",null,[l("mi",null,"d"),l("mn",null,"1")]),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"d"),l("mn",null,"2")]),l("mo",{stretchy:"false"},")"),l("mo",null,"∈"),l("msub",null,[l("mi",null,"R"),l("msub",null,[l("mi",null,"f"),l("mi",null,"i")])])]),l("annotation",{encoding:"application/x-tex"},"(n_i, d_1) \\to (n_{i + 1}, d_2) \\in E^{\\sharp} \\Leftrightarrow (d_1, d_2) \\in R_{f_i}")])])]),n(" ，其中， "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"f"),l("mi",null,"i")])]),l("annotation",{encoding:"application/x-tex"},"f_i")])])]),n(" 是 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"i")]),l("annotation",{encoding:"application/x-tex"},"i")])])]),n(" 处的流函数。")])])],-1),l("p",null,[n("基于此，我们可以得到之前那个程序的分解超图 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msup",null,[l("mi",null,"G"),l("mi",{mathvariant:"normal"},"♯")])]),l("annotation",{encoding:"application/x-tex"},"G^{\\sharp}")])])]),n(" 如下：")],-1),l("p",{style:{"text-align":"center"}},[l("img",{src:v,alt:"exploded-supergraph",style:{zoom:"30%"}})],-1),l("h3",{id:"_11-5-3-关于粘边",tabindex:"-1"},[n("11.5.3 关于粘边 "),l("a",{class:"header-anchor",href:"#_11-5-3-关于粘边","aria-label":'Permalink to "11.5.3 关于粘边"'},"​")],-1),l("p",null,[n("其中，还有一点会有疑问的是，我们能够理解为什么会有 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mn",null,"0"),l("mo",null,"→"),l("mi",null,"y")]),l("annotation",{encoding:"application/x-tex"},"0\\to y")])])]),n(" ，这个表示和输入无关的输出，比如 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"λ"),l("mi",null,"S"),l("mi",{mathvariant:"normal"},"."),l("mo",{stretchy:"false"},"{"),l("mi",null,"x"),l("mo",{separator:"true"},","),l("mi",null,"g"),l("mo",{stretchy:"false"},"}")]),l("annotation",{encoding:"application/x-tex"},"\\lambda S.\\{x, g\\}")])])]),n(" 这种。但是为什么要有 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mn",null,"0"),l("mo",null,"→"),l("mn",null,"0")]),l("annotation",{encoding:"application/x-tex"},"0\\to 0")])])]),n(" 这条边呢？")],-1),l("div",{class:"definition"},[l("p",{class:"title"},"定义11.16"),l("p",null,[n("称分解超图 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msup",null,[l("mi",null,"G"),l("mi",{mathvariant:"normal"},"♯")])]),l("annotation",{encoding:"application/x-tex"},"G^{\\sharp}")])])]),n(" 中形如 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",{stretchy:"false"},"("),l("msub",null,[l("mi",null,"n"),l("mi",null,"i")]),l("mo",{separator:"true"},","),l("mn",null,"0"),l("mo",{stretchy:"false"},")"),l("mo",null,"→"),l("mo",{stretchy:"false"},"("),l("msub",null,[l("mi",null,"n"),l("mrow",null,[l("mi",null,"i"),l("mo",null,"+"),l("mn",null,"1")])]),l("mo",{separator:"true"},","),l("mn",null,"0"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"(n_i, 0) \\to (n_{i+1}, 0)")])])]),n(" 这样的边为 "),l("strong",null,"粘边（Glue Edge）"),n(" 。")])],-1),l("p",null,[n("在传统的数据流分析中，我们会通过检查数据流因素 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"a")]),l("annotation",{encoding:"application/x-tex"},"a")])])]),n(" 是否在 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"OUT[s_i]")])])]),n(" 中来检查该数据流因素是否在程序点 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",{stretchy:"false"},"("),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"s"),l("mrow",null,[l("mi",null,"i"),l("mo",null,"+"),l("mn",null,"1")])]),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"(s_i, s_{i+1})")])])]),n(" 处成立 。因为数据流因素是通过流函数的组合进行传递的（见定理4.10），从而我们可以通过直接查看 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"OUT[s_i]")])])]),n(" 的方式来判断。")],-1),l("p",null,[n("但是，在IFDS中，数据流因素 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"a")]),l("annotation",{encoding:"application/x-tex"},"a")])])]),n(" 是否在 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"n"),l("mn",null,"4")])]),l("annotation",{encoding:"application/x-tex"},"n_4")])])]),n(" 处成立是通过判断在 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msup",null,[l("mi",null,"G"),l("mi",{mathvariant:"normal"},"♯")])]),l("annotation",{encoding:"application/x-tex"},"G^{\\sharp}")])])]),n(" 中是否存从 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",{stretchy:"false"},"("),l("msub",null,[l("mi",null,"s"),l("mrow",null,[l("mi",null,"m"),l("mi",null,"a"),l("mi",null,"i"),l("mi",null,"n")])]),l("mo",{separator:"true"},","),l("mn",null,"0"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"(s_{main}, 0)")])])]),n(" 到 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",{stretchy:"false"},"("),l("msub",null,[l("mi",null,"n"),l("mn",null,"4")]),l("mo",{separator:"true"},","),l("mi",null,"a"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"(n_4, a)")])])]),n(" 的路径来决定的（如果读到这里已经忘了这件事情的话可以回顾一下结论 11.1）。")],-1),l("p",null,"上述的两者（传统数据流分析和IFDS）之间是有区别的，我们看一个简单的例子就能明白了。",-1),l("p",{style:{"text-align":"center"}},[l("img",{src:F,alt:"gule-edge",style:{zoom:"20%"}})],-1),l("p",null,[n("上面左图中是不含 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mn",null,"0"),l("mo",null,"→"),l("mn",null,"0")]),l("annotation",{encoding:"application/x-tex"},"0\\to 0")])])]),n("这条边的情况，右图是符合我们定义的情况。在左图中，我们发现， "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"λ"),l("mi",null,"S"),l("mi",{mathvariant:"normal"},"."),l("mo",{stretchy:"false"},"{"),l("mi",null,"a"),l("mo",{stretchy:"false"},"}")]),l("annotation",{encoding:"application/x-tex"},"\\lambda S.\\{a\\}")])])]),n(" 说无论 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"S")]),l("annotation",{encoding:"application/x-tex"},"S")])])]),n(" 的输入是什么， "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"a")]),l("annotation",{encoding:"application/x-tex"},"a")])])]),n(" 都成立。")],-1),l("p",null,[n("但是，如果没有像右图中的 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mn",null,"0"),l("mo",null,"→"),l("mn",null,"0")]),l("annotation",{encoding:"application/x-tex"},"0\\to 0")])])]),n(" 这样的边，很多个代表关系形成的二部图就没办法“粘”在一起了，就相当于无法表达出原本的流函数的复合了。从而，IFDS无法在这样的分裂的图上通过可达性分析得出正确的结论了。")],-1),l("p",null,"一句话总结：IFDS 中分解超图上的粘边是为了表达出流函数的复合运算。",-1),l("h3",{id:"_11-5-4-制表算法",tabindex:"-1"},[n("11.5.4 制表算法 "),l("a",{class:"header-anchor",href:"#_11-5-4-制表算法","aria-label":'Permalink to "11.5.4 制表算法"'},"​")],-1),l("h4",{id:"直观感知",tabindex:"-1"},[n("直观感知 "),l("a",{class:"header-anchor",href:"#直观感知","aria-label":'Permalink to "直观感知"'},"​")],-1),l("p",null,[n("有了 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msup",null,[l("mi",null,"G"),l("mi",{mathvariant:"normal"},"♯")])]),l("annotation",{encoding:"application/x-tex"},"G^{\\sharp}")])])]),n(" 之后，下面我们只要解决图 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msup",null,[l("mi",null,"G"),l("mi",{mathvariant:"normal"},"♯")])]),l("annotation",{encoding:"application/x-tex"},"G^{\\sharp}")])])]),n(" 上的CFL可达性问题就行了。先来看两个例子：")],-1),l("figure",null,[l("img",{src:P,alt:"alg-eg",loading:"lazy",decoding:"async"})],-1),l("p",null,[n("上面左图中圈起来的 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"g")]),l("annotation",{encoding:"application/x-tex"},"g")])])]),n(" 是有可能未初始化的，因为存在一条可实现的路径，其CFL表示是 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"e"),l("mi",null,"e"),l("msub",null,[l("mo",{stretchy:"false"},"("),l("mn",null,"5")]),l("mi",null,"e"),l("mi",null,"e"),l("msub",null,[l("mo",{stretchy:"false"},")"),l("mn",null,"5")]),l("mi",null,"e"),l("mo",null,"∈"),l("mi",null,"L"),l("mo",{stretchy:"false"},"("),l("mi",null,"r"),l("mi",null,"e"),l("mi",null,"a"),l("mi",null,"l"),l("mi",null,"i"),l("mi",null,"z"),l("mi",null,"a"),l("mi",null,"b"),l("mi",null,"l"),l("mi",null,"e"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"ee(_5ee)_5e \\in L(realizable)")])])]),n(" （如果到这里已经忘了请回头再看一眼11.2.2）。")],-1),l("p",null,[n("但是上面右图中圈起来的 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"g")]),l("annotation",{encoding:"application/x-tex"},"g")])])]),n(" 是不可能未初始化的，因为到达这个 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"g")]),l("annotation",{encoding:"application/x-tex"},"g")])])]),n(" 的路径是不可实现的，其CFL表示为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"e"),l("mi",null,"e"),l("msub",null,[l("mo",{stretchy:"false"},"("),l("mn",null,"5")]),l("mi",null,"e"),l("mi",null,"e"),l("msub",null,[l("mo",{stretchy:"false"},")"),l("mn",null,"11")]),l("mi",null,"e"),l("mo",{mathvariant:"normal"},"∉"),l("mi",null,"L"),l("mo",{stretchy:"false"},"("),l("mi",null,"r"),l("mi",null,"e"),l("mi",null,"a"),l("mi",null,"l"),l("mi",null,"i"),l("mi",null,"z"),l("mi",null,"a"),l("mi",null,"b"),l("mi",null,"l"),l("mi",null,"e"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"ee(_5ee)_{11}e \\notin L(realizable)")])])]),n(" ，一个不可实现的路径一定是不可行的。")],-1),l("blockquote",null,[l("p",null,[n("这里的 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mn",null,"5")]),l("annotation",{encoding:"application/x-tex"},"5")])])]),n(" 和 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mn",null,"11")]),l("annotation",{encoding:"application/x-tex"},"11")])])]),n(" 是调用点（call site）在源程序中的行号，这个例子的源程序见 11.4.1 。")])],-1),l("p",null,"当然了，没有路径肯定是不行了，也就不用再检查是否可实现了了，这里就不举例了。",-1),l("p",null,[n("那有没有一个算法能够帮助我们判断所有的点是否CFL可达呢？答案是有的，制表算法能够帮助我们把从 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",{stretchy:"false"},"("),l("msub",null,[l("mi",null,"S"),l("mrow",null,[l("mi",null,"m"),l("mi",null,"a"),l("mi",null,"i"),l("mi",null,"n")])]),l("mo",{separator:"true"},","),l("mn",null,"0"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"(S_{main}, 0)")])])]),n(" 开始的所有的可实现路径找出来。")],-1),l("p",{style:{"text-align":"center"}},[l("img",{src:S,alt:"alg-res",style:{zoom:"100%"}})],-1),l("p",null,[n("其中蓝色实心的就是CFL可达的点，空心的就是CFL不可达的点。其中，CFL使用的是 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"L"),l("mo",{stretchy:"false"},"("),l("mi",null,"r"),l("mi",null,"e"),l("mi",null,"a"),l("mi",null,"l"),l("mi",null,"i"),l("mi",null,"z"),l("mi",null,"a"),l("mi",null,"b"),l("mi",null,"l"),l("mi",null,"e"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"L(realizable)")])])]),n(" 这个语言。到现在为止，我们完成了对该程序的数据流分析，最后的问题就是：能够计算分解超图中各个结点的 CFL 可达性的制表算法到底是啥了。不过有一点读者现在就应当理解的是：整个问题到此为止已经被转化成了一个纯粹的图问题了。")],-1),l("h4",{id:"制表算法",tabindex:"-1"},[n("制表算法 "),l("a",{class:"header-anchor",href:"#制表算法","aria-label":'Permalink to "制表算法"'},"​")],-1),l("p",null,[n("从结论11.1的第3点以及上面对制表算法的直观感知，我们应该能够知道的是 "),l("strong",null,"制表算法（Tabulation Algorithm）"),n(" 的功能是给定分解超图，求其中的所有可实现路径。")],-1),l("div",{class:"algorithm"},[l("p",{class:"title"},"算法11.1 制表算法（Tabulation Algorithm）"),l("iframe",{src:"/posts/StaticAnalytics/11-ifds/tb-alg.html",frameborder:"no",border:"0",marginwidth:"0",width:"100%",height:"1100px",marginheight:"0",scrolling:"auto",style:{"box-shadow":"none"}})],-1),l("p",null,[n("算法11.1的复杂度为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mo",{stretchy:"false"},"("),l("mi",{mathvariant:"normal"},"∣"),l("mi",null,"E"),l("mi",{mathvariant:"normal"},"∣"),l("mi",{mathvariant:"normal"},"∣"),l("mi",null,"D"),l("msup",null,[l("mi",{mathvariant:"normal"},"∣"),l("mn",null,"3")]),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"O(|E||D|^3)")])])]),n(" ，其中 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"E")]),l("annotation",{encoding:"application/x-tex"},"E")])])]),n(" 是分解超图的边集， "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"D")]),l("annotation",{encoding:"application/x-tex"},"D")])])]),n(" 是数据流值集。")],-1),l("p",null,[n("关于算法的具体细节我们不多分析，因为这会引入太多琐碎的内容，而这些琐碎对于这个基础教程来说是不必要的，具体可以看前面提到的"),l("a",{href:"https://www.csa.iisc.ac.in/~raghavan/CleanedPav2011/idfs-popl95.pdf",target:"_blank",rel:"noreferrer"},"论文")],-1),l("p",null,"不过我们会通过一个简单的例子稍微介绍一下制表算法核心的工作原理。",-1),l("h4",{id:"工作原理",tabindex:"-1"},[n("工作原理 "),l("a",{class:"header-anchor",href:"#工作原理","aria-label":'Permalink to "工作原理"'},"​")],-1),l("p",null,[n("我们以一个单个的数据流因素来解释一下制表算法的核心工作机制。下图中黑色的部分是 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"p")]),l("annotation",{encoding:"application/x-tex"},"p")])])]),n(" 和 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msup",null,[l("mi",null,"p"),l("mrow",null,[l("mo",{mathvariant:"normal"},"′"),l("mo",{mathvariant:"normal"},"′")])])]),l("annotation",{encoding:"application/x-tex"},"p''")])])]),n(" 都调用了 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msup",null,[l("mi",null,"p"),l("mo",{mathvariant:"normal",lspace:"0em",rspace:"0em"},"′")])]),l("annotation",{encoding:"application/x-tex"},"p'")])])]),n(" 的时候，只考虑一个数据流因素的分解超图的简化版示意图。")],-1),l("p",{style:{"text-align":"center"}},[l("img",{src:R,alt:"tb-core",style:{zoom:"35%"}})],-1),l("ol",null,[l("li",null,[l("p",null,"在每发现一个方法可达的时候，将可达性分析本地化。"),l("blockquote",null,[l("p",null,[n("见图上 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"S"),l("msup",null,[l("mi",null,"p"),l("mo",{mathvariant:"normal",lspace:"0em",rspace:"0em"},"′")])])]),l("annotation",{encoding:"application/x-tex"},"S_{p'}")])])]),n(" 出的自引（self-reference）绿边。")])]),l("ul",null,[l("li",null,[l("p",null,[n("图上形如 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"v"),l("mn",null,"1")]),l("mo",null,"→"),l("msub",null,[l("mi",null,"v"),l("mn",null,"2")])]),l("annotation",{encoding:"application/x-tex"},"v_1 \\to v_2")])])]),n(" 的绿边表示 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"v"),l("mn",null,"2")])]),l("annotation",{encoding:"application/x-tex"},"v_2")])])]),n(" 从 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"v"),l("mn",null,"1")])]),l("annotation",{encoding:"application/x-tex"},"v_1")])])]),n(" 可达（注意这里只是一般的可达，并不特指 CFL 可达，CFL 可达是通过后面的 2 和 3 两点来共同保证的）。")])]),l("li",null,[l("p",null,[n("当一个过程 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"S"),l("msup",null,[l("mi",null,"p"),l("mo",{mathvariant:"normal",lspace:"0em",rspace:"0em"},"′")])])]),l("annotation",{encoding:"application/x-tex"},"S_{p'}")])])]),n(" 被调用的时候，让 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"S"),l("msup",null,[l("mi",null,"p"),l("mo",{mathvariant:"normal",lspace:"0em",rspace:"0em"},"′")])])]),l("annotation",{encoding:"application/x-tex"},"S_{p'}")])])]),n(" 自引表示它一定是被某个过程给调用了，但具体是哪一个过程对可达性来说其实不重要，"),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msup",null,[l("mi",null,"p"),l("mo",{mathvariant:"normal",lspace:"0em",rspace:"0em"},"′")])]),l("annotation",{encoding:"application/x-tex"},"p'")])])]),n(" 内部的可达性分析只需要做一遍，当 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msup",null,[l("mi",null,"p"),l("mo",{mathvariant:"normal",lspace:"0em",rspace:"0em"},"′")])]),l("annotation",{encoding:"application/x-tex"},"p'")])])]),n(" 被调用第二次的时候，发现 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"S"),l("msup",null,[l("mi",null,"p"),l("mo",{mathvariant:"normal",lspace:"0em",rspace:"0em"},"′")])])]),l("annotation",{encoding:"application/x-tex"},"S_{p'}")])])]),n(" 已经自引了，就不需要再分析 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msup",null,[l("mi",null,"p"),l("mo",{mathvariant:"normal",lspace:"0em",rspace:"0em"},"′")])]),l("annotation",{encoding:"application/x-tex"},"p'")])])]),n(" 内部的可达性了。")])]),l("li",null,[l("p",null,"我们也可以一直维护着一个全局的可达性分析，但这样会有冗余的重复分析，不如对每个可达方法进行局部分析，然后再组合成一个整体的结果来得更高效。")])])]),l("li",null,[l("p",null,"在处理每一个过程的结束结点（Exit Node）的时候，做调用-返回的匹配（Call-to-return Matching）："),l("blockquote",null,[l("p",null,"见图上黄色部分。")]),l("ul",null,[l("li",null,[l("p",null,[n("先找到所有的调用 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msup",null,[l("mi",null,"p"),l("mo",{mathvariant:"normal",lspace:"0em",rspace:"0em"},"′")])]),l("annotation",{encoding:"application/x-tex"},"p'")])])]),n(" 的调用点 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",{stretchy:"false"},"("),l("mi",null,"C"),l("mi",null,"a"),l("mi",null,"l"),l("msub",null,[l("mi",null,"l"),l("mi",null,"p")]),l("mo",{separator:"true"},","),l("mi",null,"C"),l("mi",null,"a"),l("mi",null,"l"),l("msub",null,[l("mi",null,"l"),l("msup",null,[l("mi",null,"p"),l("mrow",null,[l("mo",{mathvariant:"normal"},"′"),l("mo",{mathvariant:"normal"},"′")])])]),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"(Call_p, Call_{p''})")])])]),n(" ；")])]),l("li",null,[l("p",null,[n("然后找出它们对应的返回点 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",{stretchy:"false"},"("),l("mi",null,"R"),l("mi",null,"e"),l("msub",null,[l("mi",null,"t"),l("mi",null,"p")]),l("mo",{separator:"true"},","),l("mi",null,"R"),l("mi",null,"e"),l("msub",null,[l("mi",null,"t"),l("msup",null,[l("mi",null,"p"),l("mrow",null,[l("mo",{mathvariant:"normal"},"′"),l("mo",{mathvariant:"normal"},"′")])])]),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"(Ret_{p}, Ret_{p''})")])])]),n(" 。")])])])]),l("li",null,[l("p",null,[n("从 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",{stretchy:"false"},"("),l("mi",null,"C"),l("mi",null,"a"),l("mi",null,"l"),l("mi",null,"l"),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"d"),l("mi",null,"m")]),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"(Call, d_m)")])])]),n(" 到 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",{stretchy:"false"},"("),l("mi",null,"R"),l("mi",null,"e"),l("mi",null,"t"),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"d"),l("mi",null,"n")]),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"(Ret, d_n)")])])]),n(" 的总结边（Summary Edge）表示通过调用方法 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msup",null,[l("mi",null,"p"),l("mo",{mathvariant:"normal",lspace:"0em",rspace:"0em"},"′")])]),l("annotation",{encoding:"application/x-tex"},"p'")])])]),n(" ， "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"d"),l("mi",null,"n")])]),l("annotation",{encoding:"application/x-tex"},"d_n")])])]),n(" 是从 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"d"),l("mi",null,"m")])]),l("annotation",{encoding:"application/x-tex"},"d_m")])])]),n(" 可达的。")]),l("blockquote",null,[l("p",null,"见图上粉色部分，如果一个方法的开始结点到结束结点可达，会在这个方法所有匹配的调用点和返回点之间添加总结边。")]),l("ul",null,[l("li",null,[l("p",null,"在此时，有些方法调用可能还没有被处理，等之后再用到这个方法的时候，有了总结边，我们就知道了这个方法的可达性，从而就不需要再重复地分析一遍这个方法了，能够消除冗余的分析过程。")]),l("li",null,[l("p",null,"其实，我感觉这里的总结边有点像是一种缓存，用空间换时间，从而提高算法效率。这也是为什么在上面 1 的时候只需要本地化地分析过程内部的可达性就可以了，因为之后可以用总结边来概括这个过程调用的开始结点和结束结点之间的可达性。")])])])],-1),l("p",{style:{"text-align":"center"}},[l("img",{src:D,alt:"tb-res",style:{zoom:"33%"}})],-1),l("ol",{start:"4"},[l("li",null,[n("当图上的一个点 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",{stretchy:"false"},"("),l("mi",null,"n"),l("mo",{separator:"true"},","),l("mi",null,"d"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"(n, d)")])])]),n(" 从空心变成实心的时候，说明存在一条从 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",{stretchy:"false"},"("),l("msub",null,[l("mi",null,"S"),l("mrow",null,[l("mi",null,"m"),l("mi",null,"a"),l("mi",null,"i"),l("mi",null,"n")])]),l("mo",{separator:"true"},","),l("mn",null,"0"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"(S_{main}, 0)")])])]),n(" 到 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",{stretchy:"false"},"("),l("mi",null,"n"),l("mo",{separator:"true"},","),l("mi",null,"d"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"(n, d)")])])]),n(" 的可实现路径（realizable path）。")])],-1),l("h2",{id:"_11-6-理解-ifds-的分配性",tabindex:"-1"},[n("11.6 理解 IFDS 的分配性 "),l("a",{class:"header-anchor",href:"#_11-6-理解-ifds-的分配性","aria-label":'Permalink to "11.6 理解 IFDS 的分配性"'},"​")],-1),l("p",null,[n("分配性是 IFDS 的关键，定义可达性问题、活跃变量问题、空闲表达式问题是可分配的（所有的 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"g"),l("mi",null,"e"),l("mi",null,"n"),l("mi",{mathvariant:"normal"},"/"),l("mi",null,"k"),l("mi",null,"i"),l("mi",null,"l"),l("mi",null,"l")]),l("annotation",{encoding:"application/x-tex"},"gen/kill")])])]),n(" 问题都是可分配的），可以用 IFDS 解决。但是像常量传播、指针分析这类不可分配的问题，就没有办法用标准的 IFDS 方法解决。")],-1),l("h3",{id:"_11-6-1-分配性的理解和判断",tabindex:"-1"},[n("11.6.1 分配性的理解和判断 "),l("a",{class:"header-anchor",href:"#_11-6-1-分配性的理解和判断","aria-label":'Permalink to "11.6.1 分配性的理解和判断"'},"​")],-1),l("p",null,"在 4.5.2 中，我们提过如果流函数具有分配性，那么迭代算法可以达到 MOP 同等的精度，否则迭代算法不如 MOP 。分配性的具体定义见定义4.11，以汇集（Meet）操作为例：",-1),l("p",null,[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[l("semantics",null,[l("mrow",null,[l("mi",null,"F"),l("mo",{stretchy:"false"},"("),l("mi",null,"x"),l("mo",null,"∧"),l("mi",null,"y"),l("mo",{stretchy:"false"},")"),l("mo",null,"="),l("mi",null,"F"),l("mo",{stretchy:"false"},"("),l("mi",null,"x"),l("mo",{stretchy:"false"},")"),l("mo",null,"∧"),l("mi",null,"F"),l("mo",{stretchy:"false"},"("),l("mi",null,"y"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"F(x \\wedge y) = F(x) \\wedge F(y) ")])])])],-1),l("p",null,[n("在 IFDS 中，每个流函数一次只能处理一个数据流因素——即只能计算 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"F"),l("mo",{stretchy:"false"},"("),l("mi",null,"x"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"F(x)")])])]),n(" 或者 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"F"),l("mo",{stretchy:"false"},"("),l("mi",null,"y"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"F(y)")])])]),n(" ，不能计算 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"F"),l("mo",{stretchy:"false"},"("),l("mi",null,"x"),l("mo",null,"∧"),l("mi",null,"y"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"F(x \\wedge y)")])])]),n(" 。因为每个代表关系（见定义11.4）只能说明“如果x存在，那么 …”，“如果y存在，那么…”但是并不能表达“如果x和y都存在，那么…”这样的逻辑。")],-1),l("p",null,[n("于是，比如说常量传播问题（我们暂时忽略它数据流值不是有限集的问题），对于 "),l("code",null,"z = x + y"),n(" 来说，只有同时知道了 "),l("code",null,"x"),n(" 和 "),l("code",null,"y"),n(" 的值，才能判断 "),l("code",null,"z"),n(" 的值。而这是代表关系所无法表达出来的，也就没办法进行后面分解超图的构建了。")],-1),l("p",null,[n("然而，如果不考虑定义域无限的问题，我们其实是可以用 IFDS 的方式来分析线性常量传播（只包含 "),l("code",null,"y = 2x + 3"),n(" 这种语句）或者拷贝常量传播（只包含 "),l("code",null,"x = 2, y = x"),n(" 这种语句）的，因为它们的结果只受一个因素影响。")],-1),l("p",null,"所以，我们可以总结一个简单的判断一个分析问题能否通过IFDS表达和解决的规则：",-1),l("div",{class:"conclusion"},[l("p",{class:"title"},"结论11.2"),l("p",null,[n("给定一个语句 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"s")]),l("annotation",{encoding:"application/x-tex"},"s")])])]),n(" ，除了 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"s")]),l("annotation",{encoding:"application/x-tex"},"s")])])]),n(" 本身，如果我们还需要考虑 "),l("strong",null,"多个（Multiple）"),n(" 数据流因素作为输入来产生正确的输出，那么这个分析就不具有分配性，也就不能用IFDS来表达。")]),l("p",null,"在 IFDS 能够处理的问题中，每个数据流因素及其传播都应当可以被独立地处理，并且这样做并不会影响最终结果的正确性，否则就无法使用 IFDS 来解决。")],-1),l("h3",{id:"_11-6-2-指针分析",tabindex:"-1"},[n("11.6.2 指针分析 "),l("a",{class:"header-anchor",href:"#_11-6-2-指针分析","aria-label":'Permalink to "11.6.2 指针分析"'},"​")],-1),l("p",null,[n("考虑如下的指针分析问题，应用 IFDS 算法，其中为了方便，假设我们已知整个程序只有这 4 条语句，也就是说需要分析的对象只有那个 "),l("code",null,"new T"),n(" ，相当于我们是在分析哪些指针指向了 "),l("code",null,"new T"),n(" 。应用 IFDS 算法的思路，得到的结果如下（只看黑边）：")],-1),l("p",{style:{"text-align":"center"}},[l("img",{src:T,alt:"pointer-analysis",style:{zoom:"35%"}})],-1),l("p",null,[n("我们会得到一个错误的结果："),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"z")]),l("annotation",{encoding:"application/x-tex"},"z")])])]),n(" 并不能够指向 "),l("code",null,"new T"),n("，因为它不 CFL 可达。得到错误结果的原因是 IFDS 的过程中我们没能够表达出图中红色虚线所指示的关系，从而让 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"z")]),l("annotation",{encoding:"application/x-tex"},"z")])])]),n(" 变得不可达了。")],-1),l("p",null,[n("按理说， "),l("code",null,"z"),n(" 和 "),l("code",null,"y.f"),n(" 应该也指向 "),l("code",null,"new T"),n(" ，但是因为缺了红色虚线那条边，所以没有到 "),l("code",null,"y.f"),n(" 和 "),l("code",null,"z"),n(" 的可实现路径。缺那条线的原因在于在 "),l("code",null,"x.f = x"),n(" 的时候， "),l("code",null,"y.f"),n(" 也随之指向 "),l("code",null,"new T"),n(" 了，但这一点在流函数中是没能够体现出来的。简单总结，就是流函数只看自己这一步，它的输入数据缺少别名信息，比如说 "),l("code",null,"x"),n(" 和 "),l("code",null,"y"),n(" 是别名， "),l("code",null,"x.f"),n(" 和 "),l("code",null,"y.f"),n(" 也是别名，为了产生正确的结果，我们需要用到这些信息。")],-1),l("p",null,[n("可如果考虑别名信息的话，我们就需要同时考虑多个输入的数据流因素，比如说 "),l("code",null,"x"),n(" 和 "),l("code",null,"y"),n(" ，但标准IFDS的流函数只能独立地一次处理一个因素，因此不能用标准的IFDS来解决。")],-1),l("p",null,"综上，指针分析也是不具有分配性的。",-1),l("h2",{id:"_11-7-自检问题",tabindex:"-1"},[n("11.7 自检问题 "),l("a",{class:"header-anchor",href:"#_11-7-自检问题","aria-label":'Permalink to "11.7 自检问题"'},"​")],-1),l("ol",null,[l("li",null,[l("p",null,"什么是CFL可达（CFL-Reachability）？")]),l("li",null,[l("p",null,"IFDS（Interprocedural Finite Distributive Subset Problem）的基本想法是什么？")]),l("li",null,[l("p",null,"怎样的问题可以用IFDS来解决？")])],-1)])),"main-header":a(()=>[i(t.$slots,"main-header")]),"main-header-after":a(()=>[i(t.$slots,"main-header-after")]),"main-nav":a(()=>[i(t.$slots,"main-nav")]),"main-content":a(()=>[i(t.$slots,"main-content")]),"main-content-after":a(()=>[i(t.$slots,"main-content-after")]),"main-nav-before":a(()=>[i(t.$slots,"main-nav-before")]),"main-nav-after":a(()=>[i(t.$slots,"main-nav-after")]),comment:a(()=>[i(t.$slots,"comment")]),footer:a(()=>[i(t.$slots,"footer")]),aside:a(()=>[i(t.$slots,"aside")]),"aside-custom":a(()=>[i(t.$slots,"aside-custom")]),default:a(()=>[i(t.$slots,"default")]),_:3},8,["frontmatter"])}}};export{B as default};

import{_ as r}from"./ValaxyMain.vue_vue_type_style_index_0_lang-Bn109ln0.js";import{c as p,w as t,f as w,a as x,p as o,o as g,g as l,h as n,r as i}from"./app-DvGICojQ.js";import"./YunFooter.vue_vue_type_style_index_0_lang-6I6EwKPx.js";import"./YunCard.vue_vue_type_script_setup_true_lang-G2SLBOpE.js";import"./index-C5okkQwF.js";import"./YunPageHeader.vue_vue_type_script_setup_true_lang-B-GmT0Fn.js";import"./post-JeTKiWMk.js";const M="/assets/propagate-C7bye01k.jpg",d="/assets/rd-2BoGhWCU.png",f="/assets/rd-eg-z0VOjLpT.jpg",k="/assets/rda-eg-CuFQOMBj.png",y="/assets/lv-DwJlAsbB.png",b="/assets/lv-eg-__4n0jon.png",B="/assets/lv-alg-eg-CoCUkPwl.png",_="/assets/ae-eg-DCzrInlC.png",D={__name:"20240731 3 数据流分析-应用",setup(L,{expose:c}){const s=JSON.parse('{"title":"3 数据流分析-应用","description":"","frontmatter":{"title":"3 数据流分析-应用","date":"2024-07-31T00:00:00.000Z","tags":["静态代码分析"],"categories":["静态代码分析"]},"headers":[{"level":2,"title":"3.1 数据流分析初步","slug":"_3-1-数据流分析初步","link":"#_3-1-数据流分析初步","children":[{"level":3,"title":"3.1.1 基本概念","slug":"_3-1-1-基本概念","link":"#_3-1-1-基本概念","children":[]},{"level":3,"title":"3.1.2 约束记号","slug":"_3-1-2-约束记号","link":"#_3-1-2-约束记号","children":[]}]},{"level":2,"title":"3.2 定义可达性分析","slug":"_3-2-定义可达性分析","link":"#_3-2-定义可达性分析","children":[{"level":3,"title":"3.2.1 问题简化","slug":"_3-2-1-问题简化","link":"#_3-2-1-问题简化","children":[]},{"level":3,"title":"3.2.2 问题描述","slug":"_3-2-2-问题描述","link":"#_3-2-2-问题描述","children":[]},{"level":3,"title":"3.2.3 问题分析","slug":"_3-2-3-问题分析","link":"#_3-2-3-问题分析","children":[]},{"level":3,"title":"3.2.4 问题求解","slug":"_3-2-4-问题求解","link":"#_3-2-4-问题求解","children":[]}]},{"level":2,"title":"3.3 活跃变量分析","slug":"_3-3-活跃变量分析","link":"#_3-3-活跃变量分析","children":[{"level":3,"title":"3.3.1 问题描述","slug":"_3-3-1-问题描述","link":"#_3-3-1-问题描述","children":[]},{"level":3,"title":"3.3.2 问题分析","slug":"_3-3-2-问题分析","link":"#_3-3-2-问题分析","children":[]},{"level":3,"title":"3.3.3 问题求解","slug":"_3-3-3-问题求解","link":"#_3-3-3-问题求解","children":[]}]},{"level":2,"title":"3.4 可用表达式分析","slug":"_3-4-可用表达式分析","link":"#_3-4-可用表达式分析","children":[{"level":3,"title":"3.4.1 问题描述","slug":"_3-4-1-问题描述","link":"#_3-4-1-问题描述","children":[]},{"level":3,"title":"3.4.2 问题分析","slug":"_3-4-2-问题分析","link":"#_3-4-2-问题分析","children":[]},{"level":3,"title":"3.4.3 问题求解","slug":"_3-4-3-问题求解","link":"#_3-4-3-问题求解","children":[]}]},{"level":2,"title":"3.5 总结","slug":"_3-5-总结","link":"#_3-5-总结","children":[]},{"level":2,"title":"3.6 自检问题","slug":"_3-6-自检问题","link":"#_3-6-自检问题","children":[]}],"relativePath":"pages/posts/静态代码分析/20240731 3 数据流分析-应用/20240731 3 数据流分析-应用.md","path":"/home/runner/work/LiuZhuJunYa.github.io/LiuZhuJunYa.github.io/pages/posts/静态代码分析/20240731 3 数据流分析-应用/20240731 3 数据流分析-应用.md","lastUpdated":1731428437000}'),e=x(),m=s.frontmatter||{};return e.meta.frontmatter=Object.assign(e.meta.frontmatter||{},s.frontmatter||{}),o("pageData",s),o("valaxy:frontmatter",m),globalThis.$frontmatter=m,c({frontmatter:{title:"3 数据流分析-应用",date:"2024-07-31T00:00:00.000Z",tags:["静态代码分析"],categories:["静态代码分析"]}}),(a,u)=>{const h=r;return g(),p(h,{frontmatter:w(m)},{"main-content-md":t(()=>u[0]||(u[0]=[l("p",null,[n("原文链接："),l("a",{href:"https://static-analysis.cuijiacai.com/03-dfa-ap/",target:"_blank",rel:"noreferrer"},"https://static-analysis.cuijiacai.com/03-dfa-ap/")],-1),l("h1",{id:"_3-数据流分析-应用",tabindex:"-1"},[n("3 数据流分析-应用 "),l("a",{class:"header-anchor",href:"#_3-数据流分析-应用","aria-label":'Permalink to "3 数据流分析-应用"'},"​")],-1),l("h2",{id:"_3-1-数据流分析初步",tabindex:"-1"},[n("3.1 数据流分析初步 "),l("a",{class:"header-anchor",href:"#_3-1-数据流分析初步","aria-label":'Permalink to "3.1 数据流分析初步"'},"​")],-1),l("h3",{id:"_3-1-1-基本概念",tabindex:"-1"},[n("3.1.1 基本概念 "),l("a",{class:"header-anchor",href:"#_3-1-1-基本概念","aria-label":'Permalink to "3.1.1 基本概念"'},"​")],-1),l("div",{class:"definition"},[l("p",{class:"title"},"定义3.1"),l("p",null,[l("strong",null,"数据流分析（Data Flow Analysis, DFA）"),n(" 是指分析“数据在程序中是怎样流动的”。具体来讲，其")]),l("ul",null,[l("li",null,[l("p",null,[n("分析的对象是基于抽象（Abstraction，见定义1.7）的 "),l("strong",null,"应用特定型数据（Application-Specific Data）"),n(" ；")])]),l("li",null,[l("p",null,[n("分析的行为是数据的“流动”，分析的方式是 "),l("strong",null,"安全近似（Safe-Approximation）"),n(" ——根据安全性需求选择过近似（Over-Approximation）还是欠近似（Under-Approximation）；")])]),l("li",null,[l("p",null,[n("分析的基础是控制流图（Control Flow Graph, CFG），CFG是程序 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"P")]),l("annotation",{encoding:"application/x-tex"},"P")])])]),n(" 的表示方法；")])]),l("li",null,[l("p",null,"数据流动的场景有两个："),l("ul",null,[l("li",null,[l("p",null,"在CFG的点（Node）内流动，即程序基块（Basic Block，见定义2.2）内部的数据流；")]),l("li",null,[l("p",null,"在CFG的边（Edge）上流动，即由基块间控制流触发的数据流。")])])])])],-1),l("div",{class:"definition"},[l("p",{class:"title"},"定义3.2"),l("p",null,[n("我们将采用过近似策略，输出所有可能为真的信息的数据流分析称为 "),l("strong",null,"可能性分析（May Analysis）"),n(" ，将采用欠近似策略，输出信息必然为真的数据流分析称为 "),l("strong",null,"必然性分析（Must Analysis）"),n(" 。可能性分析和必然性分析应用于不同的场景，其目的都是为了分析的安全性（Safety of Analysis）。")])],-1),l("p",null,"从上述定义中可以看出，不同的数据流分析应用应当有：",-1),l("ul",null,[l("li",null,[l("p",null,"不同的数据抽象（Data Abstraction）;")]),l("li",null,[l("p",null,"不同的流安全近似策略——过近似或者欠近似；")]),l("li",null,[l("p",null,"不同的转移函数（Transfer Function，见定义1.8）和控制流处理方法（Control-Flow Handlings）。")])],-1),l("div",{class:"definition"},[l("p",{class:"title"},"定义3.3"),l("p",null,[n("定义程序 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"P")]),l("annotation",{encoding:"application/x-tex"},"P")])])]),n(" 的 "),l("strong",null,"抽象数据状态（Abstract Data State，ADS）"),n(" 为程序 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"P")]),l("annotation",{encoding:"application/x-tex"},"P")])])]),n(" 中所有的数据的抽象值（见定义1.7）的整体（具体数据结构可以根据需求来定义），抽象数据状态也称作 "),l("strong",null,"数据流值（Data-Flow Value）"),n(" 。基于此：")]),l("ul",null,[l("li",null,[l("p",null,[n("称每一个 IR 语句 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"s")]),l("annotation",{encoding:"application/x-tex"},"s")])])]),n(" 执行之前 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"p"),l("mi",null,"r"),l("mi",null,"e"),l("mo",{stretchy:"false"},"("),l("mi",null,"s"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"pre(s)")])])]),n(" 执行之后的数据流值为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"s")]),l("annotation",{encoding:"application/x-tex"},"s")])])]),n(" 的 "),l("strong",null,"输入状态（Input State）"),n(" ，记为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"s"),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"IN[s]")])])]),n(" ；")]),l("ul",null,[l("li",null,[n("其中， "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"p"),l("mi",null,"r"),l("mi",null,"e"),l("mo",{stretchy:"false"},"("),l("mi",null,"s"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"pre(s)")])])]),n(" 为控制流中 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"s")]),l("annotation",{encoding:"application/x-tex"},"s")])])]),n(" 的前驱的集合（Predecessors，见定义2.4）；")])])]),l("li",null,[l("p",null,[n("称每一个 IR 语句 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"s")]),l("annotation",{encoding:"application/x-tex"},"s")])])]),n(" 执行之后 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"s"),l("mi",null,"u"),l("mi",null,"c"),l("mo",{stretchy:"false"},"("),l("mi",null,"s"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"suc(s)")])])]),n(" 执行之前的数据流值为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"s")]),l("annotation",{encoding:"application/x-tex"},"s")])])]),n(" 的 "),l("strong",null,"输出状态（Output State）"),n(" ，记为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"s"),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"OUT[s]")])])]),n(" ；")]),l("ul",null,[l("li",null,[n("其中， "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"s"),l("mi",null,"u"),l("mi",null,"c"),l("mo",{stretchy:"false"},"("),l("mi",null,"s"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"suc(s)")])])]),n(" 为控制流中 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"s")]),l("annotation",{encoding:"application/x-tex"},"s")])])]),n(" 的后继的集合（Successors，见定义2.4）；")])])])])],-1),l("p",null,"基于上述定义，我们不难发现控制流会将 ADS 在 IR 语句之间传递，为了描述方便，我们可以定义一下程序点的概念。",-1),l("div",{class:"definition"},[l("p",{class:"title"},"定义3.4"),l("p",null,[n("考虑程序 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"P")]),l("annotation",{encoding:"application/x-tex"},"P")])])]),n(" 的 IR 语句集为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"S")]),l("annotation",{encoding:"application/x-tex"},"S")])])]),n("，定义集合")]),l("p",null,[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[l("semantics",null,[l("mrow",null,[l("mi",null,"P"),l("mi",null,"P"),l("mo",null,"="),l("mo",{stretchy:"false"},"{"),l("mo",{stretchy:"false"},"("),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"s"),l("mi",null,"j")]),l("mo",{stretchy:"false"},")"),l("mi",{mathvariant:"normal"},"∣"),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"s"),l("mi",null,"j")]),l("mo",null,"∈"),l("mi",null,"S"),l("mo",null,"∧"),l("mo",{stretchy:"false"},"("),l("msub",null,[l("mi",null,"s"),l("mi",null,"j")]),l("mo",null,"∈"),l("mi",null,"s"),l("mi",null,"u"),l("mi",null,"c"),l("mo",{stretchy:"false"},"("),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",{stretchy:"false"},")"),l("mo",null,"∨"),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",null,"∈"),l("mi",null,"p"),l("mi",null,"r"),l("mi",null,"e"),l("mo",{stretchy:"false"},"("),l("msub",null,[l("mi",null,"s"),l("mi",null,"j")]),l("mo",{stretchy:"false"},")"),l("mo",{stretchy:"false"},")"),l("mo",{stretchy:"false"},"}")]),l("annotation",{encoding:"application/x-tex"},"PP = \\{(s_i, s_j) | s_i, s_j\\in S \\wedge (s_j \\in suc(s_i) \\vee s_i \\in pre(s_j))\\} ")])])])]),l("p",null,[n("中的每一个元素为程序 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"P")]),l("annotation",{encoding:"application/x-tex"},"P")])])]),n(" 的一个 "),l("strong",null,"程序点（Program Point）"),n(" 。")])],-1),l("blockquote",null,[l("p",null,"简单理解：程序点可以用控制流中相邻语句的顺序二元组表示。"),l("p",null,"我的个人理解：其实说了这么多，程序点就是CFG的一条边罢了。")],-1),l("div",{class:"definition"},[l("p",{class:"title"},"定义3.5"),l("p",null,[n("我们称程序 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"P")]),l("annotation",{encoding:"application/x-tex"},"P")])])]),n(" 的所有可能的数据流值（见定义3.3）形成的集合为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"P")]),l("annotation",{encoding:"application/x-tex"},"P")])])]),n(" 的 "),l("strong",null,"定义域（Domain）"),n(" 。")])],-1),l("div",{class:"theorem"},[l("p",{class:"title"},"定理3.1"),l("p",null,[n("记程序 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"P")]),l("annotation",{encoding:"application/x-tex"},"P")])])]),n(" 的定义域为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"D")]),l("annotation",{encoding:"application/x-tex"},"D")])])]),n(" ，存在映射 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"f"),l("mrow",null,[l("mi",null,"P"),l("mi",null,"P"),l("mo",null,"→"),l("mi",null,"D")])])]),l("annotation",{encoding:"application/x-tex"},"f_{PP\\to D}")])])]),n(" 且 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"f")]),l("annotation",{encoding:"application/x-tex"},"f")])])]),n(" 是一个满射。")])],-1),l("blockquote",null,[l("p",null,"简单理解：每个程序点都对应了一个数据流值，每一个不同的（集合具有互异性）数据流值都会有一个或者多个程序点与之对应。")],-1),l("div",{class:"definition"},[l("p",{class:"title"},"定义3.6"),l("p",null,[n("定义 ADS 在控制流推动下融合时的运算为 "),l("strong",null,"交汇（meet）"),n(" ，用符号 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",null,"∧")]),l("annotation",{encoding:"application/x-tex"},"\\wedge")])])]),n(" 表示，其含义由具体的数据流分析决定。一般的，如果数据流值是集合类型的话，可能性分析下， "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",null,"∧")]),l("annotation",{encoding:"application/x-tex"},"\\wedge")])])]),n(" 常定义为并集，必然性分析下， "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",null,"∧")]),l("annotation",{encoding:"application/x-tex"},"\\wedge")])])]),n(" 常定义为交集。")])],-1),l("div",{class:"theorem"},[l("p",{class:"title"},"定理3.2"),l("p",null,"正向分析中（见定义3.8），每个语句s的输入状态，是其前驱语句输出状态的交汇，即："),l("p",null,[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[l("semantics",null,[l("mrow",null,[l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"s"),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("munder",null,[l("mo",null,"⋀"),l("mrow",null,[l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",null,"∈"),l("mi",null,"p"),l("mi",null,"r"),l("mi",null,"e"),l("mo",{stretchy:"false"},"("),l("mi",null,"s"),l("mo",{stretchy:"false"},")")])]),l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"IN[s] = \\bigwedge_{s_i \\in pre(s)} OUT[s_i] ")])])])]),l("p",null,"逆向分析中（见定义3.8），每个语句s的输出状态，是其后继语句输入状态的交汇，即："),l("p",null,[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"s"),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("munder",null,[l("mo",null,"⋀"),l("mrow",null,[l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",null,"∈"),l("mi",null,"s"),l("mi",null,"u"),l("mi",null,"c"),l("mo",{stretchy:"false"},"("),l("mi",null,"s"),l("mo",{stretchy:"false"},")")])]),l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"OUT[s] = \\bigwedge_{s_i \\in suc(s)} IN[s_i] ")])])])])],-1),l("p",null,"上述公式有如下3种常见的应用场景（以正向分析为例）。",-1),l("figure",null,[l("img",{src:M,alt:"propagate",loading:"lazy",decoding:"async"})],-1),l("p",null,"有了上面的一些定义和定理，我们就可以反过来再思考一下定义3.1，从而对数据流分析到底做了什么进行一些更加具体的、形式化的总结：",-1),l("div",{class:"conclusion"},[l("p",{class:"title"},"结论3.1"),l("p",null,[n("在每个具体的数据流分析中，我们最终会为每一个程序点（Program Point，见定义3.4）关联一个数据流值（Data-Flow Value，见定义3.3），这个数据流值表征了在这个程序点能够观察到的所有可能的程序状态（定理3.2）。从这个视角来看，数据流分析就是确定定理3.1中的满射 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"f"),l("mrow",null,[l("mi",null,"P"),l("mi",null,"P"),l("mo",null,"→"),l("mi",null,"D")])])]),l("annotation",{encoding:"application/x-tex"},"f_{PP\\to D}")])])]),n(" 。")])],-1),l("p",null,[n("从定理3.2中，我们还可以发现，每一个程序点 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",{stretchy:"false"},"("),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"s"),l("mi",null,"j")]),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"(s_i, s_j)")])])]),n(" 处的数据流值与 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"OUT[s_i]")])])]),n(" 和 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("msub",null,[l("mi",null,"s"),l("mi",null,"j")]),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"IN[s_j]")])])]),n(" 是对应的，也就是说求 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"f"),l("mrow",null,[l("mi",null,"P"),l("mi",null,"P"),l("mo",null,"→"),l("mi",null,"D")])])]),l("annotation",{encoding:"application/x-tex"},"f_{PP\\to D}")])])]),n(" 和求 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",{stretchy:"false"},"{"),l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"s"),l("mo",{stretchy:"false"},"]"),l("mo",{separator:"true"},","),l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"s"),l("mo",{stretchy:"false"},"]"),l("mi",{mathvariant:"normal"},"∣"),l("mi",null,"s"),l("mo",null,"∈"),l("mi",null,"S"),l("mo",{stretchy:"false"},"}")]),l("annotation",{encoding:"application/x-tex"},"\\{OUT[s], IN[s] | s\\in S\\}")])])]),n(" 两者做的其实是同一件事情。所以，从输入状态和输出状态的角度，我们也可以总结一下数据流分析做了什么：")],-1),l("div",{class:"conclusion"},[l("p",{class:"title"},"结论3.2"),l("p",null,[n("数据流分析就是要寻找一种解决方案（即结论3.1中的 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"f"),l("mrow",null,[l("mi",null,"P"),l("mi",null,"P"),l("mo",null,"→"),l("mi",null,"D")])])]),l("annotation",{encoding:"application/x-tex"},"f_{PP\\to D}")])])]),n(" ），对于程序 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"P")]),l("annotation",{encoding:"application/x-tex"},"P")])])]),n(" 中的所有语句 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"s")]),l("annotation",{encoding:"application/x-tex"},"s")])])]),n(" ，这种解决方案能够满足 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"s"),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"IN[s]")])])]),n(" 和 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"s"),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"OUT[s]")])])]),n(" 所需要满足的 "),l("strong",null,"安全近似导向型约束（Safe-Approximation-Oriented Constraints, SAOC）"),n(" ，SAOC主要有两种：")]),l("ul",null,[l("li",null,[l("p",null,"基于语句语意（Sematics of Statements）的约束，即由状态转移方程（见定义3.7）产生的约束；")]),l("li",null,[l("p",null,"基于控制流（Flow of Control）的约束，即定理3.2所产生的约束。")])])],-1),l("h3",{id:"_3-1-2-约束记号",tabindex:"-1"},[n("3.1.2 约束记号 "),l("a",{class:"header-anchor",href:"#_3-1-2-约束记号","aria-label":'Permalink to "3.1.2 约束记号"'},"​")],-1),l("div",{class:"definition"},[l("p",{class:"title"},"定义3.7"),l("p",null,[n("考虑程序 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"P")]),l("annotation",{encoding:"application/x-tex"},"P")])])]),n(" ，定义数据流分析中， "),l("strong",null,"状态转移方程（State Transfer Function）"),n(" 为映射 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"f"),l("mrow",null,[l("mi",null,"D"),l("mo",null,"→"),l("mi",null,"D")])])]),l("annotation",{encoding:"application/x-tex"},"f_{D\\to D}")])])]),n(" （ "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"D")]),l("annotation",{encoding:"application/x-tex"},"D")])])]),n(" 是P的定义域，见定义3.5），考虑语句 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"s")]),l("annotation",{encoding:"application/x-tex"},"s")])])]),n(" ，关于语句 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"s")]),l("annotation",{encoding:"application/x-tex"},"s")])])]),n(" 的状态转移方程记为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"f"),l("mi",null,"s")])]),l("annotation",{encoding:"application/x-tex"},"f_s")])])]),n(" 。")])],-1),l("blockquote",null,[l("p",null,"这里，定义3.7的状态转移方程和定义1.8中的转移函数都称为Transfer Function，其本质上是一样的，只不过应用场景不一样，原相和相的集合不一样而已。但是这两种Transfer Function本质上都是抽象和语句语意的表征。")],-1),l("div",{class:"definition"},[l("p",{class:"title"},"定义3.8"),l("p",null,[n("定义顺控制流方向的数据流分析为 "),l("strong",null,"正向分析（Forward Analysis）"),n(" ，正向分析中， "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"f"),l("mi",null,"s")])]),l("annotation",{encoding:"application/x-tex"},"f_s")])])]),n(" 满足 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"s"),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("msub",null,[l("mi",null,"f"),l("mi",null,"s")]),l("mo",{stretchy:"false"},"("),l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"s"),l("mo",{stretchy:"false"},"]"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"OUT[s] = f_s(IN[s])")])])]),n(" ；定义逆控制流方向的数据流分析为 "),l("strong",null,"逆向分析（Backward Analysis）"),n(" ，逆向分析中， "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"f"),l("mi",null,"s")])]),l("annotation",{encoding:"application/x-tex"},"f_s")])])]),n(" 满足 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"s"),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("msub",null,[l("mi",null,"f"),l("mi",null,"s")]),l("mo",{stretchy:"false"},"("),l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"s"),l("mo",{stretchy:"false"},"]"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"IN[s] = f_s(OUT[s])")])])]),n(" 。")])],-1),l("p",null,"有了正向分析和逆向分析的定义之后，我们可以定义控制流中的约束记号。",-1),l("div",{class:"definition"},[l("p",{class:"title"},"定义3.9"),l("p",null,[n("考虑基块（见定义2.2） "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"B"),l("mo",null,"="),l("mo",{stretchy:"false"},"{"),l("msub",null,[l("mi",null,"s"),l("mn",null,"1")]),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"s"),l("mn",null,"2")]),l("mo",{separator:"true"},","),l("mi",{mathvariant:"normal"},"."),l("mi",{mathvariant:"normal"},"."),l("mi",{mathvariant:"normal"},"."),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"s"),l("mi",null,"n")]),l("mo",{stretchy:"false"},"}")]),l("annotation",{encoding:"application/x-tex"},"B = \\{s_1, s_2, ..., s_n\\}")])])]),n(" ，定义 "),l("strong",null,"基块B的输入状态"),n(" 为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("msub",null,[l("mi",null,"s"),l("mn",null,"1")]),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"IN[B] = IN[s_1]")])])]),n(" ， "),l("strong",null,"基块B的输出状态"),n(" 为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("msub",null,[l("mi",null,"s"),l("mi",null,"n")]),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"OUT[B] = OUT[s_n]")])])]),n(" 。")])],-1),l("blockquote",null,[l("p",null,"这里表示基块的集合为有序集，在定义2.2中已经指出，为防读者忘记而产生疑惑，这里提醒一下。")],-1),l("div",{class:"theorem"},[l("p",{class:"title"},"定理3.3"),l("p",null,[n("考虑基块 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"B"),l("mo",null,"="),l("mo",{stretchy:"false"},"{"),l("msub",null,[l("mi",null,"s"),l("mn",null,"1")]),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"s"),l("mn",null,"2")]),l("mo",{separator:"true"},","),l("mi",{mathvariant:"normal"},"."),l("mi",{mathvariant:"normal"},"."),l("mi",{mathvariant:"normal"},"."),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"s"),l("mi",null,"n")]),l("mo",{stretchy:"false"},"}")]),l("annotation",{encoding:"application/x-tex"},"B = \\{s_1, s_2, ..., s_n\\}")])])]),n(" ，则有")]),l("p",null,[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[l("semantics",null,[l("mrow",null,[l("mi",{mathvariant:"normal"},"∀"),l("mi",null,"i"),l("mo",null,"="),l("mn",null,"1"),l("mo",{separator:"true"},","),l("mn",null,"2"),l("mo",{separator:"true"},","),l("mi",{mathvariant:"normal"},"."),l("mi",{mathvariant:"normal"},"."),l("mi",{mathvariant:"normal"},"."),l("mo",{separator:"true"},","),l("mi",null,"n"),l("mo",null,"−"),l("mn",null,"1"),l("mo",{separator:"true"},","),l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("msub",null,[l("mi",null,"s"),l("mrow",null,[l("mi",null,"i"),l("mo",null,"+"),l("mn",null,"1")])]),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")]),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"\\forall i = 1, 2, ..., n - 1, IN[s_{i + 1}] = OUT[s_i] ")])])])])],-1),l("blockquote",null,[l("p",null,"定理3.3描述的是基块内部的数据流。")],-1),l("div",{class:"definition"},[l("p",{class:"title"},"定义3.10"),l("p",null,[n("考虑基块 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"B"),l("mo",null,"="),l("mo",{stretchy:"false"},"{"),l("msub",null,[l("mi",null,"s"),l("mn",null,"1")]),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"s"),l("mn",null,"2")]),l("mo",{separator:"true"},","),l("mi",{mathvariant:"normal"},"."),l("mi",{mathvariant:"normal"},"."),l("mi",{mathvariant:"normal"},"."),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"s"),l("mi",null,"n")]),l("mo",{stretchy:"false"},"}")]),l("annotation",{encoding:"application/x-tex"},"B = \\{s_1, s_2, ..., s_n\\}")])])]),n(" ， "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"s"),l("mi",null,"i")])]),l("annotation",{encoding:"application/x-tex"},"s_i")])])]),n(" 的状态转移方程为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"f"),l("msub",null,[l("mi",null,"s"),l("mi",null,"i")])])]),l("annotation",{encoding:"application/x-tex"},"f_{s_i}")])])]),n(" 。")]),l("p",null,[n("在正向分析中，定义 "),l("strong",null,"基块B的状态转移方程"),n(" 为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"f"),l("mi",null,"B")]),l("mo",null,"="),l("msub",null,[l("mi",null,"f"),l("msub",null,[l("mi",null,"s"),l("mi",null,"n")])]),l("mo",null,"∘"),l("mi",{mathvariant:"normal"},"."),l("mi",{mathvariant:"normal"},"."),l("mi",{mathvariant:"normal"},"."),l("mo",null,"∘"),l("msub",null,[l("mi",null,"f"),l("msub",null,[l("mi",null,"s"),l("mn",null,"2")])]),l("mo",null,"∘"),l("msub",null,[l("mi",null,"f"),l("msub",null,[l("mi",null,"s"),l("mn",null,"1")])])]),l("annotation",{encoding:"application/x-tex"},"f_B = f_{s_n}\\circ ...\\circ f_{s_2}\\circ f_{s_1}")])])]),n(" ，满足")]),l("p",null,[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("msub",null,[l("mi",null,"f"),l("mi",null,"B")]),l("mo",{stretchy:"false"},"("),l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"OUT[B] = f_B(IN[B]) ")])])])]),l("p",null,[n("其中， "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("msub",null,[l("mo",null,"⋀"),l("mrow",null,[l("mi",null,"P"),l("mo",null,"∈"),l("mi",null,"p"),l("mi",null,"r"),l("mi",null,"e"),l("mo",{stretchy:"false"},"("),l("mi",null,"B"),l("mo",{stretchy:"false"},")")])]),l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"P"),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"IN[B] = \\bigwedge_{P \\in pre(B)} OUT[P]")])])]),n(" ；")]),l("p",null,[n("在逆向分析中，定义 "),l("strong",null,"基块B的状态转移方程"),n(" 为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"f"),l("mi",null,"B")]),l("mo",null,"="),l("msub",null,[l("mi",null,"f"),l("msub",null,[l("mi",null,"s"),l("mn",null,"1")])]),l("mo",null,"∘"),l("mi",{mathvariant:"normal"},"."),l("mi",{mathvariant:"normal"},"."),l("mi",{mathvariant:"normal"},"."),l("mo",null,"∘"),l("msub",null,[l("mi",null,"f"),l("msub",null,[l("mi",null,"s"),l("mrow",null,[l("mi",null,"n"),l("mo",null,"−"),l("mn",null,"1")])])]),l("mo",null,"∘"),l("msub",null,[l("mi",null,"f"),l("msub",null,[l("mi",null,"s"),l("mi",null,"n")])])]),l("annotation",{encoding:"application/x-tex"},"f_B = f_{s_1}\\circ ...\\circ f_{s_{n - 1}}\\circ f_{s_n}")])])]),n(" ，满足")]),l("p",null,[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[l("semantics",null,[l("mrow",null,[l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("msub",null,[l("mi",null,"f"),l("mi",null,"B")]),l("mo",{stretchy:"false"},"("),l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"IN[B] = f_B(OUT[B]) ")])])])]),l("p",null,[n("其中， "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("msub",null,[l("mo",null,"⋀"),l("mrow",null,[l("mi",null,"S"),l("mo",null,"∈"),l("mi",null,"s"),l("mi",null,"u"),l("mi",null,"c"),l("mo",{stretchy:"false"},"("),l("mi",null,"B"),l("mo",{stretchy:"false"},")")])]),l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"S"),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"OUT[B] = \\bigwedge_{S \\in suc(B)} IN[S]")])])]),n(" 。")])],-1),l("h2",{id:"_3-2-定义可达性分析",tabindex:"-1"},[n("3.2 定义可达性分析 "),l("a",{class:"header-anchor",href:"#_3-2-定义可达性分析","aria-label":'Permalink to "3.2 定义可达性分析"'},"​")],-1),l("h3",{id:"_3-2-1-问题简化",tabindex:"-1"},[n("3.2.1 问题简化 "),l("a",{class:"header-anchor",href:"#_3-2-1-问题简化","aria-label":'Permalink to "3.2.1 问题简化"'},"​")],-1),l("p",null,"在下面的讨论当中，我们暂时不考虑以下问题：",-1),l("blockquote",null,[l("p",null,"待到后期掌握了更多的方法之后，我们可以将下面的情况也纳入讨论。")],-1),l("ul",null,[l("li",null,[l("p",null,"方法调用（Method Calls）"),l("ul",null,[l("li",null,[l("p",null,"我们只考虑过程内部（Intra-Procedural）的CFG；")]),l("li",null,[l("p",null,"跨过程分析（Inter-Procedural Analysis）将在之后的章节中展开。")])])]),l("li",null,[l("p",null,"别名（Aliases）"),l("ul",null,[l("li",null,[l("p",null,"在我们之后的分析中，每个变量都有唯一的一个名字，没有别名；")]),l("li",null,[l("p",null,"关于别名的分析将在指针分析（Pointer Analysis）相关的章节中展开。")])])])],-1),l("h3",{id:"_3-2-2-问题描述",tabindex:"-1"},[n("3.2.2 问题描述 "),l("a",{class:"header-anchor",href:"#_3-2-2-问题描述","aria-label":'Permalink to "3.2.2 问题描述"'},"​")],-1),l("div",{class:"definition"},[l("p",{class:"title"},"定义3.11"),l("p",null,[n("程序中变量 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"v")]),l("annotation",{encoding:"application/x-tex"},"v")])])]),n(" 的一个 "),l("strong",null,"定义（Definition）"),n(" 是指一条给 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"v")]),l("annotation",{encoding:"application/x-tex"},"v")])])]),n(" 赋值的语句。")])],-1),l("div",{class:"definition"},[l("p",{class:"title"},"定义3.12"),l("p",null,[n("我们称在程序点 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"p")]),l("annotation",{encoding:"application/x-tex"},"p")])])]),n(" 处的一个定义 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"d")]),l("annotation",{encoding:"application/x-tex"},"d")])])]),n(),l("strong",null,"到达（Reach）"),n(" 了程序点 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"q")]),l("annotation",{encoding:"application/x-tex"},"q")])])]),n(" ，如果存在一条从 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"p")]),l("annotation",{encoding:"application/x-tex"},"p")])])]),n(" 到 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"q")]),l("annotation",{encoding:"application/x-tex"},"q")])])]),n(" 的“路径”（控制流），在这条路径上，定义 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"d")]),l("annotation",{encoding:"application/x-tex"},"d")])])]),n(" 未被 "),l("strong",null,"覆盖（Kill）"),n(" 。称分析每个程序点处能够到达的定义的过程为 "),l("strong",null,"定义可达性分析（Reaching Definition Analysis）"),n(" 。")])],-1),l("p",{style:{"text-align":"center"}},[l("img",{src:d,alt:"rd",style:{zoom:"30%"}})],-1),l("p",null,[n("从上面的定义中我们可以看出，“定义可达性”其实描述了一个定义可能的 "),l("strong",null,"最长的"),n(" 生存期（Lifetime），因为如果存在只要一条路径，我们就认为可达，这是一个可能性分析（May Analysis，见定义3.2），采用的是过近似（Over-Approximation）的原则。")],-1),l("p",null,[n("定义可达性分析可以应用于检测程序中可能存在的未被定义的变量。比如说，我们在 DFG 的入口处为每个变量 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"v")]),l("annotation",{encoding:"application/x-tex"},"v")])])]),n(" 赋予一个伪定义（Dummy Definition），如果程序中存在某个使用变量 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"v")]),l("annotation",{encoding:"application/x-tex"},"v")])])]),n(" 的程序点 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"p")]),l("annotation",{encoding:"application/x-tex"},"p")])])]),n(" ，且 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"v")]),l("annotation",{encoding:"application/x-tex"},"v")])])]),n(" 的伪定义能够到达程序点 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"p")]),l("annotation",{encoding:"application/x-tex"},"p")])])]),n(" ，那么我们就可以分析出变量 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"v")]),l("annotation",{encoding:"application/x-tex"},"v")])])]),n(" 可能在定义之前被使用，也就是可能程序存在变量未定义的错误。")],-1),l("p",null,"这里为什么是可能存在，不是一定存在呢？原因在于我们进行定义可达性分析的时候采用的是可能性分析，只要有任意一条控制流能携带这个定义流到任何地方，我们都认为这个定义可达。在DFG中，虽然存在着多条控制流，但是，实际程序执行的时候，只有唯一的一条控制流会被真实的执行，而这条控制流并不一定刚好是我们用于得到定义可达结论的那一条。",-1),l("h3",{id:"_3-2-3-问题分析",tabindex:"-1"},[n("3.2.3 问题分析 "),l("a",{class:"header-anchor",href:"#_3-2-3-问题分析","aria-label":'Permalink to "3.2.3 问题分析"'},"​")],-1),l("h4",{id:"数据抽象",tabindex:"-1"},[n("数据抽象 "),l("a",{class:"header-anchor",href:"#数据抽象","aria-label":'Permalink to "数据抽象"'},"​")],-1),l("p",null,"这个小节，我们会应用我们之前学习的静态分析以及数据流分析的基本思路，来作定义可达性的分析。",-1),l("p",null,"首先，我们需要定义程序的抽象数据状态（见定义3.3，也就是确定数据流值的形式），在这个问题中，我们关心的数据流值是每个变量的定义，那么，程序的抽象数据状态可以用定义的集合来表示。",-1),l("p",null,[n("我们假设程序 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"P")]),l("annotation",{encoding:"application/x-tex"},"P")])])]),n(" 中所有的定义为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"D"),l("mo",null,"="),l("mo",{stretchy:"false"},"{"),l("msub",null,[l("mi",null,"d"),l("mn",null,"1")]),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"d"),l("mn",null,"2")]),l("mo",{separator:"true"},","),l("mi",{mathvariant:"normal"},"."),l("mi",{mathvariant:"normal"},"."),l("mi",{mathvariant:"normal"},"."),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"d"),l("mi",null,"n")]),l("mo",{stretchy:"false"},"}")]),l("annotation",{encoding:"application/x-tex"},"D = \\{d_1, d_2, ..., d_n\\}")])])]),n(" （在定义可达性问题下， "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"D")]),l("annotation",{encoding:"application/x-tex"},"D")])])]),n(" 的幂集（Power Set）就是程序 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"P")]),l("annotation",{encoding:"application/x-tex"},"P")])])]),n(" 的定义域 Domain ，见定义3.5），于是，我们可以用 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"D")]),l("annotation",{encoding:"application/x-tex"},"D")])])]),n(" 的子集（即定义域中的元素）来表示每个程序点处，能够到达该点的定义的集合，即该程序点处的数据流值。其实也就是确定 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"f"),l("mrow",null,[l("mi",null,"P"),l("mi",null,"P"),l("mo",null,"→"),l("mi",null,"D")])])]),l("annotation",{encoding:"application/x-tex"},"f_{PP \\to D}")])])]),n(" （见定理3.1），为每一个程序点关联一个数据流值（见结论3.1）。")],-1),l("p",null,[n("在具体的实现过程中，因为全集 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"D")]),l("annotation",{encoding:"application/x-tex"},"D")])])]),n(" 是固定的，且我们记 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",{mathvariant:"normal"},"∣"),l("mi",null,"D"),l("mi",{mathvariant:"normal"},"∣"),l("mo",null,"="),l("mi",null,"n")]),l("annotation",{encoding:"application/x-tex"},"|D| = n")])])]),n(" ，所以我们可以采用 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"n")]),l("annotation",{encoding:"application/x-tex"},"n")])])]),n(" 位的位向量（Bit Vector）来表示 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"D")]),l("annotation",{encoding:"application/x-tex"},"D")])])]),n(" 的所有子集，也就是我们所有可能的抽象数据状态。其中位向量从左往右的第 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"i")]),l("annotation",{encoding:"application/x-tex"},"i")])])]),n(" 位表示定义 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"d"),l("mi",null,"i")])]),l("annotation",{encoding:"application/x-tex"},"d_i")])])]),n(" 是否可达，具体地，第 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"i")]),l("annotation",{encoding:"application/x-tex"},"i")])])]),n(" 位为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mn",null,"0")]),l("annotation",{encoding:"application/x-tex"},"0")])])]),n(" 表示 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"d"),l("mi",null,"i")])]),l("annotation",{encoding:"application/x-tex"},"d_i")])])]),n(" 不可达，为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mn",null,"1")]),l("annotation",{encoding:"application/x-tex"},"1")])])]),n(" 则可达。")],-1),l("blockquote",null,[l("p",null,[n("其实用位向量表示全集确定的集合是很常见的，因为全集确定之后，假设全集的势为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"n")]),l("annotation",{encoding:"application/x-tex"},"n")])])]),n(" ，则所有可能集合（一定是全集的子集）一共有 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msup",null,[l("mn",null,"2"),l("mi",null,"n")])]),l("annotation",{encoding:"application/x-tex"},"2^n")])])]),n(" 个，而 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"n")]),l("annotation",{encoding:"application/x-tex"},"n")])])]),n(" 位的位向量也恰好有 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msup",null,[l("mn",null,"2"),l("mi",null,"n")])]),l("annotation",{encoding:"application/x-tex"},"2^n")])])]),n(" 个不同的可能，所以我们可以根据每个元素在或者不在子集中为对应法则，建立起所有子集与位向量之间的一个双射。")])],-1),l("p",null,"除了位向量以外，集合也有很多别的表示方式，比如哈希表、红黑树等等，这里只是介绍一下位向量的表示方法，因为这在数据流分析中是常用的。不过，为了更具一般性，我们接下来的分析只基于集合的抽象，而不基于其具体实现。",-1),l("h4",{id:"约束分析",tabindex:"-1"},[n("约束分析 "),l("a",{class:"header-anchor",href:"#约束分析","aria-label":'Permalink to "约束分析"'},"​")],-1),l("p",null,"完成数据抽象之后，我们就可以进行估计了，这里采用的安全近似方式是过近似，分析的顺序是正向分析。",-1),l("p",null,"估计的时候需要考虑两种约束：语意约束和控制流约束（见3.1.2节和结论3.2）。",-1),l("p",null,[n("考虑 "),l("strong",null,"语意的约束"),n(" ，语句 "),l("code",null,"D: v = x op y"),n(" 生成了关于变量 "),l("code",null,"v"),n(" 的一个新定义 "),l("code",null,"D"),n(" ，并且覆盖了程序中其他地方对于变量 "),l("code",null,"v"),n(" 的定义，不过并不会影响后续其他的定义再来覆盖这里的定义。赋值语句只是定义的一种形式而已，定义也可以有别的形式，比如说引用参数。")],-1),l("p",null,[n("我们以基块为粒度考虑问题，一个基块中可能有许多具有定义功能的语句，基块B所产生的新的定义记为集合 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"g"),l("mi",null,"e"),l("msub",null,[l("mi",null,"n"),l("mi",null,"B")])]),l("annotation",{encoding:"application/x-tex"},"gen_B")])])]),n(" ，这些定义语句会覆盖其他地方的别的对于相关变量的定义，基块B所覆盖掉的定义记为集合 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"k"),l("mi",null,"i"),l("mi",null,"l"),l("msub",null,[l("mi",null,"l"),l("mi",null,"B")])]),l("annotation",{encoding:"application/x-tex"},"kill_B")])])]),n(" 。例如：")],-1),l("p",{style:{"text-align":"center"}},[l("img",{src:f,alt:"rd-eg",style:{zoom:"40%"}})],-1),l("p",null,[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[l("semantics",null,[l("mrow",null,[l("mi",null,"g"),l("mi",null,"e"),l("msub",null,[l("mi",null,"n"),l("msub",null,[l("mi",null,"B"),l("mn",null,"1")])]),l("mo",null,"="),l("mo",{stretchy:"false"},"{"),l("msub",null,[l("mi",null,"d"),l("mn",null,"1")]),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"d"),l("mn",null,"2")]),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"d"),l("mn",null,"3")]),l("mo",{stretchy:"false"},"}"),l("mo",{separator:"true"},","),l("mi",null,"k"),l("mi",null,"i"),l("mi",null,"l"),l("msub",null,[l("mi",null,"l"),l("msub",null,[l("mi",null,"B"),l("mn",null,"1")])]),l("mo",null,"="),l("mo",{stretchy:"false"},"{"),l("msub",null,[l("mi",null,"d"),l("mn",null,"4")]),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"d"),l("mn",null,"5")]),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"d"),l("mn",null,"6")]),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"d"),l("mn",null,"7")]),l("mo",{stretchy:"false"},"}")]),l("annotation",{encoding:"application/x-tex"},"gen_{B_1} = \\{d_1, d_2, d_3\\}, kill_{B_1} = \\{d_4, d_5, d_6, d_7\\} ")])])])],-1),l("p",null,[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[l("semantics",null,[l("mrow",null,[l("mi",null,"g"),l("mi",null,"e"),l("msub",null,[l("mi",null,"n"),l("msub",null,[l("mi",null,"B"),l("mn",null,"2")])]),l("mo",null,"="),l("mo",{stretchy:"false"},"{"),l("msub",null,[l("mi",null,"d"),l("mn",null,"4")]),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"d"),l("mn",null,"5")]),l("mo",{stretchy:"false"},"}"),l("mo",{separator:"true"},","),l("mi",null,"k"),l("mi",null,"i"),l("mi",null,"l"),l("msub",null,[l("mi",null,"l"),l("msub",null,[l("mi",null,"B"),l("mn",null,"2")])]),l("mo",null,"="),l("mo",{stretchy:"false"},"{"),l("msub",null,[l("mi",null,"d"),l("mn",null,"1")]),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"d"),l("mn",null,"2")]),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"d"),l("mn",null,"7")]),l("mo",{stretchy:"false"},"}")]),l("annotation",{encoding:"application/x-tex"},"gen_{B_2} = \\{d_4, d_5\\}, kill_{B_2} = \\{d_1, d_2, d_7\\} ")])])])],-1),l("p",null,[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[l("semantics",null,[l("mrow",null,[l("mi",null,"g"),l("mi",null,"e"),l("msub",null,[l("mi",null,"n"),l("msub",null,[l("mi",null,"B"),l("mn",null,"3")])]),l("mo",null,"="),l("mo",{stretchy:"false"},"{"),l("msub",null,[l("mi",null,"d"),l("mn",null,"6")]),l("mo",{stretchy:"false"},"}"),l("mo",{separator:"true"},","),l("mi",null,"k"),l("mi",null,"i"),l("mi",null,"l"),l("msub",null,[l("mi",null,"l"),l("msub",null,[l("mi",null,"B"),l("mn",null,"3")])]),l("mo",null,"="),l("mo",{stretchy:"false"},"{"),l("msub",null,[l("mi",null,"d"),l("mn",null,"3")]),l("mo",{stretchy:"false"},"}")]),l("annotation",{encoding:"application/x-tex"},"gen_{B_3} = \\{d_6\\}, kill_{B_3} = \\{d_3\\} ")])])])],-1),l("p",null,[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[l("semantics",null,[l("mrow",null,[l("mi",null,"g"),l("mi",null,"e"),l("msub",null,[l("mi",null,"n"),l("msub",null,[l("mi",null,"B"),l("mn",null,"4")])]),l("mo",null,"="),l("mo",{stretchy:"false"},"{"),l("msub",null,[l("mi",null,"d"),l("mn",null,"7")]),l("mo",{stretchy:"false"},"}"),l("mo",{separator:"true"},","),l("mi",null,"k"),l("mi",null,"i"),l("mi",null,"l"),l("msub",null,[l("mi",null,"l"),l("msub",null,[l("mi",null,"B"),l("mn",null,"4")])]),l("mo",null,"="),l("mo",{stretchy:"false"},"{"),l("msub",null,[l("mi",null,"d"),l("mn",null,"1")]),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"d"),l("mn",null,"4")]),l("mo",{stretchy:"false"},"}")]),l("annotation",{encoding:"application/x-tex"},"gen_{B_4} = \\{d_7\\}, kill_{B_4} = \\{d_1, d_4\\} ")])])])],-1),l("p",null,[n("我们不难发现，对于一个静态的程序来说， "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"k"),l("mi",null,"i"),l("mi",null,"l"),l("msub",null,[l("mi",null,"l"),l("mi",null,"B")])]),l("annotation",{encoding:"application/x-tex"},"kill_B")])])]),n(" 和 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"g"),l("mi",null,"e"),l("msub",null,[l("mi",null,"n"),l("mi",null,"B")])]),l("annotation",{encoding:"application/x-tex"},"gen_B")])])]),n(" 都是固定不变的。在此基础上，我们可以得到一个基块 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"B")]),l("annotation",{encoding:"application/x-tex"},"B")])])]),n(" 的转移方程为：")],-1),l("p",null,[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("mi",null,"g"),l("mi",null,"e"),l("msub",null,[l("mi",null,"n"),l("mi",null,"B")]),l("mo",null,"∪"),l("mo",{stretchy:"false"},"("),l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",null,"−"),l("mi",null,"k"),l("mi",null,"i"),l("mi",null,"l"),l("msub",null,[l("mi",null,"l"),l("mi",null,"B")]),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"OUT[B] = gen_B \\cup (IN[B] - kill_B) ")])])])],-1),l("p",null,[n("考虑 "),l("strong",null,"控制流的约束"),n(" ，因为我们采用的是过近似方式，因此一个定义达到某个程序点，只需要有至少一条路径能够到达这个点即可。因此，我们定义交汇操作符（Meet Operator，见定义3.6）为集合的并操作，即 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",null,"∧"),l("mo",null,"="),l("mo",null,"∪")]),l("annotation",{encoding:"application/x-tex"},"\\wedge = \\cup")])])]),n(" ，则控制流约束为：")],-1),l("p",null,[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[l("semantics",null,[l("mrow",null,[l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("munder",null,[l("mo",null,"⋃"),l("mrow",null,[l("mi",null,"P"),l("mo",null,"∈"),l("mi",null,"p"),l("mi",null,"r"),l("mi",null,"e"),l("mo",{stretchy:"false"},"("),l("mi",null,"B"),l("mo",{stretchy:"false"},")")])]),l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"P"),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"IN[B] = \\bigcup_{P \\in pre(B)} OUT[P] ")])])])],-1),l("h3",{id:"_3-2-4-问题求解",tabindex:"-1"},[n("3.2.4 问题求解 "),l("a",{class:"header-anchor",href:"#_3-2-4-问题求解","aria-label":'Permalink to "3.2.4 问题求解"'},"​")],-1),l("h4",{id:"算法设计",tabindex:"-1"},[n("算法设计 "),l("a",{class:"header-anchor",href:"#算法设计","aria-label":'Permalink to "算法设计"'},"​")],-1),l("p",null,"根据上面的分析，我们可以设计定义可达性问题的求解算法。",-1),l("div",{class:"algorithm"},[l("p",{class:"title"},"算法3.1 定义可达性分析算法"),l("iframe",{src:"/posts/StaticAnalytics/03-dfa-ap/reaching-definition.html",frameborder:"no",border:"0",marginwidth:"0",width:"100%",height:"315px",marginheight:"0",scrolling:"auto",style:{"box-shadow":"none"}})],-1),l("blockquote",null,[l("p",null,"上述算法的复杂度和集合的实现方式以及遍历顺序的选择有关，在这里我们不讨论具体的算法实现，而聚焦于算法的设计。"),l("p",null,[n("在下一章里面，我们会探讨到，迭代算法总的迭代次数最多为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mo",{stretchy:"false"},"("),l("mi",null,"k"),l("mo",null,"⋅"),l("mi",null,"h"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"O(k\\cdot h)")])])]),n(" ，其中 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"h")]),l("annotation",{encoding:"application/x-tex"},"h")])])]),n(" 为值集的大小（也是定义域形成的格的高度），这里就是整个程序中所有的定义的个数， "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"k")]),l("annotation",{encoding:"application/x-tex"},"k")])])]),n(" 为CFG中结点的个数。")])],-1),l("p",null,"我们可以通过下面的例子来直观感受一下上面的算法。",-1),l("figure",null,[l("img",{src:k,alt:"rda-eg",loading:"lazy",decoding:"async"})],-1),l("h4",{id:"算法分析",tabindex:"-1"},[n("算法分析 "),l("a",{class:"header-anchor",href:"#算法分析","aria-label":'Permalink to "算法分析"'},"​")],-1),l("p",null,"这里算法最开始初始化的时候 Entry 和除了 Entry 以外的其他基块是分开初始化的，其实合起来也没关系。这样写是因为算法3.1是一个很经典的静态分析中迭代算法的模版，有的时候 Entry 和 Entry 以外的基块初始化的内容是不一样的。",-1),l("div",{class:"theorem"},[l("p",{class:"title"},"定理3.4"),l("p",null,"算法3.1能够正常终止。")],-1),l("p",null,[n("这个算法的 "),l("code",null,"repeat-until"),n(" 迭代终止的条件其实是有些可疑的，终止条件是当某次迭代的过程中，所有的 BB 的输出状态都不变。")],-1),l("p",null,[n("我们看一下算法中唯一能够改变输出状态的语句 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("mi",null,"g"),l("mi",null,"e"),l("msub",null,[l("mi",null,"n"),l("mi",null,"B")]),l("mo",null,"∪"),l("mo",{stretchy:"false"},"("),l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",null,"−"),l("mi",null,"k"),l("mi",null,"i"),l("mi",null,"l"),l("msub",null,[l("mi",null,"l"),l("mi",null,"B")]),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"OUT[B] = gen_B\\cup (IN[B] - kill_B)")])])]),n(" ，我们不难发现：")],-1),l("ul",null,[l("li",null,[l("p",null,[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"g"),l("mi",null,"e"),l("msub",null,[l("mi",null,"n"),l("mi",null,"B")])]),l("annotation",{encoding:"application/x-tex"},"gen_B")])])]),n(" 和 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"k"),l("mi",null,"i"),l("mi",null,"l"),l("msub",null,[l("mi",null,"l"),l("mi",null,"B")])]),l("annotation",{encoding:"application/x-tex"},"kill_B")])])]),n(" 是不变的，因为程序P本身是不改变的（至少我们现在的分析场景下是这样的）；")])]),l("li",null,[l("p",null,[n("当更多的定义从控制流流入 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"IN[B]")])])]),n(" （也就是当别处的定义到达B的时候），这里流入的更多的定义")]),l("ul",null,[l("li",null,[l("p",null,[n("要么被 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"k"),l("mi",null,"i"),l("mi",null,"l"),l("msub",null,[l("mi",null,"l"),l("mi",null,"B")])]),l("annotation",{encoding:"application/x-tex"},"kill_B")])])]),n(" 给覆盖了，")])]),l("li",null,[l("p",null,[n("要么幸存了下来，流入了 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"OUT[B]")])])]),n(" ，记为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"s"),l("mi",null,"u"),l("mi",null,"r"),l("mi",null,"v"),l("mi",null,"i"),l("mi",null,"v"),l("mi",null,"o"),l("msub",null,[l("mi",null,"r"),l("mi",null,"B")]),l("mo",null,"="),l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",null,"−"),l("mi",null,"k"),l("mi",null,"i"),l("mi",null,"l"),l("msub",null,[l("mi",null,"l"),l("mi",null,"B")])]),l("annotation",{encoding:"application/x-tex"},"survivor_B = IN[B] - kill_B")])])]),n(" 。")])])])]),l("li",null,[l("p",null,[n("也就是说，当一个定义d被加入 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"OUT[B]")])])]),n(" 集合的时候，无论是通过 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"g"),l("mi",null,"e"),l("msub",null,[l("mi",null,"n"),l("mi",null,"B")])]),l("annotation",{encoding:"application/x-tex"},"gen_B")])])]),n(" 还是 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"s"),l("mi",null,"u"),l("mi",null,"r"),l("mi",null,"v"),l("mi",null,"i"),l("mi",null,"v"),l("mi",null,"o"),l("msub",null,[l("mi",null,"r"),l("mi",null,"B")])]),l("annotation",{encoding:"application/x-tex"},"survivor_B")])])]),n(" ，它会永远的留在 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"OUT[B]")])])]),n(" 中；")]),l("ul",null,[l("li",null,[n("因为这一轮的幸存者在下一轮依然是幸存者（ "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"k"),l("mi",null,"i"),l("mi",null,"l"),l("msub",null,[l("mi",null,"l"),l("mi",null,"B")])]),l("annotation",{encoding:"application/x-tex"},"kill_B")])])]),n(" 是固定的）。")])])]),l("li",null,[l("p",null,[n("因此，集合 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"OUT[B]")])])]),n(" 是不会收缩的，也就是说 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"OUT[B]")])])]),n(" 要么变大，要么不变。")])]),l("li",null,[l("p",null,[n("而定义的总集合 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"D")]),l("annotation",{encoding:"application/x-tex"},"D")])])]),n(" 是固定的，而 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",null,"⊆"),l("mi",null,"D")]),l("annotation",{encoding:"application/x-tex"},"OUT[B] \\subseteq D")])])]),n(" ，因此最终一定会有一个所有的 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"OUT[B]")])])]),n(" 都不变的状态。")]),l("ul",null,[l("li",null,[n("最多的迭代次数为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",{mathvariant:"normal"},"∣"),l("mi",null,"D"),l("mi",{mathvariant:"normal"},"∣"),l("mo",null,"×"),l("mi",{mathvariant:"normal"},"∣"),l("mo",{stretchy:"false"},"{"),l("mi",null,"B"),l("mi",{mathvariant:"normal"},"∣"),l("mi",null,"B"),l("mtext",null," "),l("mi",null,"i"),l("mi",null,"s"),l("mtext",null," "),l("mi",null,"a"),l("mtext",null," "),l("mi",null,"b"),l("mi",null,"a"),l("mi",null,"s"),l("mi",null,"i"),l("mi",null,"c"),l("mtext",null," "),l("mi",null,"b"),l("mi",null,"l"),l("mi",null,"o"),l("mi",null,"c"),l("mi",null,"k"),l("mtext",null," "),l("mi",null,"o"),l("mi",null,"f"),l("mtext",null," "),l("mi",null,"P"),l("mo",{stretchy:"false"},"}"),l("mi",{mathvariant:"normal"},"∣")]),l("annotation",{encoding:"application/x-tex"},"|D| \\times |\\{B | B\\ is\\ a\\ basic\\ block\\ of\\ P\\}|")])])]),n(" ，因为最慢的时候就是每次迭代只有一个 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"OUT[B]")])])]),n(" 增加了一个元素。")])])])],-1),l("p",null,"到此为止，我们完成了定理3.4的一个非形式化的证明。",-1),l("blockquote",null,[l("p",null,[n("上面的分析过程不仅适用于定义可达性分析迭代算法，也适用于其他的关于数据流分析的迭代算法。其中，上面分析中的“定义”，更抽象的视角应该是定义3.3中的数据流值，也可以称为 "),l("strong",null,"因素（Facts）"),n(" 。")])],-1),l("p",null,[n("更具体的，当 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T")]),l("annotation",{encoding:"application/x-tex"},"OUT")])])]),n(" 不变的时候，由于 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("msub",null,[l("mo",null,"⋃"),l("mrow",null,[l("mi",null,"P"),l("mo",null,"∈"),l("mi",null,"p"),l("mi",null,"r"),l("mi",null,"e"),l("mo",{stretchy:"false"},"("),l("mi",null,"B"),l("mo",{stretchy:"false"},")")])]),l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"P"),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"IN[B] = \\bigcup_{P\\in pre(B)} OUT[P]")])])]),n(" ，"),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"I"),l("mi",null,"N")]),l("annotation",{encoding:"application/x-tex"},"IN")])])]),n(" 也就不变了，而 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"I"),l("mi",null,"N")]),l("annotation",{encoding:"application/x-tex"},"IN")])])]),n(" 不变的话，由于"),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("mi",null,"g"),l("mi",null,"e"),l("msub",null,[l("mi",null,"n"),l("mi",null,"B")]),l("mo",null,"∪"),l("mo",{stretchy:"false"},"("),l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",null,"−"),l("mi",null,"k"),l("mi",null,"i"),l("mi",null,"l"),l("msub",null,[l("mi",null,"l"),l("mi",null,"B")]),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"OUT[B] = gen_B\\cup (IN[B] - kill_B)")])])]),n(" ，则 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T")]),l("annotation",{encoding:"application/x-tex"},"OUT")])])]),n(" 也就不变了。此时，我们称这个迭代的算法到达了一个“不动点（Fixed Point）”，这也和算法的单调性（Monotonicity）有关。这些更理论化的严谨分析会包含在下一章的内容中。")],-1),l("h2",{id:"_3-3-活跃变量分析",tabindex:"-1"},[n("3.3 活跃变量分析 "),l("a",{class:"header-anchor",href:"#_3-3-活跃变量分析","aria-label":'Permalink to "3.3 活跃变量分析"'},"​")],-1),l("h3",{id:"_3-3-1-问题描述",tabindex:"-1"},[n("3.3.1 问题描述 "),l("a",{class:"header-anchor",href:"#_3-3-1-问题描述","aria-label":'Permalink to "3.3.1 问题描述"'},"​")],-1),l("div",{class:"definition"},[l("p",{class:"title"},"定义3.13"),l("p",null,[n("在程序点 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"p")]),l("annotation",{encoding:"application/x-tex"},"p")])])]),n(" 处，某个变量 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"v")]),l("annotation",{encoding:"application/x-tex"},"v")])])]),n(" 的变量值（Variable Value）可能在之后的某条控制流中被用到，我们就称变量 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"v")]),l("annotation",{encoding:"application/x-tex"},"v")])])]),n(" 是程序点 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"p")]),l("annotation",{encoding:"application/x-tex"},"p")])])]),n(" 处的 "),l("strong",null,"活变量（Live Variable）"),n(" ，否则，我们就称变量 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"v")]),l("annotation",{encoding:"application/x-tex"},"v")])])]),n(" 为程序点 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"p")]),l("annotation",{encoding:"application/x-tex"},"p")])])]),n(" 处的 "),l("strong",null,"死变量（Dead Variable）"),n(" 。分析在各个程序点处所有的变量是死是活的分析，称为 "),l("strong",null,"活跃变量分析（Live Variable Analysis）"),n(" 。")])],-1),l("div",{class:"theorem"},[l("p",{class:"title"},"定理3.5"),l("p",null,[n("程序点 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"p")]),l("annotation",{encoding:"application/x-tex"},"p")])])]),n(" 处的变量 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"v")]),l("annotation",{encoding:"application/x-tex"},"v")])])]),n(" 是活变量，当且仅当在 CFG 中存在某条从 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"p")]),l("annotation",{encoding:"application/x-tex"},"p")])])]),n(" 开始的路径，在这条路径上变量 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"v")]),l("annotation",{encoding:"application/x-tex"},"v")])])]),n(" 被使用了，并且在 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"v")]),l("annotation",{encoding:"application/x-tex"},"v")])])]),n(" 被使用之前， "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"v")]),l("annotation",{encoding:"application/x-tex"},"v")])])]),n(" 未被重定义。")])],-1),l("p",{style:{"text-align":"center"}},[l("img",{src:y,alt:"live-var",style:{zoom:"30%"}})],-1),l("p",null,[n("这个定义有些迷惑，注意，我们判断活跃变量的标准不是这个变量之后有没有可能用到，而是 "),l("strong",null,"这个变量当前所储存的值在之后有没有可能被用到"),n(" 。")],-1),l("p",null,"活跃变量分析可以应用在寄存器分配（Register Allocation）中，可以作为编译器优化的参考信息。比如说，如果在某个程序点处，所有的寄存器都被占满了，而我们又需要用一个新的寄存器，那么我们就要从已经占满的这些寄存器中选择一个去覆盖它的旧值，我们应该更青睐于去覆盖那些储存死变量的寄存器。",-1),l("h3",{id:"_3-3-2-问题分析",tabindex:"-1"},[n("3.3.2 问题分析 "),l("a",{class:"header-anchor",href:"#_3-3-2-问题分析","aria-label":'Permalink to "3.3.2 问题分析"'},"​")],-1),l("h4",{id:"数据抽象-1",tabindex:"-1"},[n("数据抽象 "),l("a",{class:"header-anchor",href:"#数据抽象-1","aria-label":'Permalink to "数据抽象"'},"​")],-1),l("p",null,"有了前面的基本概念和定义可达性分析的基础，下面的数据抽象就不难理解了。",-1),l("p",null,[n("在活跃变量分析问题中，我们关心的是有哪些活跃变量，所以可以用变量的集合作为数据流值，假设程序 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"P")]),l("annotation",{encoding:"application/x-tex"},"P")])])]),n(" 中的所有变量为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"V"),l("mo",null,"="),l("mo",{stretchy:"false"},"{"),l("msub",null,[l("mi",null,"v"),l("mn",null,"1")]),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"v"),l("mn",null,"2")]),l("mo",{separator:"true"},","),l("mi",{mathvariant:"normal"},"."),l("mi",{mathvariant:"normal"},"."),l("mi",{mathvariant:"normal"},"."),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"v"),l("mi",null,"n")]),l("mo",{stretchy:"false"},"}")]),l("annotation",{encoding:"application/x-tex"},"V = \\{v_1, v_2, ..., v_n\\}")])])]),n(" ，则数据分析的定义域为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"V")]),l("annotation",{encoding:"application/x-tex"},"V")])])]),n(" 的幂集，即 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"D"),l("mo",null,"="),l("msup",null,[l("mn",null,"2"),l("mi",null,"V")])]),l("annotation",{encoding:"application/x-tex"},"D = 2^{V}")])])]),n(" 。")],-1),l("p",null,[n("每个程序点处的抽象程序状态就是 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"V")]),l("annotation",{encoding:"application/x-tex"},"V")])])]),n(" 的一个子集，表示这个程序点处所有的活变量的集合，我们的活跃变量分析的任务就是确定每个程序点的抽象程序状态。")],-1),l("p",null,"和定义可达性分析同样的，因为全集确定，所以子集的实现可以用位向量，这里不再赘述。",-1),l("h4",{id:"约束分析-1",tabindex:"-1"},[n("约束分析 "),l("a",{class:"header-anchor",href:"#约束分析-1","aria-label":'Permalink to "约束分析"'},"​")],-1),l("p",null,"在某个程序点处的变量是否存活，判断标准是这个程序点之后，该变量的值是否还有被使用的可能。换句话来说，如果在某个程序点处，一个变量被使用了，那么在它之前的“一些”程序点上，该变量就是活的。这里的“一些”的标准是到某个变量的定义为止，因为我们判断活跃变量看的是变量的值，而不是变量本身。",-1),l("blockquote",null,[l("p",null,"用变量值判断活性的原因或许是在实际应用场景中，哪怕是同一个变量，其值改变了，也是要重新修改寄存器值的。")],-1),l("p",null,"因此，活跃变量分析适合用逆向分析（Backward Analysis，见定义3.8）的方式来进行。",-1),l("p",null,[n("从定理3.5中我们可以知道，只要存在一条路径使得 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"p")]),l("annotation",{encoding:"application/x-tex"},"p")])])]),n(" 处的变量 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"v")]),l("annotation",{encoding:"application/x-tex"},"v")])])]),n(" 的值被用到，那么就认为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"v")]),l("annotation",{encoding:"application/x-tex"},"v")])])]),n(" 在 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"p")]),l("annotation",{encoding:"application/x-tex"},"p")])])]),n(" 处是活的，因此，这里应该采用过近似的方式。")],-1),l("p",null,"确定了分析顺序和安全近似的策略，下面我们只要确定语意约束和控制流约束即可（见结论3.2）。",-1),l("p",null,[n("考虑 "),l("strong",null,"语意约束"),n(" ，在基块 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"B")]),l("annotation",{encoding:"application/x-tex"},"B")])])]),n(" 中，考虑 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"OUT[B]")])])]),n(" 如何被转化为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"IN[B]")])])]),n(" ，也就是 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"IN[B]")])])]),n(" 中存活的变量从何而来？")],-1),l("ul",null,[l("li",null,[l("p",null,[n("第一种是 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"OUT[B]")])])]),n(" 中已经存活，并且在"),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"B")]),l("annotation",{encoding:"application/x-tex"},"B")])])]),n("并没有重定义；")])]),l("li",null,[l("p",null,[n("第二种是在 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"B")]),l("annotation",{encoding:"application/x-tex"},"B")])])]),n(" 中被使用的在 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"B")]),l("annotation",{encoding:"application/x-tex"},"B")])])]),n(" 之前定义的变量（也就是说，如果 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"B")]),l("annotation",{encoding:"application/x-tex"},"B")])])]),n(" 自己先定义了一个变量，然后再使用这个变量，那么这个变量在 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"IN[B]")])])]),n(" 处还是死的）。")])])],-1),l("p",null,[n("举一个简单的例子，对于下面左边的DFG，我们假设 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("mo",{stretchy:"false"},"{"),l("mi",null,"v"),l("mo",{stretchy:"false"},"}")]),l("annotation",{encoding:"application/x-tex"},"OUT[B] = \\{v\\}")])])]),n(" ，考虑B中的语句的6种具有代表性的情况，则 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"IN[B]")])])]),n(" 是否包含 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"v")]),l("annotation",{encoding:"application/x-tex"},"v")])])]),n(" 的结果应当如右所示：")],-1),l("figure",null,[l("img",{src:b,alt:"lv-eg",loading:"lazy",decoding:"async"})],-1),l("p",null,[n("我们可以记在基块 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"B")]),l("annotation",{encoding:"application/x-tex"},"B")])])]),n(" 中被定义的变量集合为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"d"),l("mi",null,"e"),l("msub",null,[l("mi",null,"f"),l("mi",null,"B")])]),l("annotation",{encoding:"application/x-tex"},"def_B")])])]),n(" ，在基块 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"B")]),l("annotation",{encoding:"application/x-tex"},"B")])])]),n(" 中定义前使用的变量集合为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"u"),l("mi",null,"s"),l("msub",null,[l("mi",null,"e"),l("mi",null,"B")])]),l("annotation",{encoding:"application/x-tex"},"use_B")])])]),n(" 。")],-1),l("blockquote",null,[l("p",null,[n("被使用但未被定义也属于在定义前使用，也就是说上述的2、4、6都满足 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"v"),l("mo",null,"∈"),l("mi",null,"u"),l("mi",null,"s"),l("msub",null,[l("mi",null,"e"),l("mi",null,"B")])]),l("annotation",{encoding:"application/x-tex"},"v \\in use_B")])])]),n(" ，而在情况5中， "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"v"),l("mo",{mathvariant:"normal"},"∉"),l("mi",null,"u"),l("mi",null,"s"),l("msub",null,[l("mi",null,"e"),l("mi",null,"B")])]),l("annotation",{encoding:"application/x-tex"},"v\\notin use_B")])])]),n(" ）。")])],-1),l("p",null,"于是，我们可以得到语意约束下的状态转移方程为：",-1),l("p",null,[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[l("semantics",null,[l("mrow",null,[l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("mi",null,"u"),l("mi",null,"s"),l("msub",null,[l("mi",null,"e"),l("mi",null,"B")]),l("mo",null,"∪"),l("mo",{stretchy:"false"},"("),l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",null,"−"),l("mi",null,"d"),l("mi",null,"e"),l("msub",null,[l("mi",null,"f"),l("mi",null,"B")]),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"IN[B] = use_B \\cup (OUT[B] - def_B) ")])])])],-1),l("p",null,[n("考虑 "),l("strong",null,"控制流约束"),n(" ，由于我们采用过近似的方式，所以交汇操作符应当定义为并集，即 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",null,"∧"),l("mo",null,"="),l("mo",null,"∪")]),l("annotation",{encoding:"application/x-tex"},"\\wedge = \\cup")])])]),n(" ，又因为是逆向分析，因此控制流约束为：")],-1),l("p",null,[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("munder",null,[l("mo",null,"⋃"),l("mrow",null,[l("mi",null,"S"),l("mo",null,"∈"),l("mi",null,"s"),l("mi",null,"u"),l("mi",null,"c"),l("mo",{stretchy:"false"},"("),l("mi",null,"B"),l("mo",{stretchy:"false"},")")])]),l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"S"),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"OUT[B] = \\bigcup_{S \\in suc(B)} IN[S] ")])])])],-1),l("h3",{id:"_3-3-3-问题求解",tabindex:"-1"},[n("3.3.3 问题求解 "),l("a",{class:"header-anchor",href:"#_3-3-3-问题求解","aria-label":'Permalink to "3.3.3 问题求解"'},"​")],-1),l("h4",{id:"算法设计-1",tabindex:"-1"},[n("算法设计 "),l("a",{class:"header-anchor",href:"#算法设计-1","aria-label":'Permalink to "算法设计"'},"​")],-1),l("p",null,"通过上面的分析，我们可以设计活跃变量分析的算法如下。",-1),l("div",{class:"algorithm"},[l("p",{class:"title"},"算法3.2 活跃变量分析算法"),l("iframe",{src:"/posts/StaticAnalytics/03-dfa-ap/live-variables.html",frameborder:"no",border:"0",marginwidth:"0",width:"100%",height:"315px",marginheight:"0",scrolling:"auto",style:{"box-shadow":"none"}})],-1),l("blockquote",null,[l("p",null,"上述算法的复杂度和集合的实现方式以及遍历顺序的选择有关，在这里我们不讨论具体的算法实现，而聚焦于算法的设计。")],-1),l("p",null,"我们可以通过下面的例子来直观感受一下上面的算法。",-1),l("figure",null,[l("img",{src:B,alt:"lv-alg-eg",loading:"lazy",decoding:"async"})],-1),l("h4",{id:"算法分析-1",tabindex:"-1"},[n("算法分析 "),l("a",{class:"header-anchor",href:"#算法分析-1","aria-label":'Permalink to "算法分析"'},"​")],-1),l("div",{class:"theorem"},[l("p",{class:"title"},"定理3.5"),l("p",null,"算法3.2能够正常终止。")],-1),l("p",null,"算法3.2和算法3.1基本上是一致的，都是可能性分析（May Analysis）的迭代算法，不同的是",-1),l("ul",null,[l("li",null,[l("p",null,"分析顺序，3.1是顺序分析，3.2是逆序分析；")]),l("li",null,[l("p",null,"初始化的时候，3.1先初始化的是输出状态，而3.2先初始化的是输入状态，其实也是由分析顺序决定的。")])],-1),l("h2",{id:"_3-4-可用表达式分析",tabindex:"-1"},[n("3.4 可用表达式分析 "),l("a",{class:"header-anchor",href:"#_3-4-可用表达式分析","aria-label":'Permalink to "3.4 可用表达式分析"'},"​")],-1),l("h3",{id:"_3-4-1-问题描述",tabindex:"-1"},[n("3.4.1 问题描述 "),l("a",{class:"header-anchor",href:"#_3-4-1-问题描述","aria-label":'Permalink to "3.4.1 问题描述"'},"​")],-1),l("div",{class:"definition"},[l("p",{class:"title"},"定义3.14"),l("p",null,[n("我们称一个表达式（Expression）"),l("code",null,"x op y"),n("在程序点 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"p")]),l("annotation",{encoding:"application/x-tex"},"p")])])]),n(" 处是 "),l("strong",null,"可用的（Avaliable）"),n(" ，如果：")]),l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"所有"),n(" 的从程序入口到程序点 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"p")]),l("annotation",{encoding:"application/x-tex"},"p")])])]),n(" 的路径都 "),l("strong",null,"必须"),n(" 经过 "),l("code",null,"x op y"),n(" 表达式的评估（Evaluation），并且")])]),l("li",null,[l("p",null,[n("在最后一次 "),l("code",null,"x op y"),n(" 的评估之后，没有 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"x")]),l("annotation",{encoding:"application/x-tex"},"x")])])]),n(" 或者 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"y")]),l("annotation",{encoding:"application/x-tex"},"y")])])]),n(" 的重定义（Redefinition）。")])])]),l("p",null,[n("对于程序中每个程序点处的可用表达式的分析，我们称之为 "),l("strong",null,"可用表达式分析（Avaliable Expression Analysis）"),n(" 。")])],-1),l("p",null,[n("这里说一个表达式是可用的，指的是这个表达是的值肯定已经被计算过了，可以直接复用之前的结果，没必要再算一遍，也就是说，这个表达式 "),l("strong",null,"不需要忙碌于计算"),n(" 。我们考虑一个简单的场景。")],-1),l("div",{class:"language-bash vp-adaptive-theme"},[l("button",{title:"Copy Code",class:"copy"}),l("span",{class:"lang"},"bash"),l("pre",{class:"shiki shiki-themes github-light github-dark vp-code"},[l("code",{"v-pre":""},[l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"if"),l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}}," a"),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}}," -"),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}}," b"),l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}}," >"),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}}," c"),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}}," then")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"    c"),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}}," ="),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}}," a"),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}}," -"),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}}," b"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},";")])])]),l("button",{class:"collapse"})],-1),l("div",{class:"language-bash vp-adaptive-theme"},[l("button",{title:"Copy Code",class:"copy"}),l("span",{class:"lang"},"bash"),l("pre",{class:"shiki shiki-themes github-light github-dark vp-code"},[l("code",{"v-pre":""},[l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"d"),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}}," ="),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}}," a"),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}}," -"),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}}," b"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},";")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"if"),l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}}," d"),l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}}," >"),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}}," c"),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}}," then")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"  c"),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}}," ="),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}}," d")])])]),l("button",{class:"collapse"})],-1),l("p",null,[n("上面两个例子功能性上是等价的，但是在 Example 01 中， "),l("code",null,"a - b"),n(" 被重复计算了两次，而 Example 02 中， "),l("code",null,"a - b"),n(" 只被计算了一次，因此 Example 02 的效率是更高的。在 Example 01 的第2行， "),l("code",null,"a - b"),n(" 就是一个可用表达式，在之前肯定已经被计算过，因此我么可以对程序进行优化，通过一个变量或者是寄存器储存之前的计算结果，从而在之后不需要进行重复的计算。")],-1),l("p",null,"可用表达式的相关信息还可以被用来检测全局的公共子表达式（Global Common Subexpression）。",-1),l("p",null,"从定义中不难看出，可用表达式分析是一种必然性分析。因为在上述表达式优化的应用场景中，我们可以不优化每一个表达式，但不可以优化错误（也就是说一旦决定优化某个表达式，这个表达式就必须必然是可用表达式）。",-1),l("h3",{id:"_3-4-2-问题分析",tabindex:"-1"},[n("3.4.2 问题分析 "),l("a",{class:"header-anchor",href:"#_3-4-2-问题分析","aria-label":'Permalink to "3.4.2 问题分析"'},"​")],-1),l("p",null,"经过了前两种数据流分析的铺垫，相信读者对于数据流分析的基本过程已经轻车熟路了，下面和前面重复的部分我就不多解释了。",-1),l("h4",{id:"数据抽象-2",tabindex:"-1"},[n("数据抽象 "),l("a",{class:"header-anchor",href:"#数据抽象-2","aria-label":'Permalink to "数据抽象"'},"​")],-1),l("p",null,[n("在这个问题中，考虑程序中所有表达式的集合，即 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"E"),l("mo",null,"="),l("mo",{stretchy:"false"},"{"),l("msub",null,[l("mi",null,"e"),l("mn",null,"1")]),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"e"),l("mn",null,"2")]),l("mo",{separator:"true"},","),l("mi",{mathvariant:"normal"},"."),l("mi",{mathvariant:"normal"},"."),l("mi",{mathvariant:"normal"},"."),l("mo",{separator:"true"},","),l("msub",null,[l("mi",null,"e"),l("mi",null,"n")]),l("mo",{stretchy:"false"},"}")]),l("annotation",{encoding:"application/x-tex"},"E = \\{e_1, e_2, ..., e_n\\}")])])]),n(" ，其中 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"e"),l("mi",null,"i")])]),l("annotation",{encoding:"application/x-tex"},"e_i")])])]),n(" 是程序中的表达式。那么，每个程序点处的抽象程序状态，也就是数据流值，则为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"E")]),l("annotation",{encoding:"application/x-tex"},"E")])])]),n(" 的一个子集，整个分析的定义域 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"D"),l("mo",null,"="),l("msup",null,[l("mn",null,"2"),l("mi",null,"E")])]),l("annotation",{encoding:"application/x-tex"},"D = 2^E")])])]),n(" 。之后我们只需要建立 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("msub",null,[l("mi",null,"f"),l("mrow",null,[l("mi",null,"P"),l("mi",null,"P"),l("mo",null,"→"),l("mi",null,"D")])])]),l("annotation",{encoding:"application/x-tex"},"f_{PP\\to D}")])])]),n(" 即可。")],-1),l("h4",{id:"约束分析-2",tabindex:"-1"},[n("约束分析 "),l("a",{class:"header-anchor",href:"#约束分析-2","aria-label":'Permalink to "约束分析"'},"​")],-1),l("p",null,"定义3.14中已经指出从程序入口开始了，所以是顺序分析。定义3.14还告诉我们，需要所有的路径都可用才算可用，因此这是一个必然性分析（Must Analysis，见定义3.2）。",-1),l("p",null,"下面考虑两种约束：语意约束和控制流约束。",-1),l("p",null,[n("考虑 "),l("strong",null,"语意约束"),n(" ，基于定义3.14，我们每次需要从 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"IN[B]")])])]),n(" 中加入 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"B")]),l("annotation",{encoding:"application/x-tex"},"B")])])]),n(" 中产生的新表达式，删去 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"IN[B]")])])]),n(" 中被 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"B")]),l("annotation",{encoding:"application/x-tex"},"B")])])]),n(" 重定义变量的表达式。定义 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"g"),l("mi",null,"e"),l("msub",null,[l("mi",null,"n"),l("mi",null,"B")])]),l("annotation",{encoding:"application/x-tex"},"gen_B")])])]),n(" 为基块B中的所有的表达式的集合， "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"k"),l("mi",null,"i"),l("mi",null,"l"),l("msub",null,[l("mi",null,"l"),l("mi",null,"B")])]),l("annotation",{encoding:"application/x-tex"},"kill_B")])])]),n(" 为 "),l("strong",null,[n("程序中所有的其中变量被 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"B")]),l("annotation",{encoding:"application/x-tex"},"B")])])]),n(" 重定义的表达式")]),n(" 的集合。")],-1),l("blockquote",null,[l("p",null,[n("这里 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"k"),l("mi",null,"i"),l("mi",null,"l"),l("msub",null,[l("mi",null,"l"),l("mi",null,"B")])]),l("annotation",{encoding:"application/x-tex"},"kill_B")])])]),n(" 为程序中所有的变量被B重定义的表达式的集合，而不是 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"IN[B]")])])]),n(" 中被B重定义变量的表达式集合，这是因为 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"g"),l("mi",null,"e"),l("msub",null,[l("mi",null,"n"),l("mi",null,"B")])]),l("annotation",{encoding:"application/x-tex"},"gen_B")])])]),n(" 与 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"k"),l("mi",null,"i"),l("mi",null,"l"),l("msub",null,[l("mi",null,"l"),l("mi",null,"B")])]),l("annotation",{encoding:"application/x-tex"},"kill_B")])])]),n(" 需要能够在数据流分析算法执行之前被静态的计算好，这样在算法过程中就不需要每次迭代都重新计算了。并且我们之后是取差集操作，因此 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"k"),l("mi",null,"i"),l("mi",null,"l"),l("msub",null,[l("mi",null,"l"),l("mi",null,"B")])]),l("annotation",{encoding:"application/x-tex"},"kill_B")])])]),n(" 大一点并不会影响结果。")])],-1),l("p",null,"于是，我们可以得到状态转移方程如下：",-1),l("p",null,[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("mi",null,"g"),l("mi",null,"e"),l("msub",null,[l("mi",null,"n"),l("mi",null,"B")]),l("mo",null,"∪"),l("mo",{stretchy:"false"},"("),l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",null,"−"),l("mi",null,"k"),l("mi",null,"i"),l("mi",null,"l"),l("msub",null,[l("mi",null,"l"),l("mi",null,"B")]),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"OUT[B] = gen_B \\cup (IN[B] - kill_B) ")])])])],-1),l("p",null,[n("考虑 "),l("strong",null,"控制流约束"),n(" ，由于是必然性分析，所以交汇操作应该是交集，即 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mo",null,"∧"),l("mo",null,"="),l("mo",null,"∩")]),l("annotation",{encoding:"application/x-tex"},"\\wedge = \\cap")])])]),n(" ，于是控制流约束为：")],-1),l("p",null,[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[l("semantics",null,[l("mrow",null,[l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("munder",null,[l("mo",null,"⋂"),l("mrow",null,[l("mi",null,"P"),l("mo",null,"∈"),l("mi",null,"p"),l("mi",null,"r"),l("mi",null,"e"),l("mo",{stretchy:"false"},"("),l("mi",null,"B"),l("mo",{stretchy:"false"},")")])]),l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"P"),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"IN[B] = \\bigcap_{P \\in pre(B)} OUT[P] ")])])])],-1),l("h3",{id:"_3-4-3-问题求解",tabindex:"-1"},[n("3.4.3 问题求解 "),l("a",{class:"header-anchor",href:"#_3-4-3-问题求解","aria-label":'Permalink to "3.4.3 问题求解"'},"​")],-1),l("h4",{id:"算法设计-2",tabindex:"-1"},[n("算法设计 "),l("a",{class:"header-anchor",href:"#算法设计-2","aria-label":'Permalink to "算法设计"'},"​")],-1),l("p",null,"基于上述分析，我们可以设计可用表达式分析算法如下。",-1),l("div",{class:"algorithm"},[l("p",{class:"title"},"算法3.3 可用表达式分析算法"),l("iframe",{src:"/posts/StaticAnalytics/03-dfa-ap/available-expressions.html",frameborder:"no",border:"0",marginwidth:"0",width:"100%",height:"315px",marginheight:"0",scrolling:"auto",style:{"box-shadow":"none"}})],-1),l("blockquote",null,[l("p",null,[n("注： "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"U")]),l("annotation",{encoding:"application/x-tex"},"U")])])]),n(" 和 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"I")]),l("annotation",{encoding:"application/x-tex"},"I")])])]),n(" 常在集合论中表示全集。")])],-1),l("p",null,"我们可以通过下面的例子来直观感受一下上面的算法。",-1),l("figure",null,[l("img",{src:_,alt:"ae-eg",loading:"lazy",decoding:"async"})],-1),l("h4",{id:"算法分析-2",tabindex:"-1"},[n("算法分析 "),l("a",{class:"header-anchor",href:"#算法分析-2","aria-label":'Permalink to "算法分析"'},"​")],-1),l("div",{class:"theorem"},[l("p",{class:"title"},"定理3.6"),l("p",null,"算法3.3能够正常终止。")],-1),l("p",null,"算法3.3和算法3.1基本上是一致的，不同的地方有：",-1),l("ul",null,[l("li",null,[l("p",null,[n("初始化的时候，除了程序入口之外的其他基块B的 "),l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"OUT[B]")])])]),n(" 都初始化为了全集，因为在最开始的时候，所有的表达式都是可用的。只有当我们在分析过程中发现表达式中的某个变量被重定义的时候，表达式才会变得不可用（需要重新计算）。")])]),l("li",null,[l("p",null,"控制流约束部分变成了交集，因为我们这里是必然性分析。")])],-1),l("p",null,"当我们分析出初始状态的时候，需要通过语意以及对算法执行过程的影响来分析，到底是空集还是全集。当然，在下一章中会有更加形式化的基于数学语言的解释。",-1),l("h2",{id:"_3-5-总结",tabindex:"-1"},[n("3.5 总结 "),l("a",{class:"header-anchor",href:"#_3-5-总结","aria-label":'Permalink to "3.5 总结"'},"​")],-1),l("p",null,"到此，我们已经学习完了3种经典的数据流分析，我们可以稍微对比一下。",-1),l("table",null,[l("thead",null,[l("tr",null,[l("th",{style:{"text-align":"center"}}),l("th",{style:{"text-align":"center"}},"定义可达性分析"),l("th",{style:{"text-align":"center"}},"活跃变量分析"),l("th",{style:{"text-align":"center"}},"可用表达式分析")])]),l("tbody",null,[l("tr",null,[l("td",{style:{"text-align":"center"}},"定义域"),l("td",{style:{"text-align":"center"}},"定义集的幂集"),l("td",{style:{"text-align":"center"}},"变量集的幂集"),l("td",{style:{"text-align":"center"}},"表达式集的幂集")]),l("tr",null,[l("td",{style:{"text-align":"center"}},"方向"),l("td",{style:{"text-align":"center"}},"正向分析"),l("td",{style:{"text-align":"center"}},"逆向分析"),l("td",{style:{"text-align":"center"}},"正向分析")]),l("tr",null,[l("td",{style:{"text-align":"center"}},"估计"),l("td",{style:{"text-align":"center"}},"过近似"),l("td",{style:{"text-align":"center"}},"过近似"),l("td",{style:{"text-align":"center"}},"欠近似")]),l("tr",null,[l("td",{style:{"text-align":"center"}},"边界"),l("td",{style:{"text-align":"center"}},[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"E"),l("mi",null,"N"),l("mi",null,"T"),l("mi",null,"R"),l("mi",null,"Y"),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("mi",{mathvariant:"normal"},"∅")]),l("annotation",{encoding:"application/x-tex"},"OUT[ENTRY]=\\emptyset")])])])]),l("td",{style:{"text-align":"center"}},[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"E"),l("mi",null,"X"),l("mi",null,"I"),l("mi",null,"T"),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("mi",{mathvariant:"normal"},"∅")]),l("annotation",{encoding:"application/x-tex"},"IN[EXIT]=\\emptyset")])])])]),l("td",{style:{"text-align":"center"}},[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"E"),l("mi",null,"N"),l("mi",null,"T"),l("mi",null,"R"),l("mi",null,"Y"),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("mi",{mathvariant:"normal"},"∅")]),l("annotation",{encoding:"application/x-tex"},"OUT[ENTRY]=\\emptyset")])])])])]),l("tr",null,[l("td",{style:{"text-align":"center"}},"初始化"),l("td",{style:{"text-align":"center"}},[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("mi",{mathvariant:"normal"},"∅")]),l("annotation",{encoding:"application/x-tex"},"OUT[B] = \\emptyset")])])])]),l("td",{style:{"text-align":"center"}},[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("mi",{mathvariant:"normal"},"∅")]),l("annotation",{encoding:"application/x-tex"},"IN[B]=\\emptyset")])])])]),l("td",{style:{"text-align":"center"}},[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("mi",null,"U")]),l("annotation",{encoding:"application/x-tex"},"OUT[B] = U")])])])])]),l("tr",null,[l("td",{style:{"text-align":"center"}},"状态转移"),l("td",{style:{"text-align":"center"}},[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("mi",null,"g"),l("mi",null,"e"),l("msub",null,[l("mi",null,"n"),l("mi",null,"B")]),l("mo",null,"∪"),l("mo",{stretchy:"false"},"("),l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",null,"−"),l("mi",null,"k"),l("mi",null,"i"),l("mi",null,"l"),l("msub",null,[l("mi",null,"l"),l("mi",null,"B")]),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"OUT[B] = gen_B \\cup (IN[B] - kill_B)")])])])]),l("td",{style:{"text-align":"center"}},[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("mi",null,"u"),l("mi",null,"s"),l("msub",null,[l("mi",null,"e"),l("mi",null,"B")]),l("mo",null,"∪"),l("mo",{stretchy:"false"},"("),l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",null,"−"),l("mi",null,"d"),l("mi",null,"e"),l("msub",null,[l("mi",null,"f"),l("mi",null,"B")]),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"IN[B] = use_B \\cup (OUT[B] - def_B)")])])])]),l("td",{style:{"text-align":"center"}},[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("mi",null,"g"),l("mi",null,"e"),l("msub",null,[l("mi",null,"n"),l("mi",null,"B")]),l("mo",null,"∪"),l("mo",{stretchy:"false"},"("),l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",null,"−"),l("mi",null,"k"),l("mi",null,"i"),l("mi",null,"l"),l("msub",null,[l("mi",null,"l"),l("mi",null,"B")]),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"OUT[B] = gen_B \\cup (IN[B] - kill_B)")])])])])]),l("tr",null,[l("td",{style:{"text-align":"center"}},"交汇"),l("td",{style:{"text-align":"center"}},[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("munder",null,[l("mo",null,"⋃"),l("mrow",null,[l("mi",null,"P"),l("mo",null,"∈"),l("mi",null,"p"),l("mi",null,"r"),l("mi",null,"e"),l("mo",{stretchy:"false"},"("),l("mi",null,"B"),l("mo",{stretchy:"false"},")")])]),l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"P"),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"IN[B] = \\bigcup\\limits_{P \\in pre(B)} OUT[P]")])])])]),l("td",{style:{"text-align":"center"}},[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("munder",null,[l("mo",null,"⋃"),l("mrow",null,[l("mi",null,"S"),l("mo",null,"∈"),l("mi",null,"s"),l("mi",null,"u"),l("mi",null,"c"),l("mo",{stretchy:"false"},"("),l("mi",null,"B"),l("mo",{stretchy:"false"},")")])]),l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"S"),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"OUT[B] = \\bigcup\\limits_{S \\in suc(B)} IN[S]")])])])]),l("td",{style:{"text-align":"center"}},[l("span",{class:"katex"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"I"),l("mi",null,"N"),l("mo",{stretchy:"false"},"["),l("mi",null,"B"),l("mo",{stretchy:"false"},"]"),l("mo",null,"="),l("munder",null,[l("mo",null,"⋂"),l("mrow",null,[l("mi",null,"P"),l("mo",null,"∈"),l("mi",null,"p"),l("mi",null,"r"),l("mi",null,"e"),l("mo",{stretchy:"false"},"("),l("mi",null,"B"),l("mo",{stretchy:"false"},")")])]),l("mi",null,"O"),l("mi",null,"U"),l("mi",null,"T"),l("mo",{stretchy:"false"},"["),l("mi",null,"P"),l("mo",{stretchy:"false"},"]")]),l("annotation",{encoding:"application/x-tex"},"IN[B] = \\bigcap\\limits_{P \\in pre(B)} OUT[P]")])])])])])])],-1),l("p",null,"于是，我们可以简单总结一下数据流分析的基本过程。",-1),l("div",{class:"conclusion"},[l("p",{class:"title"},"结论3.3 数据流分析的基本过程"),l("ol",null,[l("li",null,[l("p",null,"问题描述："),l("ul",null,[l("li",null,"定义要研究的问题，从而确定分析顺序（正向还是逆向）和估计方式（过近似还是欠近似）；")])]),l("li",null,[l("p",null,"数据抽象："),l("ul",null,[l("li",null,"确定抽象数据状态集（也就是数据流值集），从而确定定义域；")])]),l("li",null,[l("p",null,"约束分析："),l("ul",null,[l("li",null,[l("p",null,"考虑语意约束，确定状态转移方程；")]),l("li",null,[l("p",null,"考虑控制流约束，确定交汇操作符的含义；")])])]),l("li",null,[l("p",null,"算法设计："),l("ul",null,[l("li",null,"根据上述分析设计算法，我们目前只学了迭代算法，还可以有其他的算法设计；")])]),l("li",null,[l("p",null,"算法分析："),l("ul",null,[l("li",null,"分析算法的正确性和复杂度。")])])])],-1),l("h2",{id:"_3-6-自检问题",tabindex:"-1"},[n("3.6 自检问题 "),l("a",{class:"header-anchor",href:"#_3-6-自检问题","aria-label":'Permalink to "3.6 自检问题"'},"​")],-1),l("ol",null,[l("li",null,[l("p",null,"定义可达性（Reaching Definitions）分析、活跃变量（Live Variables）分析和可用表达式（Avaliable Expressions）分析分别是什么含义？")]),l("li",null,[l("p",null,"上述三种数据流分析（Data Flow Analysis）有哪些不同点？又有什么相似的地方？")]),l("li",null,[l("p",null,"如何理解数据流分析的迭代算法？数据流分析的迭代算法为什么最后能够终止？")])],-1),l("div",{class:"tip custom-block"},[l("p",{class:"custom-block-title"},[l("span",{lang:"en"},"作业布置"),l("span",{lang:"zh-CN"},"作业布置")]),l("p",null,[n("到此为止，读者已经具备了完成"),l("a",{href:"https://tai-e.pascal-lab.net/pa1.html",target:"_blank",rel:"noreferrer"},"作业 1：活跃变量分析和迭代求解器"),n("所需的全部理论知识。")])],-1)])),"main-header":t(()=>[i(a.$slots,"main-header")]),"main-header-after":t(()=>[i(a.$slots,"main-header-after")]),"main-nav":t(()=>[i(a.$slots,"main-nav")]),"main-content":t(()=>[i(a.$slots,"main-content")]),"main-content-after":t(()=>[i(a.$slots,"main-content-after")]),"main-nav-before":t(()=>[i(a.$slots,"main-nav-before")]),"main-nav-after":t(()=>[i(a.$slots,"main-nav-after")]),comment:t(()=>[i(a.$slots,"comment")]),footer:t(()=>[i(a.$slots,"footer")]),aside:t(()=>[i(a.$slots,"aside")]),"aside-custom":t(()=>[i(a.$slots,"aside-custom")]),default:t(()=>[i(a.$slots,"default")]),_:3},8,["frontmatter"])}}};export{D as default};

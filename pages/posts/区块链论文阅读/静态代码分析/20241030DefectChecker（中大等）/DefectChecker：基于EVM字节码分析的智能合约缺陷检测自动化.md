---
title: DefectChecker：基于EVM字节码分析的智能合约缺陷检测自动化
date: 2024-10-30
tags: 
  - 静态代码分析
  - 区块链
  - 智能合约
  - 以太坊
  - 合约缺陷检测
  - 字节码分析
  - 符号执行
categories: 
  - 论文阅读
---

# DefectChecker：基于 EVM 字节码分析的智能合约缺陷检测自动化

## 摘要

智能合约是在区块链上运行的图灵完备程序。它们是不可变的，一旦部署后即便发现错误也无法修改。因此，在将智能合约部署到区块链之前，确保其无错误且设计完善极为重要。合约缺陷是指智能合约中的错误、缺陷或漏洞，这些问题可能导致合约产生错误或意外结果，或者因意外行为而无法正常工作。检测和消除合约缺陷可以避免潜在的攻击，增强程序的鲁棒性。我们之前的工作定义了 20 种智能合约缺陷，并将其分为五个影响级别。根据我们的分类，从 1 到 3 级的缺陷可能导致不安全行为，例如合约被攻击者控制。在本文中，我们提出了一种名为`DefectChecker`的工具，它基于符号执行的方法来检测以太坊区块链平台上智能合约的缺陷。`DefectChecker`可以从智能合约的字节码中检测出缺陷。我们通过将其应用于一个开源数据集来验证`DefectChecker`的性能。评估结果显示，`DefectChecker`在整个数据集中的 F-score 很高（88.8%），并且平均分析一个智能合约只需 0.15 秒。我们还将`DefectChecke`应用于以太坊平台上的 165,621 个智能合约，结果发现有 25,815 个智能合约至少包含一个属于 1 到 3 级影响的缺陷，其中包括一些真实的攻击案例。

`索引术语`——智能合约，以太坊，合约缺陷检测，字节码分析，符号执行

## 引言

近年来，去中心化加密货币引起了广泛关注。为了确保这些系统在没有中心化组织管理的情况下仍然具有可扩展性和安全性，去中心化加密货币采用区块链概念作为其基础技术。比特币[1]是第一个数字货币，它允许用户通过编码脚本自动处理交易。然而，比特币中的脚本不是图灵完备的，这限制了它们在货币转账或支付等应用上的能力。为了应对这一限制，以太坊[2]引入了一种名为智能合约的技术，这是一种在区块链上运行的图灵完备程序。通过利用该技术，实践者可以开发去中心化应用程序（DApps）[3]，并将区块链技术应用于游戏[4]和金融[5]等不同领域。

智能合约通常使用高级编程语言编写，例如Solidity[6]。当开发者将智能合约部署到以太坊时，合约首先会被编译为以太坊虚拟机（EVM）字节码。然后，以太坊系统中的每个节点都会接收到智能合约的字节码并在其分类账中保留一个副本。任何人，包括攻击者，都可以通过向相应的合约地址发送交易来调用该智能合约。

智能合约的关键特性使其成为黑客的有吸引力目标[7]。一方面，许多智能合约持有有价值的以太币，且无法隐藏其余额，这为黑客提供了经济动机[8]，[9]。另一方面，智能合约在无权限网络中运行，这意味着黑客可以自由地检查所有交易和字节码，并尝试找到合约中的漏洞。更糟的是，智能合约一旦部署，即便发现了错误也无法修改。因此，在将智能合约部署到以太坊之前，确保其无错误且设计完善至关重要。

合约缺陷[10]，[11]是指导致智能合约产生不正确或意外结果，或以意外方式行为的错误、缺陷或漏洞[12]。检测和消除合约缺陷是避免潜在攻击并改进现有代码设计的方法。在我们之前的工作中[11]，我们通过分析 StackExchange[13]帖子首先定义了 20 种合约缺陷。这也是第一个通过在线调查验证智能合约开发者是否认为这些缺陷有害的工作，这使得定义更具说服力。我们的工作将定义的 20 种合约缺陷分为五个影响级别，结果表明包含 1 到 3 级缺陷的智能合约可能导致不安全行为，例如合约被攻击者控制。

然而，我们之前的工作并未提出一种可以检测这些合约缺陷的合适工具。为了解决这一局限性，本文提出了`DefectChecker`，用于检测我们之前工作中定义的对合约造成严重影响（1 级为高，3 级为中）的缺陷，使用智能合约的字节码进行检测。`DefectChecker`通过字节码进行符号执行，无需源代码支持。在符号执行过程中，`DefectChecke`生成智能合约的控制流图（CFG）以及“堆栈事件”，并识别三种特征，即“资金调用”、“循环块”和“应付函数”。通过使用CFG、堆栈事件和这三种特征，我们设计了相应的规则来检测每种合约缺陷。

我们通过应用到我们之前工作中开发的开源数据集来验证`DefectChecker`的性能[11]。我们还将其结果与三种先进工具（如`Oyente`、`Mythril`和`Securify`）进行比较。评估结果表明，`DefectChecker`在整个数据集中的 F-score 最高（88.8%），并且分析一个智能合约的时间最短（每个合约 0.15 秒），相比其他基线工具。我们还提取了截至 2019 年 1 月部署到以太坊上的所有智能合约字节码，并将`DefectChecker`应用于 165,621 个不同的字节码智能合约。结果发现，以太坊上的智能合约中有 15.9% 至少包含一个属于 1 到 3 级影响的缺陷。

本工作的主要贡献如下：

- 据我们所知，`DefectChecker`是目前最准确且最快的基于符号执行的智能合约缺陷检测工具。
- 我们系统地评估了工具的性能，使用一个开源数据集进行测试。此外，我们还提取了以太坊平台上的所有字节码（165,621个），并确定其中25,815个智能合约包含至少一个缺陷。通过这些分析，我们发现了一些真实世界的攻击案例，并举例说明了检测合约缺陷的重要性。
- 我们的数据集、工具和分析结果已向社区开放：https://github.com/Jiachi-Chen/DefectChecker/。

本文其余部分的组织如下。在第 2 节中，我们提供了智能合约的背景知识，并介绍了带有代码示例的合约缺陷。在第 3 节中，我们介绍了`DefectChecker`的架构，在第 4 节中，我们介绍了其表示和实现。在第 5 节中，我们对在以太坊智能合约上的大规模案例研究进行了评估，并在第 6 节中给出了真实案例作为案例研究。在第 6 节中，我们介绍了相关工作。最后，我们在第 7 节中总结了本研究并讨论了未来可能的工作。

## 背景与动机

在本节中，我们简要介绍了关于智能合约及其合约缺陷的关键背景信息。

### 智能合约

合约。利用区块链技术，智能合约是在区块链上存储的自治协议。一旦启动，合约的运行是自动的，并且按照预先定义的程序逻辑进行[14]。当开发人员将智能合约部署到以太坊时，合约将被编译为 EVM 字节码，并由唯一的 160 位十六进制哈希合约地址标识。智能合约的执行取决于其代码，即使是合约创建者也无法影响其运行或状态。例如，如果合约不包含以太币转账的功能，即使是创建者也无法提取以太币。智能合约运行在无权限网络中，任何人都可以通过 ABI（应用程序二进制接口）[6]调用智能合约的方法。合约字节码、交易和调用参数对所有人都是公开的。

`Gas 系统`。为了确保智能合约的安全性，智能合约的每笔交易都将由所有矿工运行。以太坊使用 gas 系统[15]来衡量其计算工作量，发送交易以调用智能合约的开发人员需要支付执行费用。执行费用的计算方式为：$gas\_cost$ $\times$ $gas\_price$。gas 费用取决于执行所需的计算资源，而 gas 价格则由交易创建者提供。为了限制调用交易的 gas 费用，开发人员会设置 Gas 上限，以确定最大 gas 费用。如果交易的 gas 费用超过了 Gas 上限，则会失败并抛出`out-of-gas`错误[2]。某些特殊操作将会对 Gas 上限设定特定值。例如，`address.transfer()`和`address.send()`是以太坊提供的两种用于转移以太币的方法。如果智能合约使用这些方法向另一个智能合约发送以太币，Gas 上限将限制为 2300 gas 单位[6]。2300 gas 单位不足以进行存储、调用函数或发送以太币，这可能导致交易失败。因此，`address.transfer()`和`address.send()`只能用于向外部账户发送以太币（外部账户指由私钥控制的账户，与合约代码控制的合约账户不同[2]）。

`以太坊虚拟机（EVM）`。为了将智能合约部署到以太坊，其源代码需要编译为字节码并存储在区块链上。EVM 是一种基于堆栈的机器：当需要执行交易时，EVM 会首先将字节码拆分为字节，每个字节表示唯一的指令，称为操作码。截至 2019 年 4 月，共有 140 个唯一的操作码[2]，每个操作码由十六进制编号表示[2]。EVM 使用这些操作码执行任务。例如，考虑一个字节码`0x6070604001`。EVM 首先将该字节码拆分为字节（`0x60`，`0x70`，`0x60`，`0x40`，`0x01`），并执行第一个字节`0x60`，其操作码为`PUSH1`。`PUSH1`将一个字节数据推送到EVM堆栈中。因此，`0x70`被推送到堆栈中。然后，EVM 读取下一个`0x60`并将`0x40`推入堆栈。最后，EVM 执行`0x01`，其操作码为`ADD`。`ADD`从堆栈顶部获取两个值，即`0x70`和`0x40`，并将它们的和（`B0`）推入堆栈。

`EVM 字节码与控制流分析中的 JVM 字节码`。控制流分析方法在其他基于堆栈的机器（例如 JVM[16]）中被广泛使用。然而，JVM 字节码与 EVM 字节码之间存在一些差异。这些差异在分析 EVM 字节码时提出了一些新的挑战。我们在本文中强调了 EVM 字节码分析方法与 JVM 字节码分析的关键差异，包括：

（1）JVM 字节码在不同的控制流路径下具有固定的堆栈深度。而 EVM 无法在具有不同堆栈大小的情况下到达同一程序点[17]。EVM 字节码没有这种约束，这大大增加了识别 EVM 字节码中控制流结构的难度。例如，对于简单的递归代码“`function f(int a){f(a);}`”，其在 EVM 中的代码如下：

```
Block 1:
  JUMPDEST
  PUSH Block1' ID
  DUP2
  PUSH Block2' ID
  JUMP
Block 2:
  JUMPDEST
```
存在两个代码块；两个块标识符在相同的块（块1）中被推入，并将由相同的指令`JUMP`读取。JVM 和 EVM 的区别在于，JVM为每个方法调用创建一个新的操作数栈[18]，而 EVM 只有一个全局操作数栈。（帧用于存储数据和部分结果，也用于执行动态链接、方法返回值和调度异常）。

（2）JVM 字节码为每个跳转定义了明确的目标集[19]。相比之下，EVM 字节码的跳转目标从 EVM 堆栈中读取。当使用条件跳转时，目标将受堆栈第二项影响。例如，在图 2 中，跳转目标`JUMPI`（ID 140）从先前的指令`PUSH`读取，并将受堆栈第二项（例如，`ISZERO(GT(10, num))`）的影响。如果第二项为真值，则跳转目标为 148；否则，目标为 141。无条件跳转目标也从 EVM 堆栈顶部读取。例如，图 2 中的`JUMP`（ID 147）的跳转目标也从之前的指令`PUSH`读取。因此，我们需要通过符号执行 EVM 字节码来构造控制流边。

（3）JVM 字节码有明确的方法调用和返回指令[17]。相比之下，EVM 字节码使用跳转来执行合约内部的函数调用。在这种情况下，为了解析合约内部的函数调用，我们需要检查堆栈顶部元素以确定跳转目标。例如，假设有两个函数 A 和 B。函数 A 包含三个块，例如 A1、A2 和 A3；函数 B 包含两个块，例如 B1 和 B2。代码块 B2 调用函数 B 中的代码块 B1。在 EVM 字节码中，没有定义的方法调用和返回指令。相反，EVM 将返回地址推入堆栈中；调用方的块标识符（B1 的块 ID）需要通过字节码识别。为了返回，代码将从 EVM堆栈顶部读取调用者的块标识符（A3），然后跳转执行块。因此，执行序列为 A1、A2、B1、B2、A3。块 B1 和 A3 的标识符需要从字节码中获得以确定跳转目标。

`Fallback函数`。Fallback函数是智能合约相较于传统程序的一项独特特性。在智能合约编程中，Fallback函数是唯一没有命名的函数[6]。当交易调用合约中的某个函数但没有找到对应的函数时，Fallback函数将被自动执行。如果函数被标记为`payable`[6]，则在收到以太币时Fallback函数也会自动执行。

`CALL 指令和以太币转移`。以太币转移是以太坊中的一个重要功能。在 Solidity 编程中，有三种方法用于转移以太币，即`address.call.value()`，`address.transfer()`，和`address.send()`。在这三种方法中，只有`address.call.value()`允许用户将以太币发送到合约地址，而其他两种方法限制为 2300 gas 单位，这不足以发送以太币。`address.send()`返回一个布尔值，而`address.transfer()`在错误发生时抛出异常。这三种方法都可以在合约字节码中生成`CALL`指令。其他行为（例如函数调用）也可以生成`CALL`指令。`CALL`指令从 EVM 堆栈顶部读取七个值。它们代表 gas 限制、接收地址、转移金额、输入数据起始位置、输入数据大小、输出数据起始位置和输出数据大小。

### 智能合约中的合约缺陷

我们之前的工作[11]定义了 20 种智能合约的缺陷。我们将这些缺陷分为五个“影响”级别；在这些缺陷中，11 种属于影响级别 1（最严重）到 3（中等严重性），可能导致不安全行为。表 1 中给出了这些 11 种缺陷的定义。在本文中，我们提出了`DefectChecker`，一种符号执行工具，用于检测这些影响级别中的八个合约缺陷。`DefectChecker`不检测属于影响级别 4 和 5 的缺陷，因为这些缺陷不会影响智能合约的正常运行。例如，未指定编译器版本是五个最严重缺陷之一。消除该缺陷需要合约开发人员在合约中指定特定的编译器版本（如 0.4.25）。该缺陷不会影响合约的正常运行，仅对未来代码的重用构成威胁。这种缺陷很难通过字节码级别检测，因为语义信息在编译后丢失。

<p style="text-align:center">表1：影响级别为 1 - 3 的合约缺陷定义</p>

| 合约缺陷                    | 定义                                                       | 影响级别 |
| --------------------------- | ---------------------------------------------------------- | -------- |
| 交易状态依赖性 (TSD)        | 使用`tx.origin`检查权限                                    | IP1      |
| 严格余额质量 (SBE)          | 使用严格的余额质量来确定执行逻辑                           | IP2      |
| 嵌套调用 (NC)               | 在无限长度的循环中执行`CALL`指令                           | IP2      |
| 未检查的外部调用 (UEC)      | 不检查外部调用函数的返回值                                 | IP3      |
| 类型不匹配赋值              | 分配不匹配的类型值，可能导致整数溢出                       | IP2      |
| 硬编码地址                  | 在智能合约中使用硬编码地址                                 | IP3      |
| 外部影响下的拒绝服务 (DuEI) | 在可能受到外部用户影响的循环中抛出异常                     | IP2      |
| 重入漏洞 (RE)               | 重入攻击漏洞                                               | IP1      |
| 贪婪合约 (GC)               | 合约可以接收以太币但无法提取                               | IP3      |
| 区块信息依赖性 (BID)        | 使用与区块信息相关的函数来确定执行逻辑                     | IP3      |
| 数据位置误导                | 本地变量的引用类型（如`struct`、`array`或`mapping`）未明确 | IP2      |

`注：前八种合约缺陷可以通过 DefectChecker 检测`

然而，请注意，在本研究中，我们未考虑属于影响级别 1 到 3 的三种合约缺陷——类型不匹配赋值、硬编码地址和数据位置误导，因为这些缺陷不易通过字节码级别检测。我们的分析表明，它们分别出现在 22、84 和 587 个智能合约中。编译智能合约为字节码时，这些信息会被删除或丢失，这可能会掩盖源代码中的约束条件。对于硬编码地址，从区块链获取的字节码中不包含关于构造函数的信息，而我们发现大多数硬编码地址错误出现在构造函数中。对于检测类型不匹配赋值，我们需要知道最大循环迭代次数，这通常是从存储中读取的，并且很难通过静态分析获得。例如，对于循环“`for(uint8 i = 0; i < num; i++)`”，`uint8`的范围是 0 到 255。如果`num`大于 255，循环将会溢出。然而，`num`通常是从存储中读取的存储变量或依赖于外部输入。因此，通过字节码分析很难检测到这一缺陷。数据位置误导也不易通过字节码检测。在 Solidity 编程中，`storage`在 Solidity 中不是动态分配的，并且`struct`、`array`或`mapping`类型的数据在存储中维护。因此，这三种类型的数据将导致函数默认指向存储槽 0，这可能导致潜在的漏洞。然而，我们无法知道槽 0 上的指针是正确的还是 EVM 的错误。

#### 影响级别的定义

下面我们给出了八种智能合约缺陷中每种的代表性示例，并根据我们的先前工作引入了影响级别 1 到 3 的定义。

- `影响级别 1 (IP1)`：包含这些缺陷的智能合约可能导致严重的意外行为。攻击者可以利用这些缺陷触发不安全行为，并通过利用这些缺陷获利。
- `影响级别 2 (IP2)`：包含这些缺陷的智能合约可能导致严重的意外行为。攻击者可以利用这些缺陷触发不安全行为，但无法通过利用这些缺陷获利。
- `影响级别 3 (IP3)`：IP3有两种类型。`类型 A`：包含这些缺陷的智能合约可能导致严重的意外行为，但攻击者无法触发不安全行为。`类型 B`：包含这些缺陷的智能合约可能导致主要的意外行为。攻击者可以触发不安全行为，但无法通过利用这些缺陷获利。

“严重”代表合约缺陷可能导致崩溃、被攻击者控制或丢失所有以太币。“主要”代表合约缺陷可能导致部分以太币的丢失[11]。

#### 智能合约缺陷的示例

(1) `交易状态依赖性 (TSD)`：合约需要检查调用者是否具有执行某些敏感权限函数的正确权限。权限检查失败可能会导致严重后果。`tx.origin`可以获取交易的原始地址，但由于该方法返回的地址取决于交易状态，因此这种方法不可靠。因此，不应使用`tx.origin`来检查调用者是否有权执行函数。

`示例`：在列表 1 中，攻击者合约可以通过使用`attack`函数（第 9 行）进行权限检查失败。通过这种方法，任何人都可以执行`sendMoney`函数（第 3 行）并提取合约中的以太币。

```
contract Victim {
    address owner = owner_address;
    function sendMoney(address addr){
        require(tx.origin == owner);
        addr.transfer(1 Ether);
    }
}
contract Attacker {
    function attack(address vim_addr, address myAddr){
        Victim vic = Victim(vim_addr);
        vic.sendMoney(myAddr);
    }
}
```

`可能的解决方案`：Solidity 提供`msg.sender`来获取发送者地址，可以用来代替`tx.origin`来检查权限。

(2) `外部影响下的拒绝服务 (DuEI)`：智能合约将在运行期间检测到异常时回滚交易。如果导致异常的错误无法修复，该函数将会导致服务拒绝（DoS）错误。

`示例`：列表 2 显示了这样的示例。`members`是存储多个地址的数组。然而，其中一个地址是攻击者合约，转账功能可能触发`out-of-gas`错误，因为 2300 gas 的限制[2]。此时，智能合约状态会回滚。由于代码无法修改，合约无法从`members`列表中移除攻击者地址，这意味着如果攻击者不断攻击，下面的功能将无法正常工作。

```
for(uint i = 0; i < members.length; i++){
    if(this.balance > 0.1 ether)
        members[i].transfer(0.1 ether);
}
```

`可能的解决方案`：开发者可以使用布尔值检查代替在循环中抛出异常。例如，在列表2的第3行中使用`if(members[i].send(0.1 ether) == false) break;`。

(3) `严格余额质量 (SBE)`：攻击者可以通过强制使用`selfdestruct()`[6]向任何合约发送以太币。此方法不会触发回退函数，这意味着受害合约无法拒绝这些以太币。因此，智能合约的逻辑可能因攻击者发送的意外以太币而无法工作。

`示例`：列表 3 中的`doingSomething()`函数仅在余额状态等于 1 ETH 时触发。然而，攻击者可以向合约发送 1 Wei（1 ETH = 1e18 Wei），导致余额不再等于 1 ETH。

```
if(this.balance == 1 ether) doingSomething();
```

`可能的解决方案`：合约可以使用`>=`来代替`==`，因为攻击者只能添加余额。在这种情况下，攻击者难以影响程序的逻辑。

(4) `重入漏洞 (RE)`：在以太坊中，可以通过`Call`方法在一次执行中多次调用函数。当合约调用另一个合约时，调用会等待调用完成[20]。因此，在某些情况下可能导致多次调用和资金转移。

`示例`：列表 4 显示了一个重入漏洞的示例。这里有两个智能合约，即`Victim`合约和`Attacker`合约。`Attacker`合约用于从`Victim`合约中转移以太币，`Victim`合约可以看作银行，用户可以通过调用`withdraw()`函数提取以太币。

```
contract Victim {
    mapping(address => uint) public userBalance;
    function withdraw() {
        uint amount = userBalance[msg.sender];
        if(amount > 0){
            msg.sender.call.value(amount)();
            userBalance[msg.sender] = 0;
        }
    }
}
contract Attacker {
    function() payable {}
    Victim victim;
    function reentry(address addr){
        victim = Victim(addr);
        victim.withdraw();
    }
}
```

`可能的解决方案`：以太坊中有三种`Call`方法可用于发送以太币，即`address.send()`、`address.transfer()`和`address.call.value()`。`address.send()`和`address.transfer()`将更改最大gas限制为2300 gas单位，如果接收者是合约账户，则2300 gas单位不足以传输以太币，这意味着这两种方法不能导致重入漏洞。因此，使用`address.send()`和`address.transfer()`代替`address.call.value()`可以避免重入漏洞。

(5) `嵌套调用 (NC)`：`CALL`指令非常昂贵（9000 gas用于非零值传输作为`CALL`操作的一部分）[2]。如果循环包含`CALL`指令但未限制循环迭代次数，总gas费用可能有很大风险超过其gas上限。

`示例`：在列表5中，如果我们不限制循环迭代次数，攻击者可以恶意增加其大小，导致`out-of-gas`错误。一旦发生`out-of-gas`错误，此功能将无法再工作，因为无法减少循环迭代次数。

```
for(uint i = 0; i < member.length; i++){
    member[i].send(1 wei);
}
```

`可能的解决方案`：开发人员应估算最大循环迭代次数并限制循环迭代次数。

(6) `贪婪合约 (GC)`：智能合约中的以太币只能通过向其他账户或使用`selfdestruct`发送以太币进行提取。否则，智能合约的创建者甚至无法提取以太币，这些以太币将永远锁定。因此，如果合约可以接收以太币（包含可支付函数）但没有方法转移给其他人，则称该合约为贪婪合约。

`示例`：列表6是一个贪婪合约。该合约包含一个可支付的回退函数（第2行），可以接收以太币，但合约中没有任何方法提取以太币。

```
contract Greedy {
    function() payable {}
    function process(address addr) {...}
}
```

`可能的解决方案`：如果合约可以接收以太币，应添加一个函数以提取这些以太币。

(7) `未检查的外部调用 (UEC)`：Solidity 提供了多种函数（`address.send()`、`address.call()`）用于在合约之间转移以太币或调用函数。然而，这些与调用相关的方法可能会失败，例如出现网络错误或`out-of-gas`错误。当错误发生时，这些函数会返回布尔值但从不抛出异常。如果调用者不检查外部调用的返回值，他们无法确保以下代码逻辑正确执行。

`示例`：列表7显示了这样一个示例。第1行没有检查`address.send()`的返回值。当以太币转账失败时，第1行无法确保以下代码逻辑的执行是否正确。

```
address.send(ethers);
doingSomething(); //bad
if(address.send(ethers)) doingSomething(); //good
```

`可能的解决方案`：始终检查`address.send()`和`address.call()`的返回值。

(8) `区块信息依赖性 (BID)`：开发者可以利用一系列与区块相关的函数来获取区块信息。例如，`block.blockhash`用于获取当前区块的哈希值。许多智能合约依赖这些函数来决定程序的执行，例如生成随机数。然而，矿工可以影响区块信息，例如矿工可以将区块时间戳延迟约900秒[20]。在这种情况下，区块信息依赖操作在一定程度上可以被矿工控制。

`示例`：列表8中的合约是一个轮盘合约。该合约使用区块哈希值来选择获胜者，并向获胜者发送1个以太币作为奖励。然而，矿工可以控制结果，因此矿工可以始终成为赢家。

```
address[] participators;
uint winnerID = uint(block.blockhash) % participators.length;
participators[winnerID].transfer(1 ether);
```

`可能的解决方案`：安全随机数的前提是该随机数不能被单个用户控制，例如矿工。在以太坊中，我们可以使用完全随机的信息，包括用户地址、用户的输入数字等。此外，隐藏合约使用的值以及其他玩家避免攻击也是很重要的。由于我们无法隐藏以太坊中用户及其提交的值，一种可能的解决方案是使用哈希数来生成随机数。该算法有三个回合：

- `回合 1`：用户获得一个随机数并在本地机器上生成一个哈希值。该哈希值可以通过`keccak256`函数生成，确保信息保密。
- `回合 2`：所有用户提交哈希值后，用户需要提交原始的随机数。合约通过使用相同的`keccak256`函数检查是否可以通过原始数生成相同的哈希值。
- `回合 3`：如果所有用户提交正确的原始数，合约可以使用原始数来生成随机数。

## 缺陷检测器方法

### 设计概述

图 1 展示了缺陷检测器（DefectChecker）方法的总体架构。DefectChecker 包含四个组件，即输入器（Inputter）、CFG 构建器（CFG Builder）、特征检测器（Feature Detector）和缺陷标识器（Defect Identifier）。

<p style="text-align:center"><img src="./1.jpg" alt="bug"/></p>

<p style="text-align:center">图 1. DefectChecker 的总体架构</p>

图左侧的部分是输入器，用户可以将字节码作为输入提供。也允许使用 Solidity 源代码，但需要先将其编译为字节码。字节码会通过 Geth 提供的 API 被分解为操作码 [21]。然后，DefectChecker 将操作码拆分为几个基本块，并在每个块中进行符号执行以分析指令。之后，DefectChecker 生成智能合约的控制流图（CFG）并记录所有的栈事件。符号执行期间，特征检测器会检测出三个特征（即，资金调用、循环块和可支付函数），这些都是基础概念。基于这些信息，缺陷标识器使用八个不同的规则来识别智能合约中的缺陷。

通过字节码检测合约缺陷对于以太坊上的智能合约来说非常重要。所有智能合约的字节码都存储在区块链上，但只有不到 1% 的智能合约公开了其源代码 [22]。智能合约通常会调用其他合约，但被调用的合约可能并未公开其源代码供检查。在这种情况下，调用方智能合约只能通过字节码来检测被调用的合约是否安全。

### 基本块构建器

一个基本块是一个线性的代码序列，在入口处只有一个分支，在出口处没有分支 [23]。我们首先将操作码分割为多个块，并根据块的出口类型来确定其类型。出口类型可以通过块中的最后一条指令来决定。如果最后一条指令是 JUMP 或 JUMPI，那么块类型分别为无条件或条件块。如果最后一条指令是终止指令（STOP、REVERT 和 RETURN），则该块类型为终止块。一些块不属于这三种类型，我们称它们的块类型为 fall。总结来说，我们考虑四种块类型：无条件、条件、fall 和终止。

### 符号执行

与其他基于栈的机器不同，例如 Java 字节码在 JVM 中的每次跳转都有明确定义的目标位置，EVM 字节码的跳转位置需要在符号执行过程中计算。因此，DefectChecker 需要逐条符号执行每条 EVM 指令，以获得智能合约的控制流图（CFG）。EVM 是一种基于栈的机器——执行指令时，它会从 EVM 栈顶读取几个符号状态，并将符号结果放回 EVM 栈。在符号执行过程中，我们可以获得块之间的跳转关系。根据跳转行为，将块分为三种类型，即条件跳转、无条件跳转和 fall 执行。栈事件（Stack Event）记录每条指令执行后 EVM 栈中的所有符号状态。

<p style="text-align:center"><img src="./2.jpg" alt="bug"/></p>

<p style="text-align:center">图 2. 显示了符号执行的示例</p>

```solidity
function example(uint num) returns(uint){
    if(num > 10)
        return 1;
    else{
        return 0;
    }
}
```

图 2 是清单 9 中代码的符号执行示例。在此图中共有 4 个块，每个块包含若干指令。块 1 中的指令表示代码 `if(num > 10)`。块 2 和块 3 将值（0 或 1）放入 EVM 栈中。块 4 中的指令用于向环境返回值（0 或 1）。每个行号左侧的数字表示指令的索引 ID，中间部分是需要执行的指令。所有指令将按其索引 ID 顺序依次执行。如果指令是 `PUSH`，右侧会显示一个值，将该值推入 EVM 栈中。程序计数器（PC）记录当前时间下要执行的指令 ID。PC 从块 1 的 ID 0 开始，EVM 执行该指令。

图 2 中展示的示例代码是合约代码的一部分，因此 PC 从块 1 的 ID 130 开始。在 EVM 执行指令 `JUMPDEST` 之前，函数输入参数 `num` 已被推入 EVM 栈。符号 `num` 代表函数的输入值（清单 9 的 L1 行）。`JUMPDEST` 标记了一个有效的跳转位置；它不读取或推送任何值。因此，当 PC 指向 ID 131 时，EVM 向栈中推入值 0，并将 PC 指向 135。`DUP3` 复制栈中第三个位置的值，因此符号 `num` 被推入 EVM 栈。接下来，`GT` 指令从 EVM 栈中读取两个值。如果栈顶的第一个值大于第二个值，则 EVM 将 1 推入栈；否则，将 0 推入栈。我们用符号 `GT(a, num)` 表示结果，并将该值推入 EVM 栈中。`JUMPI`（ID 140）从栈中读取两个值，第一个值代表跳转位置 "148"，第二个值为条件表达式。如果条件表达式的结果为“1”（true），则 PC 跳转到 ID 148，开始执行块 2。否则，如果结果为“0”（false），EVM 则执行块 3 的指令，继续执行到 ID 141（块 3 的起始位置）。

由于 `ISZERO(GT(a, num))` 的结果可能是“0”或“1”，此符号执行生成了两个路径，即块 1 -> 块 2 和块 1 -> 块 3。

首先假设 `ISZERO(GT(a, num))` 的结果为“1”，此时路径为块 1 -> 块 2。在这种情况下，PC 指向 ID 148。此路径的跳转类型为条件跳转。在执行 ID 148-152 的指令后，EVM 将跳转到块 4。块 2 到块 4 的跳转类型为 fall。块 4 的第一个指令将两个值（即 `num` 和 0）压入 EVM 栈中。块 4 使用指令 `STOP` 终止执行。

我们再假设 `ISZERO(GT(a, num))` 的结果为“0”，此时路径为块 1 -> 块 3。在这种情况下，PC 指向 ID 141，此路径的跳转类型为 fall。它从栈顶读取一个值。指令 `JUMP` 将 PC 指向 ID 153（块 4 的起始位置）。EVM 执行块 4 的指令，使用 `STOP` 终止执行。

在执行条件跳转时，我们需要确定条件表达式的可满足性，这通常是通过调用 SMT（可满足性模块理论）求解器 [24]，例如 Z3 [25]。如果 SMT 求解器找不到解，我们将此程序路径视为不可行。因此，符号执行可用于发现死代码。然而，EVM 字节码中可能几乎没有死代码，因为编译器会在智能合约编译期间消除死代码。为加速分析，我们将等于“0”的条件表达式视为不可满足，并将所有其他条件表达式视为可满足，而不检查其可满足性。

### 特征检测器

为了在字节码级别检测合约缺陷，我们需要从操作码中识别出一些特定的行为。在本节中，我们介绍用于检测合约缺陷的三个特征。

#### 资金调用

为了检测重入攻击（Reentrancy），我们需要识别智能合约是否可以向其他合约转移以太币。以太坊提供了三种转移以太币的方法，即 `address.send()`、`address.transfer()` 和 `address.call().value()`。这三种方法都会生成一个 `CALL` 指令。然而，仅仅检测 `CALL` 指令是不够的，因为其他许多行为也可能生成 `CALL` 指令，例如，调用其他合约或库中的函数。在本文中，如果 `CALL` 指令是由用于转移以太币的函数生成的，我们称此 `CALL` 指令为资金调用（Money-CALL）。否则，`CALL` 指令为非资金调用（No-Money-CALL）。`CALL` 指令会从 EVM 栈中读取七个值。前三个值分别代表 gas 限制、接收者地址和转移金额。如果转移金额大于 0，则该 `CALL` 指令为资金调用（Money-CALL）。

然而，仅检测资金调用（Money-CALL）仍然不够，因为 `address.send()` 和 `address.transfer()` 将 gas 消耗限制为 2300，这不足以转移以太币。因此，这两种方法也无法引发重入攻击。如果 `CALL` 指令是由 `address.send()` 和 `address.transfer()` 生成的，则一个特定值 "2300" 会被推入 EVM 栈，代表最大 gas 消耗。因此，如果 `CALL` 指令读取了一个特定值 "2300" 且来自 EVM 栈，则该 `CALL` 指令是由 `address.send()` 和 `address.transfer()` 生成的。我们称此 `CALL` 指令为有限 gas 资金调用（Gas-Limited-Money-CALL）。否则，如果第一个读取的值不是特定值 "2300"，我们假定该 `CALL` 指令是由 `address.call().value()` 生成的。我们称此 `CALL` 指令为无限 gas 资金调用（Gas-Unlimited-Money-CALL）。

#### 循环块

在构建控制流图（CFG）后，我们需要检测哪个块是循环的起始块，以及哪些块构成循环体。为了检测这些信息，我们首先通过深度优先搜索（DFS）[26] 遍历控制流图的路径，并标记我们访问的所有块。如果有一个块已经被访问过，那么该块就是循环的起始块，而循环中的其他块则构成循环体。由于一些智能合约非常复杂，可能包含大量路径。为了减少计算量，我们采用了修剪策略。例如，块 A 是许多其他块的目标，并且我们发现块 A 的路径不包含任何循环。因此，当其他路径遇到块 A 时，我们不需要访问剩余的路径。

#### 可支付函数

只有包含可支付函数的智能合约才能接收以太币 [2]。为了检测一个函数是否可支付，我们可以检查每个函数的第一个块。`CALLVALUE` 指令用于获取接收到的以太币数量。如果智能合约接收到以太币，`CALLVALUE` 指令将获得一个非零值。可以通过 `ISZERO` 指令检查此值，以判断交易是否包含以太币。如果函数不可支付，在接收以太币时会抛出异常并终止执行。

为了找到第一个块，我们首先按索引 ID 对所有指令进行排序。所有在第一个 `JUMPDEST` 指令之前的条件跳转都是每个函数的起始位置。EVM 使用哈希值来识别函数；当 EVM 接收到一个函数调用时，它首先将接收到的值与每个函数的哈希值进行比较。如果某个函数的哈希值等于接收到的哈希值，它将跳转到目标位置，这表明这是该函数的起始位置。否则，它将进入回退函数（fallback function），其起始位置是第一个 `JUMPDEST` 指令。

### 缺陷检测器（DefectChecker）

表 2 描述了检测每种合约缺陷所需的信息。为了检测 TSD 和 UEC，DefectChecker 只需要符号执行生成的符号状态，因为我们只需要检查 `ORIGIN` 和 `CALL` 指令是否分别被 `EQ` 和 `ISZERO` 指令读取。DefectChecker 只需要控制流信息来检测 BID，因为我们只需检查条件表达式中是否包含区块相关指令，例如 "BLOCKHASH"。

<p style="text-align:center">表2：检测每种合约缺陷所需的信息</p>

|          合约缺陷           | 控制流信息 | 符号状态 |
| :-------------------------: | :--------: | :------: |
|    交易状态依赖性 (TSD)     |            |    ✓     |
| 外部影响下的拒绝服务 (DuEI) |     ✓      |    ✓     |
|    严格余额相等性 (SBE)     |     ✓      |    ✓     |
|        重入攻击 (RE)        |     ✓      |    ✓     |
|        嵌套调用 (NC)        |     ✓      |    ✓     |
|        贪婪合约 (GC)        |     ✓      |    ✓     |
|   未检查的外部调用 (UEC)    |            |    ✓     |
|    区块信息依赖性 (BID)     |     ✓      |          |

为了检测其他 5 种合约缺陷，DefectChecker 需要控制流信息和符号状态。在上一小节中，我们介绍了由特征检测器检测的三个特征，即资金调用（Money Call）、循环块（Loop Block）和可支付函数（Payable function）。资金调用需要符号状态，因此要检测它，DefectChecker 需要检查 EVM 栈中的值。循环块和可支付函数需要控制流信息，因为它们都需要 CFG 来定位循环和函数的起始位置。NC、DuEI、GC 和重入攻击都需要检测资金调用。DuEI 和 NC 还需要检测循环块；GC 需要检测可支付函数。要检测重入攻击，DefectChecker 需要遍历包含无限 Gas 的资金调用的所有路径，这需要 CFG 的帮助。要检测 SBE，DefectChecker 需要检查条件表达式中 `BALANCE` 指令是否被 `EQ` 指令读取，这需要控制流信息和符号状态。

以下描述了用于确定智能合约是否包含一种或多种合约缺陷的详细模式。

#### 交易状态依赖性（Transaction State Dependency）

`tx.origin` 会生成一个 `ORIGIN` 指令。我们首先定位所有 `ORIGIN` 指令。然后检查是否有被 `EQ` 指令读取的 `ORIGIN`。`EQ` 指令从 EVM 栈中读取两个值，并验证这两个值是否相等。如果合约包含这种类型的合约缺陷，`ORIGIN` 指令将会与一个地址值进行比较。以太坊使用 40 位的值表示地址，所有地址都符合 EIP55 标准 [27]。

#### 外部影响下的拒绝服务（DoS Under External Influence）

如果智能合约包含此合约缺陷，指令部分会检查资金调用（Money Call）的返回值，然后终止循环。为了检测此合约缺陷，我们首先找到与循环相关的块。然后检查是否存在包含资金调用的块，并且块的类型为条件块，因为它需要检查返回值。然后，该块跳转到一个类型为终止的块。

#### 严格余额相等性（Strict Balance Equality）

这种合约缺陷可能导致部分代码永远不会执行。我们需要检查条件表达式中是否包含相关模式。`BALANCE` 指令用于获取合约的余额。如果 `BALANCE` 指令被 `EQ` 读取，则表示存在严格的余额相等性检查。如果此检查发生在条件跳转表达式中，则表示该合约包含此合约缺陷。

#### 重入攻击（Reentrancy）

`SLOAD` 指令用于从存储中获取值 [2]。它从 EVM 栈中读取一个值（称为 `Slot ID`）并将读取的结果推送回 EVM 栈。以清单 4 为例，受害合约不会在发送以太币之前将攻击合约的余额清零（L7），从而允许攻击合约再次提取以太币。为了检测此合约缺陷，我们首先需要找到包含无限 Gas 资金调用的路径，因为只有这种调用才可能引发重入攻击。然后我们需要获得这些路径上的所有条件表达式。攻击合约通常会在将金额发送给攻击合约之前检查该值，并将此金额从存储中加载。在这种情况下，我们需要检查条件表达式中是否包含 `SLOAD` 指令并获取其 `Slot ID`。如果在执行 `CALL` 指令时该值依然有效且未更新，则表示 `CALL` 指令可以再次执行并引发重入攻击。为了检查存储值是否已更新，我们需要检测同一个 `Slot ID` 是否被 `SSTORE` 指令写入。（`SSTORE` 指令用于将数据保存到存储中。它从 EVM 栈中读取两个值，即 `slot id` 和写入存储的值。）

#### 嵌套调用（Nested Call）

以清单 5 为例，数组 `members` 是一个存储变量，其所有值（包括长度）都存储在存储中。要获取其长度，`SLOAD` 指令会从 EVM 栈中读取其 `Slot ID δ`，该值是存储 `members.length` 的位置。为了检测此合约缺陷，第一步是找到循环的起始块并获取 `Slot ID`。然后，我们需要检查此循环是否限制其大小。如果循环限制其大小，则同一 `Slot ID δ` 会在循环体中再次被读取，该值会与另一个值进行比较。如果智能合约包含一个不限制大小且包含资金调用的循环，则在此合约中检测到嵌套调用缺陷。

#### 贪婪合约（Greedy Contract）

智能合约可以通过资金调用或 `selfdestruct` 函数转移资金。`selfdestruct` 函数生成 `SELFDESTRUCT` 指令。如果智能合约包含可支付函数但没有资金调用或 `SELFDESTRUCT` 指令，则该合约为贪婪合约。

#### 未检查的外部调用（Unchecked External Calls）

外部调用返回一个布尔值。如果合约检查结果，它会生成 `ISZERO` 指令。为了检测此合约缺陷，我们首先定位所有 `CALL` 指令。然后，检查每个 `CALL` 指令是否被 `ISZERO` 读取。如果存在未被 `ISZERO` 检查的 `CALL` 指令，则检测到此合约缺陷。

#### 区块信息依赖性（Block Info Dependency）

检测此合约缺陷类似于严格余额相等性检查。此合约缺陷可能允许矿工控制合约，因为矿工可以更改一些区块信息的值，从而影响条件表达式的结果。如果条件表达式包含区块相关指令，例如 "BLOCKHASH"、"COINBASE"、"NUMBER"、"DIFFICULTY"、"GASLIMIT"，则表示该合约包含此合约缺陷。

以下是您提供的论文内容的翻译，保持注释序号：

## 评估

为了衡量 DefectChecker 的效果，我们基于其在一个开源数据集上的应用结果，并在本节中展示我们的实验结果分析。

### 实验设置

所有实验均在运行 Mac OS 10.14.4、配备 Intel i7 六核 CPU 和 16 GB 内存的 PC 上进行。我们使用 Solidity 0.4.25 作为编译器将源代码编译为字节码，并使用 EVM 1.8.14 将字节码反编译为操作码。

### 数据集

我们用来评估 DefectChecker 的数据集来自我们之前的工作 [11]。我们首先从 Etherscan 抓取了所有 17,013 个开源智能合约。然后，我们从这些合约中随机选择了 600 个合约。我们发现有 13 个智能合约没有任何内容，因此将它们从数据集中移除。最终，我们从 Etherscan 获得了 587 个智能合约。这些合约的代码行数总计 231,098 行，余额总和超过 400 万以太币。

表 3 显示了数据集的一些关键特征，例如代码行数、合约中的函数数量、合约中的指令数量、圈复杂度 [28] 和合约持有的以太币数量。圈复杂度是一个衡量程序复杂度的软件指标，通过分析控制流图（CFG）计算得出。其计算公式为：`E - N + 2P`。E 是 CFG 中的边数，N 是 CFG 中的节点数，P 是 CFG 中的连通分量数。由于 CFG 是连通图，因此 P 总是等于 1，该公式可以简化为：`E - N + 2`。

<p style="text-align:center">表3：数据集的一些特征</p>

| 特征                | 最小值 (Min) | 最大值 (Max) | 平均值 (Mean) | 标准差 (SD) |
| ------------------- | ------------ | ------------ | ------------- | ----------- |
| 代码行数            | 5            | 2,239        | 393.6         | 356.8       |
| 函数数量            | 1            | 174          | 30.1          | 621.6       |
| 指令数量            | 7            | 15,355       | 3,597.3       | 2,523.7     |
| 圈复杂度 (CC)       | 1            | 132          | 30.3          | 22.4        |
| 以太币余额 (Ethers) | 0            | 1,500,000    | 7,844.9       | 1,704,552.7 |

我们数据集中最简单的合约只包含一个构造函数，具有 7 条指令和 1 的圈复杂度。圈复杂度最高的合约包含 11,696 条指令和 2,004 行代码。数据集中余额最高的合约持有 150 万以太币，而余额最低的合约没有任何以太币。

我们之前工作的两位作者手动标注了该数据集。他们都具有三年的智能合约开发和研究经验，并参与了定义合约缺陷的过程，因此对智能合约编程和本文介绍的合约缺陷有很好的理解。他们首先独立手动标注数据集，然后讨论分歧并给出最终结果。其整体 Kappa 值 [29] 为 0.71，表明两者之间具有显著的一致性。

在本研究中，我们开发了一种名为 DefectChecker 的工具，用于检测八种具有影响等级 1-3 的合约缺陷。表 4 显示了我们数据集中每种合约缺陷的数量。结果表明，区块信息依赖性（Block Info Dependency）是我们数据集中最常见的合约缺陷，而交易状态依赖性（Transaction State Dependency）和严格余额相等性（Strict Balance Equality）是最少见的，数量分别为 42、5 和 5。DefectChecker 以 Solidity 版本 0.4.0+ 为目标，这是本文撰写时最广泛使用的版本 [30]。然而，一些智能合约是针对 Solidity 版本 0.2.0+ 和 0.3.0+ 设计的。因此，我们移除了八个智能合约，使用剩下的 579 个智能合约作为我们的基准数据。

<p style="text-align:center">表4：DefectChecker 的实验结果</p>

| 缺陷类型 | 缺陷数量 (#Defects) | 真阳性 (#TP) | 真阴性 (#TN) | 假阳性 (#FP) | 假阴性 (#FN) | 准确率 (P%) | 召回率 (R%) | F值 (F%) |
| -------- | ------------------- | ------------ | ------------ | ------------ | ------------ | ----------- | ----------- | -------- |
| TSD      | 5                   | 5            | 474          | 0            | 0            | 100.0       | 100.0       | 100.0    |
| DuEI     | 6                   | 6            | 466          | 7            | 0            | 46.2        | 100.0       | 63.2     |
| SBE      | 5                   | 4            | 474          | 0            | 1            | 100.0       | 80.0        | 88.9     |
| RE       | 12                  | 10           | 461          | 6            | 2            | 62.5        | 83.3        | 71.4     |
| NC       | 8                   | 7            | 464          | 1            | 2            | 81.8        | 69.2        | 75.0     |
| GC       | 6                   | 6            | 473          | 0            | 0            | 100.0       | 100.0       | 100.0    |
| UEC      | 22                  | 20           | 454          | 3            | 2            | 87.0        | 90.9        | 88.9     |
| BID      | 42                  | 41           | 437          | 0            | 1            | 100.0       | 97.6        | 98.8     |

在我们介绍的六种工具中（见表 5），只有 Zeus 开源了他们的数据集。然而，Zeus 数据集中缺少四种我们定义的缺陷。此外，Zeus 的作者没有提供他们构建数据集的详细信息。其论文只提到“他们手动验证了每个结果”，但没有提供任何细节，例如标注数据集的人员数量及其是否为专业的智能合约开发人员。因此，我们没有使用这些数据集。

<p style="text-align:center">表5：各工具的输入类型和检测的缺陷</p>

| 工具 | 输入类型 | TSD  | DuEI | SBE  | RE   | NC   | GC   | UEC  | BID  | 其他缺陷数量 |
| ---- | -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ------------ |
| DefectChecker | 字节码 | ✓    | ✓    | ✓    | ✓    | ✓    | ✓    | ✓    | ✓    | 0    |
| Oyente [20] | 字节码 | ✓    |      |      | ✓    | ✓    | ✓    | ✓    |      | 1    |
| Maian [31] | 字节码 |      | ✓    |      |      |      | ✓    |      |      | 2    |
| Securify [32] | 字节码 |      |      |      | ✓    | ✓    |      | ✓    |      | 7    |
| Mythril [33] | 字节码 | ✓    | ✓    | ✓    |      | ✓    |      | ✓    | ✓    | 28   |
| Contractfuzzer [34] | 字节码 + ABI |      |      |      | ✓    |      |      | ✓    | ✓    | 3    |
| Zeus [35] | 源代码 | ✓    |      |      | ✓    |      |      | ✓    |      | 3    |

### 评估方法和指标

我们的实验中获得了七个测量值：真阳性（True Positive, TP）、真阴性（True Negative, TN）、假阳性（False Positive, FP）、假阴性（False Negative, FN）、精确率（Precision, P）、召回率（Recall, R）和 F 值（F-Measure, F）。TP 表示正确预测智能合约中存在缺陷的结果。TN 表示正确预测智能合约中不存在缺陷的结果。FP 和 FN 分别表示错误预测智能合约中存在或不存在缺陷的结果。精确率、召回率和 F 值的计算公式如下：
$$
\text{Precision} = \frac{\#TP}{\#TP + \#FP} \times 100\%
$$

$$
\text{Recall} = \frac{\#TP}{\#TP + \#FN} \times 100\%
$$

$$
F\text{ - Measure} = \frac{2 \times \text{Precision} \times \text{Recall}}{\text{Precision} + \text{Recall}} \times 100\%
$$

### 实验结果与分析

表 4 总结了 DefectChecker 在我们之前工作中的数据集上的应用结果。第一列是需要检测的合约缺陷，第二列是我们数据集中合约缺陷的数量（基准真值）。其余七列用于衡量 DefectChecker 的性能。以下是对每种合约缺陷的分析：

（1）**交易状态依赖性（Transaction State Dependency）**。DefectChecker 检测到 5 个包含此合约缺陷的智能合约，共 579 个智能合约，且无假阳性和假阴性。

（2）**外部影响下的拒绝服务（DoS Under External Influence）**。DefectChecker 检测到 13 个包含此合约缺陷的智能合约，共 579 个智能合约，其中 7 个为假阳性，0 个为假阴性。这 7 个错误是由于循环识别错误引起的。

在我们的检测方法中，我们首先将字节码分解为多个块。然后，符号执行用于在块之间找到边。我们使用深度优先搜索（DFS）遍历 CFG 的路径。如果有一个块已被访问，则将其视为循环的起始块（见第 3.4.2 节）。由于我们将所有路径视为可达的，因此只标记两个块是否有边。这种机制导致在检测循环时出现假阳性。

在清单 10 中，L9、L10 和 L11 分别包含一个单独的块，函数 `sub()` 包含多个块。EVM 首先执行 L9 的块，然后执行 L2 中函数 `sub()` 的块。执行完 L10、L11 的块后，将再次执行 `sub()` 函数的块。因此，在使用 DFS 遍历 CFG 时，我们可以找到一个循环（`fun sub()→L10→L11→fun sub()`)。由于我们将所有路径视为可达的，因此无法知道 `sub()` 函数的块在执行完 L11 的块后不会跳转到 L10 的块。

```solidity
library SafeMath {
    function sub(uint256 a, uint256 b) internal
        returns (uint256) {
        assert(b <= a);
        return a - b;
    }
}
contract Mainsale {
    using SafeMath for uint256;
    uint256 public total;
    function() payable {
        uint amount = total.sub(100);
        msg.sender.transfer(amount);
        uint contri = msg.value.sub(amount);
    }
}
```

通过持续执行循环可以解决这种假阳性问题。例如，使用循环 `for(int i = 0; i < 100; i++)`，我们需要记录变量 `i` 的状态值，并检查表达式 `(i < 100)` 是否满足。如果我们证明循环可以持续执行，就可以确认在 Listing 10 中是真正的循环。然而，执行循环需要 SMT 求解器的协助，但执行循环将非常耗时。因此，我们认为在方法中去除 SMT 求解器的优势大于劣势。

（3）**严格余额相等性（Strict Balance Equality）**。DefectChecker 检测到 4 个包含严格余额相等性的智能合约，具有 0 个假阳性和 1 个假阴性。错误的原因在于该合约缺陷涉及多个函数。例如，清单 11 中的合约使用全局变量 `balance` 来表示合约的余额。调用方首先调用 `getBalance` 函数以获取余额，然后在第 5 行检查余额。为了检测此合约缺陷，我们需要知道全局变量 `balance` 表示合约余额。因此，只有在我们知道用户将首先调用 `getBalance()` 然后调用 `DefectFunction()` 时才能检测到该合约缺陷。然而，在字节码级别很难检测到此缺陷，因为这两个操作（例如 `balance == 1 eth` 和 `balance == this.balance`）在两个独立的函数中，我们不知道调用的顺序。

```solidity
contract Demo {
    uint balance = 0;
    function getBalance() { balance = this.balance; }
    function DefectFunction() {
        if (balance == 1 ether)
            doSomething();
    }
}
```

（4）**重入攻击（Reentrancy）**。DefectChecker 检测到 16 个包含重入攻击的智能合约，具有 6 个假阳性和 2 个假阴性。假阳性是由于错误的资金调用检测引起的。智能合约包含重入攻击的必要条件是存在无限 Gas 的资金调用。为了检测该缺陷，我们需要检查 gas 限制是否大于 2300 且转账金额大于 0。然而，在一些例子中，这两个值由复杂的符号表达式表示。某些表达式还包含从存储中读取的值（通过 `SLOAD`）。因此，通过静态分析无法确定这些值的具体值。当 DefectChecker 遇到复杂的符号表达式时，默认值是大于 2300 的 gas 和大于 0 的转账金额，这导致假阳性。

在检测重入攻击缺陷时，我们需要检查由 `SLOAD` 读取的 `Slot ID` 是否在执行 `CALL` 指令时仍保持不变。某些 `Slot ID` 也由复杂的符号表达式表示。DefectChecker 无法检测它们是否相等，从而导致报告假阴性。

当检测到资金调用时，我们将 `Gas-Limited-Money-Call` 作为默认值，如果无法通过符号推导出 gas 限制的具体值。我们还进行了另一个实验，将 `Gas-Limited-Money-Call` 作为默认值。然而，DefectChecker 未能检测到任何重入攻击。原因是 `Gas-Limited-Money-Call` 通常很容易检测，例如 `address.transfer()` 和 `address.send()` 会将特定值 "2300" 推送到 EVM 栈中。因此，我们只需检测特定值即可。然而，`Gas-Unlimited-Call` 的 gas 限制很难检测，因为它通常使用复杂的表达式来表示 gas。由于 `address.call.value()` 不会更改 gas 成本，因此在大多数情况下不会导致超出 gas 的错误。这就是我们将 `Gas-Unlimited-Call` 用作默认值的原因。

（5）**嵌套调用（Nested Call）**。DefectChecker 检测到 11 个包含嵌套调用缺陷的智能合约，其中 2 个为假阳性，4 个为假阴性。假阳性的原因也是循环识别错误，与外部影响下的拒绝服务类似。假阴性是由于复杂数据结构引起的。在检测此合约缺陷时，第一步是知道循环迭代是否与数组的长度相关。我们使用 `SLOAD` 指令来获取数组的长度，如第 3.5.5 节所述。然而，如清单 12 所示，`self` 是一个结构体，其长度通过外部函数获得。由于外部函数可以以不同方式设计，检测该模式具有挑战性。

```solidity
for (uint i; i < self.keys.length; i++) {
    self.data[self.keys[i]].transfer(1 Ether);
}
```

（6）**贪婪合约（Greedy Contract）**。DefectChecker 检测到 6 个贪婪合约，具有 0 个假阳性和假阴性。

（7）**未检查的外部调用（Unchecked External Call）**。DefectChecker 报告 23 个合约具有此类缺陷，具有 3 个假阳性和 2 个假阴性。我们分析了假阳性示例，发现这些合约将 `send()` 的返回值用作函数的返回值，并在其他函数中检查返回值。例如，清单 13 中的 `addr.send()` 是 `Example` 函数的返回值，并在调用程序中检查该值。假阴性是因为缺陷出现在构造函数中，而构造函数的字节码在运行时字节码中不包含。因此，我们未能检测到它。然而，构造函数中的合约缺陷不会影响已部署的合约，因为构造函数仅在将合约部署到区块链时执行。

 ```solidity
 function Example(Address addr) returns (bool) {
     return addr.send();
 }
 ```

（8）**区块信息依赖性（Block Info Dependency）**。DefectChecker 检测到 41 个包含此缺陷的智能合约，具有 0 个假阳性和 1 个假阴性。假阴性的原因类似于严格余额相等性。该缺陷合约使用全局变量来表示区块信息，并在其他函数中使用该全局变量，从而导致检测到该合约缺陷。

### 与最先进工具的比较

在我们之前的工作中，我们调查了是否存在可以检测我们定义的合约缺陷的现有工具。首先，我们从顶级安全和软件工程会议/期刊（例如 CCS、S&P、USENIX Security、NDSS、ACSAC、ASE、FSE、ICSE、TIFS 和 TOSEM）中收集了 2016 年至 2019 年的所有论文。然后，我们只保留了标题中包含关键字“智能合约”、“以太坊”或“区块链”的论文。接着，我们手动阅读摘要以验证其相关性。最终，我们只发现了四篇与智能合约缺陷检测相关的论文，即 Oyente [20]、Maian [31]、Zeus [35] 和 ContractFuzzer [34]。

为了扩大我们的基准方法，我们采用 Kitchenham 等人 [36] 提出的参考文献方法。我们首先阅读这 4 篇相关论文的参考文献，并尝试找出是否存在可以检测定义的合约缺陷的工具。如果找到相关论文，我们会重复此过程，直到没有新的论文可以找到。通过这种方法，我们还发现了另外两个工具，即 Securify [32] 和 Mythril [33]。

表 5 显示了这些工具可以检测的缺陷类型。最后一列显示了除前述 8 个合约缺陷外还可检测的缺陷数量。正如我们所知，以太坊上的智能合约在部署后，其字节码是可见的，而源代码则不一定可见 [22]。因此，从字节码中检测合约缺陷非常重要。为了保证比较的公平性，我们选择了 Oyente、MAIAN、Securify 和 Mythril 作为我们的基准工具，因为它们可以在字节码级别检测缺陷，与 DefectChecker 一致。然而，我们发现 MAIAN 尚未更新以支持最新的以太坊环境，因此无法在我们的数据集中运行 MAIAN。
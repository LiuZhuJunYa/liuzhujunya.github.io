---
title: DefectChecker：基于EVM字节码分析的智能合约缺陷检测自动化
date: 2024-10-30
tags: 
  - 静态代码分析
  - 区块链
  - 智能合约
  - 以太坊
  - 合约缺陷检测
  - 字节码分析
  - 符号执行
categories: 
  - 论文阅读
---

# DefectChecker：基于 EVM 字节码分析的智能合约缺陷检测自动化

## 摘要

智能合约是在区块链上运行的图灵完备程序。它们是不可变的，一旦部署后即便发现错误也无法修改。因此，在将智能合约部署到区块链之前，确保其无错误且设计完善极为重要。合约缺陷是指智能合约中的错误、缺陷或漏洞，这些问题可能导致合约产生错误或意外结果，或者因意外行为而无法正常工作。检测和消除合约缺陷可以避免潜在的攻击，增强程序的鲁棒性。我们之前的工作定义了 20 种智能合约缺陷，并将其分为五个影响级别。根据我们的分类，从 1 到 3 级的缺陷可能导致不安全行为，例如合约被攻击者控制。在本文中，我们提出了一种名为`DefectChecker`的工具，它基于符号执行的方法来检测以太坊区块链平台上智能合约的缺陷。`DefectChecker`可以从智能合约的字节码中检测出缺陷。我们通过将其应用于一个开源数据集来验证`DefectChecker`的性能。评估结果显示，`DefectChecker`在整个数据集中的 F-score 很高（88.8%），并且平均分析一个智能合约只需 0.15 秒。我们还将`DefectChecke`应用于以太坊平台上的 165,621 个智能合约，结果发现有 25,815 个智能合约至少包含一个属于 1 到 3 级影响的缺陷，其中包括一些真实的攻击案例。

`索引术语`——智能合约，以太坊，合约缺陷检测，字节码分析，符号执行

## 引言

近年来，去中心化加密货币引起了广泛关注。为了确保这些系统在没有中心化组织管理的情况下仍然具有可扩展性和安全性，去中心化加密货币采用区块链概念作为其基础技术。比特币[1]是第一个数字货币，它允许用户通过编码脚本自动处理交易。然而，比特币中的脚本不是图灵完备的，这限制了它们在货币转账或支付等应用上的能力。为了应对这一限制，以太坊[2]引入了一种名为智能合约的技术，这是一种在区块链上运行的图灵完备程序。通过利用该技术，实践者可以开发去中心化应用程序（DApps）[3]，并将区块链技术应用于游戏[4]和金融[5]等不同领域。

智能合约通常使用高级编程语言编写，例如Solidity[6]。当开发者将智能合约部署到以太坊时，合约首先会被编译为以太坊虚拟机（EVM）字节码。然后，以太坊系统中的每个节点都会接收到智能合约的字节码并在其分类账中保留一个副本。任何人，包括攻击者，都可以通过向相应的合约地址发送交易来调用该智能合约。

智能合约的关键特性使其成为黑客的有吸引力目标[7]。一方面，许多智能合约持有有价值的以太币，且无法隐藏其余额，这为黑客提供了经济动机[8]，[9]。另一方面，智能合约在无权限网络中运行，这意味着黑客可以自由地检查所有交易和字节码，并尝试找到合约中的漏洞。更糟的是，智能合约一旦部署，即便发现了错误也无法修改。因此，在将智能合约部署到以太坊之前，确保其无错误且设计完善至关重要。

合约缺陷[10]，[11]是指导致智能合约产生不正确或意外结果，或以意外方式行为的错误、缺陷或漏洞[12]。检测和消除合约缺陷是避免潜在攻击并改进现有代码设计的方法。在我们之前的工作中[11]，我们通过分析 StackExchange[13]帖子首先定义了 20 种合约缺陷。这也是第一个通过在线调查验证智能合约开发者是否认为这些缺陷有害的工作，这使得定义更具说服力。我们的工作将定义的 20 种合约缺陷分为五个影响级别，结果表明包含 1 到 3 级缺陷的智能合约可能导致不安全行为，例如合约被攻击者控制。

然而，我们之前的工作并未提出一种可以检测这些合约缺陷的合适工具。为了解决这一局限性，本文提出了`DefectChecker`，用于检测我们之前工作中定义的对合约造成严重影响（1 级为高，3 级为中）的缺陷，使用智能合约的字节码进行检测。`DefectChecker`通过字节码进行符号执行，无需源代码支持。在符号执行过程中，`DefectChecke`生成智能合约的控制流图（CFG）以及“堆栈事件”，并识别三种特征，即“资金调用”、“循环块”和“应付函数”。通过使用CFG、堆栈事件和这三种特征，我们设计了相应的规则来检测每种合约缺陷。

我们通过应用到我们之前工作中开发的开源数据集来验证`DefectChecker`的性能[11]。我们还将其结果与三种先进工具（如`Oyente`、`Mythril`和`Securify`）进行比较。评估结果表明，`DefectChecker`在整个数据集中的 F-score 最高（88.8%），并且分析一个智能合约的时间最短（每个合约 0.15 秒），相比其他基线工具。我们还提取了截至 2019 年 1 月部署到以太坊上的所有智能合约字节码，并将`DefectChecker`应用于 165,621 个不同的字节码智能合约。结果发现，以太坊上的智能合约中有 15.9% 至少包含一个属于 1 到 3 级影响的缺陷。

本工作的主要贡献如下：

- 据我们所知，`DefectChecker`是目前最准确且最快的基于符号执行的智能合约缺陷检测工具。
- 我们系统地评估了工具的性能，使用一个开源数据集进行测试。此外，我们还提取了以太坊平台上的所有字节码（165,621个），并确定其中25,815个智能合约包含至少一个缺陷。通过这些分析，我们发现了一些真实世界的攻击案例，并举例说明了检测合约缺陷的重要性。
- 我们的数据集、工具和分析结果已向社区开放：https://github.com/Jiachi-Chen/DefectChecker/。

本文其余部分的组织如下。在第 2 节中，我们提供了智能合约的背景知识，并介绍了带有代码示例的合约缺陷。在第 3 节中，我们介绍了`DefectChecker`的架构，在第 4 节中，我们介绍了其表示和实现。在第 5 节中，我们对在以太坊智能合约上的大规模案例研究进行了评估，并在第 6 节中给出了真实案例作为案例研究。在第 6 节中，我们介绍了相关工作。最后，我们在第 7 节中总结了本研究并讨论了未来可能的工作。

## 背景与动机

在本节中，我们简要介绍了关于智能合约及其合约缺陷的关键背景信息。

### 智能合约

合约。利用区块链技术，智能合约是在区块链上存储的自治协议。一旦启动，合约的运行是自动的，并且按照预先定义的程序逻辑进行[14]。当开发人员将智能合约部署到以太坊时，合约将被编译为 EVM 字节码，并由唯一的 160 位十六进制哈希合约地址标识。智能合约的执行取决于其代码，即使是合约创建者也无法影响其运行或状态。例如，如果合约不包含以太币转账的功能，即使是创建者也无法提取以太币。智能合约运行在无权限网络中，任何人都可以通过 ABI（应用程序二进制接口）[6]调用智能合约的方法。合约字节码、交易和调用参数对所有人都是公开的。

`Gas 系统`。为了确保智能合约的安全性，智能合约的每笔交易都将由所有矿工运行。以太坊使用 gas 系统[15]来衡量其计算工作量，发送交易以调用智能合约的开发人员需要支付执行费用。执行费用的计算方式为：$gas\_cost$ $\times$ $gas\_price$。gas 费用取决于执行所需的计算资源，而 gas 价格则由交易创建者提供。为了限制调用交易的 gas 费用，开发人员会设置 Gas 上限，以确定最大 gas 费用。如果交易的 gas 费用超过了 Gas 上限，则会失败并抛出`out-of-gas`错误[2]。某些特殊操作将会对 Gas 上限设定特定值。例如，`address.transfer()`和`address.send()`是以太坊提供的两种用于转移以太币的方法。如果智能合约使用这些方法向另一个智能合约发送以太币，Gas 上限将限制为 2300 gas 单位[6]。2300 gas 单位不足以进行存储、调用函数或发送以太币，这可能导致交易失败。因此，`address.transfer()`和`address.send()`只能用于向外部账户发送以太币（外部账户指由私钥控制的账户，与合约代码控制的合约账户不同[2]）。

`以太坊虚拟机（EVM）`。为了将智能合约部署到以太坊，其源代码需要编译为字节码并存储在区块链上。EVM 是一种基于堆栈的机器：当需要执行交易时，EVM 会首先将字节码拆分为字节，每个字节表示唯一的指令，称为操作码。截至 2019 年 4 月，共有 140 个唯一的操作码[2]，每个操作码由十六进制编号表示[2]。EVM 使用这些操作码执行任务。例如，考虑一个字节码`0x6070604001`。EVM 首先将该字节码拆分为字节（`0x60`，`0x70`，`0x60`，`0x40`，`0x01`），并执行第一个字节`0x60`，其操作码为`PUSH1`。`PUSH1`将一个字节数据推送到EVM堆栈中。因此，`0x70`被推送到堆栈中。然后，EVM 读取下一个`0x60`并将`0x40`推入堆栈。最后，EVM 执行`0x01`，其操作码为`ADD`。`ADD`从堆栈顶部获取两个值，即`0x70`和`0x40`，并将它们的和（`B0`）推入堆栈。

`EVM 字节码与控制流分析中的 JVM 字节码`。控制流分析方法在其他基于堆栈的机器（例如 JVM[16]）中被广泛使用。然而，JVM 字节码与 EVM 字节码之间存在一些差异。这些差异在分析 EVM 字节码时提出了一些新的挑战。我们在本文中强调了 EVM 字节码分析方法与 JVM 字节码分析的关键差异，包括：

（1）JVM 字节码在不同的控制流路径下具有固定的堆栈深度。而 EVM 无法在具有不同堆栈大小的情况下到达同一程序点[17]。EVM 字节码没有这种约束，这大大增加了识别 EVM 字节码中控制流结构的难度。例如，对于简单的递归代码“`function f(int a){f(a);}`”，其在 EVM 中的代码如下：

```
Block 1:
  JUMPDEST
  PUSH Block1' ID
  DUP2
  PUSH Block2' ID
  JUMP
Block 2:
  JUMPDEST
```
存在两个代码块；两个块标识符在相同的块（块1）中被推入，并将由相同的指令`JUMP`读取。JVM 和 EVM 的区别在于，JVM为每个方法调用创建一个新的操作数栈[18]，而 EVM 只有一个全局操作数栈。（帧用于存储数据和部分结果，也用于执行动态链接、方法返回值和调度异常）。

（2）JVM 字节码为每个跳转定义了明确的目标集[19]。相比之下，EVM 字节码的跳转目标从 EVM 堆栈中读取。当使用条件跳转时，目标将受堆栈第二项影响。例如，在图 2 中，跳转目标`JUMPI`（ID 140）从先前的指令`PUSH`读取，并将受堆栈第二项（例如，`ISZERO(GT(10, num))`）的影响。如果第二项为真值，则跳转目标为 148；否则，目标为 141。无条件跳转目标也从 EVM 堆栈顶部读取。例如，图 2 中的`JUMP`（ID 147）的跳转目标也从之前的指令`PUSH`读取。因此，我们需要通过符号执行 EVM 字节码来构造控制流边。

（3）JVM 字节码有明确的方法调用和返回指令[17]。相比之下，EVM 字节码使用跳转来执行合约内部的函数调用。在这种情况下，为了解析合约内部的函数调用，我们需要检查堆栈顶部元素以确定跳转目标。例如，假设有两个函数 A 和 B。函数 A 包含三个块，例如 A1、A2 和 A3；函数 B 包含两个块，例如 B1 和 B2。代码块 B2 调用函数 B 中的代码块 B1。在 EVM 字节码中，没有定义的方法调用和返回指令。相反，EVM 将返回地址推入堆栈中；调用方的块标识符（B1 的块 ID）需要通过字节码识别。为了返回，代码将从 EVM堆栈顶部读取调用者的块标识符（A3），然后跳转执行块。因此，执行序列为 A1、A2、B1、B2、A3。块 B1 和 A3 的标识符需要从字节码中获得以确定跳转目标。

`Fallback函数`。Fallback函数是智能合约相较于传统程序的一项独特特性。在智能合约编程中，Fallback函数是唯一没有命名的函数[6]。当交易调用合约中的某个函数但没有找到对应的函数时，Fallback函数将被自动执行。如果函数被标记为`payable`[6]，则在收到以太币时Fallback函数也会自动执行。

`CALL 指令和以太币转移`。以太币转移是以太坊中的一个重要功能。在 Solidity 编程中，有三种方法用于转移以太币，即`address.call.value()`，`address.transfer()`，和`address.send()`。在这三种方法中，只有`address.call.value()`允许用户将以太币发送到合约地址，而其他两种方法限制为 2300 gas 单位，这不足以发送以太币。`address.send()`返回一个布尔值，而`address.transfer()`在错误发生时抛出异常。这三种方法都可以在合约字节码中生成`CALL`指令。其他行为（例如函数调用）也可以生成`CALL`指令。`CALL`指令从 EVM 堆栈顶部读取七个值。它们代表 gas 限制、接收地址、转移金额、输入数据起始位置、输入数据大小、输出数据起始位置和输出数据大小。

### 智能合约中的合约缺陷

我们之前的工作[11]定义了 20 种智能合约的缺陷。我们将这些缺陷分为五个“影响”级别；在这些缺陷中，11 种属于影响级别 1（最严重）到 3（中等严重性），可能导致不安全行为。表 1 中给出了这些 11 种缺陷的定义。在本文中，我们提出了`DefectChecker`，一种符号执行工具，用于检测这些影响级别中的八个合约缺陷。`DefectChecker`不检测属于影响级别 4 和 5 的缺陷，因为这些缺陷不会影响智能合约的正常运行。例如，未指定编译器版本是五个最严重缺陷之一。消除该缺陷需要合约开发人员在合约中指定特定的编译器版本（如 0.4.25）。该缺陷不会影响合约的正常运行，仅对未来代码的重用构成威胁。这种缺陷很难通过字节码级别检测，因为语义信息在编译后丢失。

<p style="text-align:center">表1：影响级别为 1 - 3 的合约缺陷定义</p>

| 合约缺陷                    | 定义                                                       | 影响级别 |
| --------------------------- | ---------------------------------------------------------- | -------- |
| 交易状态依赖性 (TSD)        | 使用`tx.origin`检查权限                                    | IP1      |
| 严格余额质量 (SBE)          | 使用严格的余额质量来确定执行逻辑                           | IP2      |
| 嵌套调用 (NC)               | 在无限长度的循环中执行`CALL`指令                           | IP2      |
| 未检查的外部调用 (UEC)      | 不检查外部调用函数的返回值                                 | IP3      |
| 类型不匹配赋值              | 分配不匹配的类型值，可能导致整数溢出                       | IP2      |
| 硬编码地址                  | 在智能合约中使用硬编码地址                                 | IP3      |
| 外部影响下的拒绝服务 (DuEI) | 在可能受到外部用户影响的循环中抛出异常                     | IP2      |
| 重入漏洞 (RE)               | 重入攻击漏洞                                               | IP1      |
| 贪婪合约 (GC)               | 合约可以接收以太币但无法提取                               | IP3      |
| 区块信息依赖性 (BID)        | 使用与区块信息相关的函数来确定执行逻辑                     | IP3      |
| 数据位置误导                | 本地变量的引用类型（如`struct`、`array`或`mapping`）未明确 | IP2      |

`注：前八种合约缺陷可以通过 DefectChecker 检测`

然而，请注意，在本研究中，我们未考虑属于影响级别 1 到 3 的三种合约缺陷——类型不匹配赋值、硬编码地址和数据位置误导，因为这些缺陷不易通过字节码级别检测。我们的分析表明，它们分别出现在 22、84 和 587 个智能合约中。编译智能合约为字节码时，这些信息会被删除或丢失，这可能会掩盖源代码中的约束条件。对于硬编码地址，从区块链获取的字节码中不包含关于构造函数的信息，而我们发现大多数硬编码地址错误出现在构造函数中。对于检测类型不匹配赋值，我们需要知道最大循环迭代次数，这通常是从存储中读取的，并且很难通过静态分析获得。例如，对于循环“`for(uint8 i = 0; i < num; i++)`”，`uint8`的范围是 0 到 255。如果`num`大于 255，循环将会溢出。然而，`num`通常是从存储中读取的存储变量或依赖于外部输入。因此，通过字节码分析很难检测到这一缺陷。数据位置误导也不易通过字节码检测。在 Solidity 编程中，`storage`在 Solidity 中不是动态分配的，并且`struct`、`array`或`mapping`类型的数据在存储中维护。因此，这三种类型的数据将导致函数默认指向存储槽 0，这可能导致潜在的漏洞。然而，我们无法知道槽 0 上的指针是正确的还是 EVM 的错误。

#### 影响级别的定义

下面我们给出了八种智能合约缺陷中每种的代表性示例，并根据我们的先前工作引入了影响级别 1 到 3 的定义。

- `影响级别 1 (IP1)`：包含这些缺陷的智能合约可能导致严重的意外行为。攻击者可以利用这些缺陷触发不安全行为，并通过利用这些缺陷获利。
- `影响级别 2 (IP2)`：包含这些缺陷的智能合约可能导致严重的意外行为。攻击者可以利用这些缺陷触发不安全行为，但无法通过利用这些缺陷获利。
- `影响级别 3 (IP3)`：IP3有两种类型。`类型 A`：包含这些缺陷的智能合约可能导致严重的意外行为，但攻击者无法触发不安全行为。`类型 B`：包含这些缺陷的智能合约可能导致主要的意外行为。攻击者可以触发不安全行为，但无法通过利用这些缺陷获利。

“严重”代表合约缺陷可能导致崩溃、被攻击者控制或丢失所有以太币。“主要”代表合约缺陷可能导致部分以太币的丢失[11]。

#### 智能合约缺陷的示例

(1) `交易状态依赖性 (TSD)`：合约需要检查调用者是否具有执行某些敏感权限函数的正确权限。权限检查失败可能会导致严重后果。`tx.origin`可以获取交易的原始地址，但由于该方法返回的地址取决于交易状态，因此这种方法不可靠。因此，不应使用`tx.origin`来检查调用者是否有权执行函数。

`示例`：在列表 1 中，攻击者合约可以通过使用`attack`函数（第 9 行）进行权限检查失败。通过这种方法，任何人都可以执行`sendMoney`函数（第 3 行）并提取合约中的以太币。

```
contract Victim {
    address owner = owner_address;
    function sendMoney(address addr){
        require(tx.origin == owner);
        addr.transfer(1 Ether);
    }
}
contract Attacker {
    function attack(address vim_addr, address myAddr){
        Victim vic = Victim(vim_addr);
        vic.sendMoney(myAddr);
    }
}
```

`可能的解决方案`：Solidity 提供`msg.sender`来获取发送者地址，可以用来代替`tx.origin`来检查权限。

(2) `外部影响下的拒绝服务 (DuEI)`：智能合约将在运行期间检测到异常时回滚交易。如果导致异常的错误无法修复，该函数将会导致服务拒绝（DoS）错误。

`示例`：列表 2 显示了这样的示例。`members`是存储多个地址的数组。然而，其中一个地址是攻击者合约，转账功能可能触发`out-of-gas`错误，因为 2300 gas 的限制[2]。此时，智能合约状态会回滚。由于代码无法修改，合约无法从`members`列表中移除攻击者地址，这意味着如果攻击者不断攻击，下面的功能将无法正常工作。

```
for(uint i = 0; i < members.length; i++){
    if(this.balance > 0.1 ether)
        members[i].transfer(0.1 ether);
}
```

`可能的解决方案`：开发者可以使用布尔值检查代替在循环中抛出异常。例如，在列表2的第3行中使用`if(members[i].send(0.1 ether) == false) break;`。

(3) `严格余额质量 (SBE)`：攻击者可以通过强制使用`selfdestruct()`[6]向任何合约发送以太币。此方法不会触发回退函数，这意味着受害合约无法拒绝这些以太币。因此，智能合约的逻辑可能因攻击者发送的意外以太币而无法工作。

`示例`：列表 3 中的`doingSomething()`函数仅在余额状态等于 1 ETH 时触发。然而，攻击者可以向合约发送 1 Wei（1 ETH = 1e18 Wei），导致余额不再等于 1 ETH。

```
if(this.balance == 1 ether) doingSomething();
```

`可能的解决方案`：合约可以使用`>=`来代替`==`，因为攻击者只能添加余额。在这种情况下，攻击者难以影响程序的逻辑。

(4) `重入漏洞 (RE)`：在以太坊中，可以通过`Call`方法在一次执行中多次调用函数。当合约调用另一个合约时，调用会等待调用完成[20]。因此，在某些情况下可能导致多次调用和资金转移。

`示例`：列表 4 显示了一个重入漏洞的示例。这里有两个智能合约，即`Victim`合约和`Attacker`合约。`Attacker`合约用于从`Victim`合约中转移以太币，`Victim`合约可以看作银行，用户可以通过调用`withdraw()`函数提取以太币。

```
contract Victim {
    mapping(address => uint) public userBalance;
    function withdraw() {
        uint amount = userBalance[msg.sender];
        if(amount > 0){
            msg.sender.call.value(amount)();
            userBalance[msg.sender] = 0;
        }
    }
}
contract Attacker {
    function() payable {}
    Victim victim;
    function reentry(address addr){
        victim = Victim(addr);
        victim.withdraw();
    }
}
```

`可能的解决方案`：以太坊中有三种`Call`方法可用于发送以太币，即`address.send()`、`address.transfer()`和`address.call.value()`。`address.send()`和`address.transfer()`将更改最大gas限制为2300 gas单位，如果接收者是合约账户，则2300 gas单位不足以传输以太币，这意味着这两种方法不能导致重入漏洞。因此，使用`address.send()`和`address.transfer()`代替`address.call.value()`可以避免重入漏洞。

(5) `嵌套调用 (NC)`：`CALL`指令非常昂贵（9000 gas用于非零值传输作为`CALL`操作的一部分）[2]。如果循环包含`CALL`指令但未限制循环迭代次数，总gas费用可能有很大风险超过其gas上限。

`示例`：在列表5中，如果我们不限制循环迭代次数，攻击者可以恶意增加其大小，导致`out-of-gas`错误。一旦发生`out-of-gas`错误，此功能将无法再工作，因为无法减少循环迭代次数。

```
for(uint i = 0; i < member.length; i++){
    member[i].send(1 wei);
}
```

`可能的解决方案`：开发人员应估算最大循环迭代次数并限制循环迭代次数。

(6) `贪婪合约 (GC)`：智能合约中的以太币只能通过向其他账户或使用`selfdestruct`发送以太币进行提取。否则，智能合约的创建者甚至无法提取以太币，这些以太币将永远锁定。因此，如果合约可以接收以太币（包含可支付函数）但没有方法转移给其他人，则称该合约为贪婪合约。

`示例`：列表6是一个贪婪合约。该合约包含一个可支付的回退函数（第2行），可以接收以太币，但合约中没有任何方法提取以太币。

```
contract Greedy {
    function() payable {}
    function process(address addr) {...}
}
```

`可能的解决方案`：如果合约可以接收以太币，应添加一个函数以提取这些以太币。

(7) `未检查的外部调用 (UEC)`：Solidity 提供了多种函数（`address.send()`、`address.call()`）用于在合约之间转移以太币或调用函数。然而，这些与调用相关的方法可能会失败，例如出现网络错误或`out-of-gas`错误。当错误发生时，这些函数会返回布尔值但从不抛出异常。如果调用者不检查外部调用的返回值，他们无法确保以下代码逻辑正确执行。

`示例`：列表7显示了这样一个示例。第1行没有检查`address.send()`的返回值。当以太币转账失败时，第1行无法确保以下代码逻辑的执行是否正确。

```
address.send(ethers);
doingSomething(); //bad
if(address.send(ethers)) doingSomething(); //good
```

`可能的解决方案`：始终检查`address.send()`和`address.call()`的返回值。

(8) `区块信息依赖性 (BID)`：开发者可以利用一系列与区块相关的函数来获取区块信息。例如，`block.blockhash`用于获取当前区块的哈希值。许多智能合约依赖这些函数来决定程序的执行，例如生成随机数。然而，矿工可以影响区块信息，例如矿工可以将区块时间戳延迟约900秒[20]。在这种情况下，区块信息依赖操作在一定程度上可以被矿工控制。

`示例`：列表8中的合约是一个轮盘合约。该合约使用区块哈希值来选择获胜者，并向获胜者发送1个以太币作为奖励。然而，矿工可以控制结果，因此矿工可以始终成为赢家。

```
address[] participators;
uint winnerID = uint(block.blockhash) % participators.length;
participators[winnerID].transfer(1 ether);
```

`可能的解决方案`：安全随机数的前提是该随机数不能被单个用户控制，例如矿工。在以太坊中，我们可以使用完全随机的信息，包括用户地址、用户的输入数字等。此外，隐藏合约使用的值以及其他玩家避免攻击也是很重要的。由于我们无法隐藏以太坊中用户及其提交的值，一种可能的解决方案是使用哈希数来生成随机数。该算法有三个回合：

- `回合 1`：用户获得一个随机数并在本地机器上生成一个哈希值。该哈希值可以通过`keccak256`函数生成，确保信息保密。
- `回合 2`：所有用户提交哈希值后，用户需要提交原始的随机数。合约通过使用相同的`keccak256`函数检查是否可以通过原始数生成相同的哈希值。
- `回合 3`：如果所有用户提交正确的原始数，合约可以使用原始数来生成随机数。


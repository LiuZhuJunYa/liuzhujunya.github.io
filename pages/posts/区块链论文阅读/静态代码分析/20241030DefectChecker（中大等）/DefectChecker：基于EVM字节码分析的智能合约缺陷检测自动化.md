---
title: DefectChecker：基于EVM字节码分析的智能合约缺陷检测自动化
date: 2024-10-30
tags: 
  - 静态代码分析
  - 区块链
  - 智能合约
  - 以太坊
  - 合约缺陷检测
  - 字节码分析
  - 符号执行
categories: 
  - 论文阅读
---

# DefectChecker：基于 EVM 字节码分析的智能合约缺陷检测自动化

## 摘要

智能合约是在区块链上运行的图灵完备程序。它们是不可变的，一旦部署后即便发现错误也无法修改。因此，在将智能合约部署到区块链之前，确保其无错误且设计完善极为重要。合约缺陷是指智能合约中的错误、缺陷或漏洞，这些问题可能导致合约产生错误或意外结果，或者因意外行为而无法正常工作。检测和消除合约缺陷可以避免潜在的攻击，增强程序的鲁棒性。我们之前的工作定义了 20 种智能合约缺陷，并将其分为五个影响级别。根据我们的分类，从 1 到 3 级的缺陷可能导致不安全行为，例如合约被攻击者控制。在本文中，我们提出了一种名为`DefectChecker`的工具，它基于符号执行的方法来检测以太坊区块链平台上智能合约的缺陷。`DefectChecker`可以从智能合约的字节码中检测出缺陷。我们通过将其应用于一个开源数据集来验证`DefectChecker`的性能。评估结果显示，`DefectChecker`在整个数据集中的 F-score 很高（88.8%），并且平均分析一个智能合约只需 0.15 秒。我们还将`DefectChecke`应用于以太坊平台上的 165,621 个智能合约，结果发现有 25,815 个智能合约至少包含一个属于 1 到 3 级影响的缺陷，其中包括一些真实的攻击案例。

`索引术语`——智能合约，以太坊，合约缺陷检测，字节码分析，符号执行

## 引言

近年来，去中心化加密货币引起了广泛关注。为了确保这些系统在没有中心化组织管理的情况下仍然具有可扩展性和安全性，去中心化加密货币采用区块链概念作为其基础技术。比特币[1]是第一个数字货币，它允许用户通过编码脚本自动处理交易。然而，比特币中的脚本不是图灵完备的，这限制了它们在货币转账或支付等应用上的能力。为了应对这一限制，以太坊[2]引入了一种名为智能合约的技术，这是一种在区块链上运行的图灵完备程序。通过利用该技术，实践者可以开发去中心化应用程序（DApps）[3]，并将区块链技术应用于游戏[4]和金融[5]等不同领域。

智能合约通常使用高级编程语言编写，例如Solidity[6]。当开发者将智能合约部署到以太坊时，合约首先会被编译为以太坊虚拟机（EVM）字节码。然后，以太坊系统中的每个节点都会接收到智能合约的字节码并在其分类账中保留一个副本。任何人，包括攻击者，都可以通过向相应的合约地址发送交易来调用该智能合约。

智能合约的关键特性使其成为黑客的有吸引力目标[7]。一方面，许多智能合约持有有价值的以太币，且无法隐藏其余额，这为黑客提供了经济动机[8]，[9]。另一方面，智能合约在无权限网络中运行，这意味着黑客可以自由地检查所有交易和字节码，并尝试找到合约中的漏洞。更糟的是，智能合约一旦部署，即便发现了错误也无法修改。因此，在将智能合约部署到以太坊之前，确保其无错误且设计完善至关重要。

合约缺陷[10]，[11]是指导致智能合约产生不正确或意外结果，或以意外方式行为的错误、缺陷或漏洞[12]。检测和消除合约缺陷是避免潜在攻击并改进现有代码设计的方法。在我们之前的工作中[11]，我们通过分析 StackExchange[13]帖子首先定义了 20 种合约缺陷。这也是第一个通过在线调查验证智能合约开发者是否认为这些缺陷有害的工作，这使得定义更具说服力。我们的工作将定义的 20 种合约缺陷分为五个影响级别，结果表明包含 1 到 3 级缺陷的智能合约可能导致不安全行为，例如合约被攻击者控制。

然而，我们之前的工作并未提出一种可以检测这些合约缺陷的合适工具。为了解决这一局限性，本文提出了`DefectChecker`，用于检测我们之前工作中定义的对合约造成严重影响（1 级为高，3 级为中）的缺陷，使用智能合约的字节码进行检测。`DefectChecker`通过字节码进行符号执行，无需源代码支持。在符号执行过程中，`DefectChecke`生成智能合约的控制流图（CFG）以及“堆栈事件”，并识别三种特征，即“资金调用”、“循环块”和“应付函数”。通过使用CFG、堆栈事件和这三种特征，我们设计了相应的规则来检测每种合约缺陷。

我们通过应用到我们之前工作中开发的开源数据集来验证`DefectChecker`的性能[11]。我们还将其结果与三种先进工具（如`Oyente`、`Mythril`和`Securify`）进行比较。评估结果表明，`DefectChecker`在整个数据集中的 F-score 最高（88.8%），并且分析一个智能合约的时间最短（每个合约 0.15 秒），相比其他基线工具。我们还提取了截至 2019 年 1 月部署到以太坊上的所有智能合约字节码，并将`DefectChecker`应用于 165,621 个不同的字节码智能合约。结果发现，以太坊上的智能合约中有 15.9% 至少包含一个属于 1 到 3 级影响的缺陷。

本工作的主要贡献如下：

- 据我们所知，`DefectChecker`是目前最准确且最快的基于符号执行的智能合约缺陷检测工具。
- 我们系统地评估了工具的性能，使用一个开源数据集进行测试。此外，我们还提取了以太坊平台上的所有字节码（165,621个），并确定其中25,815个智能合约包含至少一个缺陷。通过这些分析，我们发现了一些真实世界的攻击案例，并举例说明了检测合约缺陷的重要性。
- 我们的数据集、工具和分析结果已向社区开放：https://github.com/Jiachi-Chen/DefectChecker/。

本文其余部分的组织如下。在第 2 节中，我们提供了智能合约的背景知识，并介绍了带有代码示例的合约缺陷。在第 3 节中，我们介绍了`DefectChecker`的架构，在第 4 节中，我们介绍了其表示和实现。在第 5 节中，我们对在以太坊智能合约上的大规模案例研究进行了评估，并在第 6 节中给出了真实案例作为案例研究。在第 6 节中，我们介绍了相关工作。最后，我们在第 7 节中总结了本研究并讨论了未来可能的工作。

## 背景与动机

在本节中，我们简要介绍了关于智能合约及其合约缺陷的关键背景信息。

### 智能合约

合约。利用区块链技术，智能合约是在区块链上存储的自治协议。一旦启动，合约的运行是自动的，并且按照预先定义的程序逻辑进行[14]。当开发人员将智能合约部署到以太坊时，合约将被编译为 EVM 字节码，并由唯一的 160 位十六进制哈希合约地址标识。智能合约的执行取决于其代码，即使是合约创建者也无法影响其运行或状态。例如，如果合约不包含以太币转账的功能，即使是创建者也无法提取以太币。智能合约运行在无权限网络中，任何人都可以通过 ABI（应用程序二进制接口）[6]调用智能合约的方法。合约字节码、交易和调用参数对所有人都是公开的。

`Gas 系统`。为了确保智能合约的安全性，智能合约的每笔交易都将由所有矿工运行。以太坊使用 gas 系统[15]来衡量其计算工作量，发送交易以调用智能合约的开发人员需要支付执行费用。执行费用的计算方式为：`$gas\_cost$ $\times$ $gas\_price$`。gas 费用取决于执行所需的计算资源，而 gas 价格则由交易创建者提供。为了限制调用交易的 gas 费用，开发人员会设置 Gas 上限，以确定最大 gas 费用。如果交易的 gas 费用超过了 Gas 上限，则会失败并抛出`out-of-gas`错误[2]。某些特殊操作将会对 Gas 上限设定特定值。例如，`address.transfer()`和`address.send()`是以太坊提供的两种用于转移以太币的方法。如果智能合约使用这些方法向另一个智能合约发送以太币，Gas 上限将限制为 2300 gas 单位[6]。2300 gas 单位不足以进行存储、调用函数或发送以太币，这可能导致交易失败。因此，`address.transfer()`和`address.send()`只能用于向外部账户发送以太币（外部账户指由私钥控制的账户，与合约代码控制的合约账户不同[2]）。

`以太坊虚拟机（EVM）`。为了将智能合约部署到以太坊，其源代码需要编译为字节码并存储在区块链上。EVM 是一种基于堆栈的机器：当需要执行交易时，EVM 会首先将字节码拆分为字节，每个字节表示唯一的指令，称为操作码。截至 2019 年 4 月，共有 140 个唯一的操作码[2]，每个操作码由十六进制编号表示[2]。EVM 使用这些操作码执行任务。例如，考虑一个字节码`0x6070604001`。EVM 首先将该字节码拆分为字节（`0x60`，`0x70`，`0x60`，`0x40`，`0x01`），并执行第一个字节`0x60`，其操作码为`PUSH1`。`PUSH1`将一个字节数据推送到EVM堆栈中。因此，`0x70`被推送到堆栈中。然后，EVM 读取下一个`0x60`并将`0x40`推入堆栈。最后，EVM 执行`0x01`，其操作码为`ADD`。`ADD`从堆栈顶部获取两个值，即`0x70`和`0x40`，并将它们的和（`B0`）推入堆栈。

`EVM 字节码与控制流分析中的 JVM 字节码`。控制流分析方法在其他基于堆栈的机器（例如 JVM[16]）中被广泛使用。然而，JVM 字节码与 EVM 字节码之间存在一些差异。这些差异在分析 EVM 字节码时提出了一些新的挑战。我们在本文中强调了 EVM 字节码分析方法与 JVM 字节码分析的关键差异，包括：

1. JVM 字节码在不同的控制流路径下具有固定的堆栈深度。而 EVM 无法在具有不同堆栈大小的情况下到达同一程序点[17]。EVM 字节码没有这种约束，这大大增加了识别 EVM 字节码中控制流结构的难度。例如，对于简单的递归代码“`function f(int a){f(a);}`”，其在 EVM 中的代码如下：

```
Block 1:
  JUMPDEST
  PUSH Block1' ID
  DUP2
  PUSH Block2' ID
  JUMP
Block 2:
  JUMPDEST
```





---

1. 在JVM中，每个方法调用都会生成一个新操作数栈，而EVM仅有一个全局操作数栈。（一个帧用于存储数据和部分结果，并用于执行动态链接、方法返回值和调度异常）。
2. JVM字节码为每个跳转定义了明确的目标集[19]。相比之下，EVM字节码的跳转目标从EVM堆栈中读取。当使用条件跳转时，目标将受堆栈第二项影响。例如，在图2中，跳转目标`JUMPI`（ID 140）从先前的指令`PUSH`读取，并将受堆栈第二项（例如，`ISZERO(GT(10, num))`）的影响。如果第二项为真值，则跳转目标为148；否则，目标为141。无条件跳转目标也从EVM堆栈顶部读取。例如，图2中的`JUMP`（ID 147）的跳转目标也从之前的指令`PUSH`读取。因此，我们需要通过符号执行EVM字节码来构造控制流边。

`Fallback函数`。Fallback函数是智能合约相较于传统程序的一项独特特性。在智能合约编程中，Fallback函数是唯一没有命名的函数[6]。当交易调用合约中的某个函数但没有找到对应的函数时，Fallback函数将被自动执行。如果函数被标记为`payable`[6]，则在收到以太币时Fallback函数也会自动执行。

`CALL指令和以太币转移`。以太币转移是以太坊中的一个重要功能。在Solidity编程中，有三种方法用于转移以太币，即`address.call.value()`，`address.transfer()`，和`address.send()`。在这三种方法中，只有`address.call.value()`允许用户将以太币发送到合约地址，而其他两种方法限制为2300 gas单位，这不足以发送以太币。`address.send()`返回一个布尔值，而`address.transfer()`在错误发生时抛出异常。这三种方法都可以在合约字节码中生成`CALL`指令。其他行为（例如函数调用）也可以生成`CALL`指令。`CALL`指令从EVM堆栈顶部读取七个值。它们代表gas限制、接收地址、转移金额、输入数据起始位置、输入数据大小、输出数据起始位置和输出数据大小。